# Cобеседование по Java. Разбор вопросов и ответов.


<a href="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%">
    <img src="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%" />
  </a>&nbsp;&nbsp;
<a href="https://mc.yandex.ru/watch/92801430">
    <img src="https://mc.yandex.ru/watch/92801430" />
  </a>&nbsp;&nbsp;

с 2681 вопрос по 2729 вопрос


Нажмите ★, если вам нравится проект. Ваш вклад сердечно ♡ приветствуется.

Если вам интересно мое резюме: https://github.com/DEBAGanov




Собеседование по Java EE — Java Persistence API (JPA)
## 2681. Что такое JPA?
## 2682. В чем её отличие JPA от Hibernate?
## 2683. Можно ли использовать JPA c noSQl базами?
## 2684. В чем её отличие JPA от JDO?
## 2685. Что такое Entity?
## 2686. Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?
## 2687. Может ли Entity класс наследоваться от других Entity классов?
## 2688. Может ли не Entity класс наследоваться от Entity класса?
## 2689. Может ли Entity быть абстрактным классом?
## 2690. Какие требования JPA к Entity классам вы можете перечислить (не менее шести требований)?
## 2691. Какие два типа элементов есть у Entity классов. Или другими словами перечислите два типа доступа (access) к элементам Entity классов.
## 2692. Что такое атрибут Entity класса в терминологии JPA?
## 2693. Какие типы данных допустимы в атрибутах Entity класса (полях или свойствах)?
## 2694. Какие типы данных можно использовать в атрибутах, входящих в первичный ключ Entity класса (составной или простой), чтобы полученный первичный ключ мог использоваться для любой базы данных? А в случае автогенерируемого первичного ключа (generated primary keys)?
## 2695. Что такое встраиваемый (Embeddable) класс?
## 2696. Может ли встраиваемый (Embeddable) класс содержать другой встраиваемый (Embeddable) класс?
## 2697. Может ли встраиваемый (Embeddable) класс содержать связи (relationship) с другими Entity или коллекциями Entity? Если может, то существуют ли какие-то ограничение на такие связи (relationship)?
## 2698. Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?
## 2699. Какие типы связей (relationship) между Entity вы знаете (перечислите восемь типов, либо укажите четыре типа связей, каждую из которых можно разделить ещё на два вида)?
## 2700. Что такое Mapped Superclass?
## 2701. Какие три типа стратегии наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?
## 2702. Какие два типа fetch стратегии в JPA вы знаете?
## 2703. Что такое EntityManager и какие основные его функции вы можете перечислить?
## 2704. Какие четыре статуса жизненного цикла Entity объекта (Entity Instance’s Life Cycle) вы можете перечислить?
## 2705. Как влияет операция persist на Entity объекты каждого из четырех статусов?
## 2706. Как влияет операция remove на Entity объекты каждого из четырех статусов?
## 2707. Как влияет операция merge на Entity объекты каждого из четырех статусов?
## 2708. Как влияет операция refresh на Entity объекты каждого из четырех статусов?
## 2709. Как влияет операция detach на Entity объекты каждого из четырех статусов?
## 2710. Для чего нужна аннотация Basic?
## 2711. Для чего нужна аннотация Access?
## 2712. Какими аннотациями можно перекрыть связи (override entity relationship) или атрибуты, унаследованные от суперкласса, или заданные в embeddable классе при использовании этого embeddable класса в одном из entity классов и не перекрывать в остальных?
## 2713. Какой аннотацией можно управлять кешированием JPA для данного Entity?
## 2714. Какие аннотации служит для задания класса преобразования basic атрибута Entity в другой тип при сохранении/получении данных их базы (например, работать с атрибутом Entity boolean типа, но в базу сохранять его как число)?
## 2715. Какой аннотацией можно задать класс, методы которого должен выполнится при определенных JPA операциях над данным Entity или Mapped Superclass (такие как удаление, изменение данных и т.п.)?
## 2716. Для чего нужны callback методы в JPA? К каким сущностям применяются аннотации callback методов? Перечислите семь callback методов (или что тоже самое аннотаций callback методов)
## 2717. Какие аннотации служить для установки порядка выдачи элементов коллекций Entity?
## 2718. Какой аннотацей можно исключить поля и свойства Entity из маппинга (property or field is not persistent)?
## 2719. Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?
## 2720. Какие есть варианты настройки second-level cache (кэша второго уровня) в JPA или что аналогично опишите какие значения может принимать элемент shared-cache-mode из persistence.xml?
## 2721. Как можно изменить настройки fetch стратегии любых атрибутов Entity для отдельных запросов (query) или методов поиска (find), то если у Entity есть атрибут с fetchType = LAZY, но для конкретного запроса его требуется сделать EAGER или наоборот?
## 2722. Каким способом можно в коде работать с кэшем второго уровня (удалять все или определенные Entity из кеша, узнать закэшировался ли данное Entity и т.п.)?
## 2723. Каким способом можно получить метаданные JPA (сведения о Entity типах, Embeddable и Managed классах и т.п.)?
## 2724. Что такое JPQL (Java Persistence query language) и чем он отличается от SQL?
## 2725. Что означает полиморфизм (polymorphism) в запросах JPQL (Java Persistence query language) и как его «выключить»?
## 2726. Что такое Criteria API и для чего он используется?
## 2727. В чем разница в требованиях к Entity в Hibernate, от требований к Entity, указанных в спецификации JPA (см. вопрос 10)?
## 2728. Какая уникальная стратегия наследования есть в Hibernate, но нет в спецификации JPA?
## 2729. Какие основные новые возможности появились в спецификации JPA 2.1 по сравнению с JPA 2.0 (перечислите хотя бы пять-шесть новых возможностей)?






## 2730. Что такое Hibernate Framework?
Hibernate Framework - это фреймворк для языка Java, который облегчает взаимодействие с базами данных. Hibernate предоставляет инструменты для работы с объектно-реляционным отображением (ORM) и упрощает выполнение операций CRUD (Create, Read, Update, Delete) с базой данных.

Основные особенности Hibernate включают:

+ Поддержку объектно-реляционного отображения (ORM), что позволяет разработчикам работать с объектами Java, а не с SQL-запросами напрямую.
+ Автоматическое создание SQL-запросов и управление соединениями с базой данных.
+ Кэширование данных для повышения производительности.
+ Поддержка транзакций и управление сеансами работы с базой данных.
+ Hibernate является открытым исходным кодом и распространяется под лицензией GNU Lesser General Public License.

Основные возможности Hibernate Framework:
+ Hibernate Framework предоставляет инструменты для работы с объектно-реляционным отображением (ORM) в Java.
+ Он облегчает выполнение операций CRUD (Create, Read, Update, Delete) с базой данных.
+ Hibernate автоматически создает SQL-запросы и управляет соединениями с базой данных.
+ Фреймворк поддерживает кэширование данных для повышения производительности.
+ Hibernate обеспечивает поддержку транзакций и управление сеансами работы с базой данных.
## 2731. Что такое ORM?

ORM (Object-Relational Mapping) в Java - это фреймворк, который позволяет разработчикам работать с базами данных, используя объектно-ориентированный подход. ORM обеспечивает автоматическое отображение данных из реляционной базы данных в объекты Java и обратно, что упрощает взаимодействие с базой данных и устраняет необходимость писать прямые SQL-запросы.

ORM в Java предоставляет различные функции, такие как создание, чтение, обновление и удаление (CRUD) объектов, управление транзакциями, поддержку связей между объектами и многое другое. Один из популярных фреймворков ORM в Java - Hibernate, который предоставляет богатый набор инструментов для работы с базами данных.

Основные преимущества ORM в Java:

+ Упрощение работы с базами данных и сокращение количества кода, необходимого для выполнения операций с данными.
+ Повышение производительности и безопасности, так как ORM обеспечивает генерацию безопасных SQL-запросов и оптимизацию доступа к данным.
+ Поддержка переносимости кода между различными СУБД, так как ORM абстрагирует различия между СУБД и предоставляет унифицированный интерфейс для работы с ними.
+ Улучшение тестируемости кода, так как ORM позволяет легко создавать и управлять тестовыми данными.

Примеры фреймворков ORM в Java:

+ Hibernate: Один из самых популярных и широко используемых фреймворков ORM в Java. Hibernate предоставляет мощные инструменты для работы с базами данных и имеет обширную документацию и сообщество разработчиков.
+ EclipseLink: Еще один популярный фреймворк ORM в Java, который предоставляет реализацию стандарта Java Persistence API (JPA).
+ MyBatis: Фреймворк ORM в Java, который предоставляет более низкоуровневый подход к работе с базами данных, позволяя разработчикам писать SQL-запросы в XML-файлах.
## 2732. Какие важные преимущества дает использование Hibernate Framework?
Hibernate Framework представляет собой мощный инструмент для работы с базами данных в Java-приложениях. Вот некоторые из важных преимуществ, которые он предоставляет:

1. ORM (Object-Relational Mapping): Hibernate позволяет разработчикам работать с базами данных, используя объектно-ориентированный подход. Он обеспечивает прозрачное отображение объектов Java на таблицы базы данных и автоматически выполняет операции CRUD (Create, Read, Update, Delete) без необходимости писать SQL-запросы вручную.

2. Упрощенная работа с базами данных: Hibernate обеспечивает абстракцию от специфических для базы данных деталей, позволяя разработчикам сосредоточиться на бизнес-логике приложения. Он автоматически генерирует SQL-запросы и управляет соединениями с базой данных, что упрощает разработку и поддержку приложений.

3. Кросс-платформенность: Hibernate является кросс-платформенным фреймворком, который может работать с различными базами данных, включая MySQL, Oracle, PostgreSQL и другие.

4. Кэширование: Hibernate предоставляет механизмы кэширования, которые позволяют улучшить производительность приложения. Он поддерживает различные виды кэширования, включая кэширование объектов, запросов и метаданных.

5. Hibernate Query Language (HQL): HQL представляет собой объектно-ориентированный язык запросов, который позволяет разработчикам выполнять сложные запросы к базе данных, используя объекты и связи между ними, а не язык SQL. Это делает код более читаемым и поддерживаемым.

6. Транзакционная поддержка: Hibernate обеспечивает управление транзакциями, что позволяет разработчикам выполнять операции с базой данных в рамках одной или нескольких транзакций. Это обеспечивает целостность данных и предотвращает возникновение проблем с параллельным доступом к данным.

7. Интеграция с Java EE: Hibernate является частью Java EE и хорошо интегрируется с другими технологиями Java, такими как JavaServer Faces (JSF), Java Servlets, JavaServer Pages (JSP) и другими.

8. Обратная совместимость: Hibernate обеспечивает обратную совместимость с предыдущими версиями, что позволяет разработчикам безопасно обновляться на новые версии фреймворка без необходимости внесения значительных изменений в код.

9. Большое сообщество и поддержка: Hibernate имеет большое сообщество разработчиков и активно поддерживается. Это означает, что разработчики могут легко найти ресурсы, документацию и помощь в решении проблем.

10. Расширяемость: Hibernate предоставляет возможность расширения и настройки для удовлетворения специфических потребностей приложения.

В целом, использование Hibernate Framework позволяет разработчикам упростить работу с базами данных, повысить производительность и поддерживаемость приложений, а также сосредоточиться на бизнес-логике.
## 2733. Какие преимущества Hibernate над JDBC?
Hibernate имеет несколько преимуществ по сравнению с JDBC:

+ Упрощенная разработка: Hibernate предоставляет высокоуровневый объектно-реляционный маппинг (ORM), который позволяет разработчикам работать с объектами Java, а не с низкоуровневыми SQL-запросами. Это упрощает разработку и позволяет сосредоточиться на бизнес-логике приложения.
+ Улучшенная производительность: Hibernate использует различные оптимизации, такие как кэширование запросов и объектов, чтобы улучшить производительность приложения. Кэширование запросов позволяет избежать повторного выполнения одних и тех же запросов к базе данных, а кэширование объектов позволяет избежать повторного извлечения данных из базы данных.
+ Удобство работы с объектами: Hibernate позволяет работать с объектами Java, а не с наборами данных, что делает код более понятным и удобным для разработчиков. Он предоставляет возможность автоматического преобразования данных из базы данных в объекты Java и обратно.
+ Поддержка транзакций: Hibernate предоставляет механизм управления транзакциями, который позволяет выполнять операции с базой данных в рамках одной транзакции. Это обеспечивает целостность данных и позволяет откатывать изменения в случае ошибок.
+ Поддержка различных баз данных: Hibernate поддерживает различные базы данных, включая MySQL, Oracle, PostgreSQL и другие. Это позволяет разработчикам использовать Hibernate в различных проектах, независимо от используемой базы данных.
+ Удобство тестирования: Hibernate обеспечивает удобство тестирования приложений, так как позволяет использовать инструменты для создания и заполнения тестовых баз данных, а также упрощает проверку результатов операций с базой данных.
+ Расширяемость: Hibernate предоставляет возможность расширения функциональности с помощью пользовательских типов данных, пользовательских запросов и других расширений. Это позволяет адаптировать Hibernate под конкретные требования проекта.

Важно отметить, что Hibernate и JDBC могут использоваться вместе, и в некоторых случаях JDBC может быть предпочтительным для выполнения определенных задач
## 2734. Назовите некоторые важные интерфейсы Hibernate.
Hibernate - это фреймворк для объектно-реляционного отображения (ORM) в Java. Он предоставляет различные интерфейсы для работы с базой данных. Некоторые из важных интерфейсов Hibernate в Java включают:

+ SessionFactory: Интерфейс SessionFactory является фабрикой для создания объектов Session, которые представляют сеансы работы с базой данных. Он отвечает за создание и управление соединениями с базой данных.
+ Session: Интерфейс Session представляет сеанс работы с базой данных в Hibernate. Он предоставляет методы для выполнения операций CRUD (создание, чтение, обновление, удаление) и других операций, таких как загрузка объектов, выполнение запросов и управление транзакциями.
+ Transaction: Интерфейс Transaction используется для управления транзакциями в Hibernate. Он предоставляет методы для начала, фиксации и отката транзакций.
+ Query: Интерфейс Query используется для выполнения запросов к базе данных в Hibernate. Он предоставляет методы для создания и выполнения запросов на языке Hibernate Query Language (HQL) или SQL.
+ Criteria: Интерфейс Criteria предоставляет возможность создания запросов к базе данных с использованием критериев. Он позволяет строить запросы с помощью объектов-критериев, что облегчает создание динамических запросов.
+ TransactionManager: Интерфейс TransactionManager предоставляет методы для управления транзакциями в Hibernate. Он позволяет начинать, фиксировать и откатывать транзакции.
+ Interceptor: Интерфейс Interceptor используется для перехвата и изменения операций, выполняемых Hibernate. Он позволяет настраивать и настраивать поведение Hibernate с помощью пользовательского кода.
+ SessionFactoryBuilder: Интерфейс SessionFactoryBuilder используется для создания объектов SessionFactory. Он предоставляет методы для настройки и создания SessionFactory.

Примечание: Это лишь некоторые из важных интерфейсов Hibernate в Java. Hibernate предлагает еще множество других интерфейсов и классов для различных задач работы с базой данных.
## 2735. Что такое конфигурационный файл Hibernate?
Конфигурационный файл Hibernate - это файл, который содержит настройки и параметры для работы фреймворка Hibernate. Hibernate - это инструмент для работы с базами данных в Java приложениях. Конфигурационный файл Hibernate определяет, как Hibernate должен взаимодействовать с базой данных, включая информацию о подключении к базе данных, настройки кэширования, маппинг объектов на таблицы и другие параметры.

В конфигурационном файле Hibernate можно указать различные настройки, такие как:

+ Имя драйвера базы данных и URL для подключения к базе данных.
+ Имя пользователя и пароль для доступа к базе данных.
+ Стратегию генерации идентификаторов для объектов.
+ Маппинг объектов на таблицы базы данных.
+ Настройки кэширования для повышения производительности.
+ Другие параметры, связанные с работой Hibernate.

Пример содержимого конфигурационного файла Hibernate может выглядеть следующим образом:
```xml
<hibernate-configuration>
    <session-factory>
        <property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>
        <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property>
        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/mydatabase</property>
        <property name="hibernate.connection.username">myusername</property>
        <property name="hibernate.connection.password">mypassword</property>
        <property name="hibernate.show_sql">true</property>
        <property name="hibernate.format_sql">true</property>
        <!-- Другие настройки Hibernate -->
    </session-factory>
</hibernate-configuration>
```
В этом примере указаны настройки для подключения к базе данных MySQL, включая имя драйвера, URL, имя пользователя и пароль. Также включены настройки для вывода SQL-запросов и форматирования SQL-кода.

Примечание: Конфигурационный файл Hibernate может иметь различный формат в зависимости от версии Hibernate и используемого языка программирования. Приведенный пример является простым примером для иллюстрации структуры конфигурационного файла Hibernate. Реальный конфигурационный файл может содержать и другие настройки и параметры
## 2736. Что такое Hibernate mapping file?
ibernate mapping file в Java - это файл конфигурации, который используется для определения отображения между классами Java и таблицами в базе данных при использовании фреймворка Hibernate. Этот файл содержит информацию о том, как поля класса Java соответствуют столбцам в таблице базы данных, а также о связях между различными классами и таблицами.

Файл маппинга Hibernate обычно имеет расширение .hbm.xml и содержит информацию о классе, его свойствах, атрибутах и отношениях с другими классами. Он также может содержать дополнительные настройки, такие как настройки кэширования и стратегии идентификации.

Пример содержимого файла маппинга Hibernate:
```xml
<hibernate-mapping>
    <class name="com.example.User" table="users">
        <id name="id" column="user_id">
            <generator class="increment"/>
        </id>
        <property name="name" column="user_name"/>
        <property name="email" column="user_email"/>
        <many-to-one name="role" class="com.example.Role" column="role_id"/>
    </class>
</hibernate-mapping>
```
В этом примере файл маппинга определяет отображение класса User на таблицу users в базе данных. Он указывает, что поле id класса User соответствует столбцу user_id в таблице, а поля name и email соответствуют столбцам user_name и user_email соответственно. Он также указывает на связь между классом User и классом Role через поле role_id
## 2737. Назовите некоторые важные аннотации, используемые для отображения в Hibernate.

Hibernate - это фреймворк для работы с базами данных в Java. В Hibernate существует несколько важных аннотаций, которые используются для отображения объектов Java на таблицы базы данных. Вот некоторые из них:

+ @Entity: Эта аннотация указывает, что класс является сущностью, которая будет отображаться на таблицу в базе данных.
+ @Table: Эта аннотация указывает имя таблицы, к которой будет отображаться сущность.
+ @Column: Эта аннотация указывает, что поле класса будет отображаться на столбец в таблице базы данных.
+ @Id: Эта аннотация указывает, что поле является первичным ключом сущности.
+ @GeneratedValue: Эта аннотация указывает, что значение первичного ключа будет генерироваться автоматически.
+ @OneToOne: Эта аннотация указывает, что между двумя сущностями существует связь "один к одному".
+ @OneToMany: Эта аннотация указывает, что между двумя сущностями существует связь "один ко многим".
+ @ManyToOne: Эта аннотация указывает, что между двумя сущностями существует связь "многие к одному".
+ @ManyToMany: Эта аннотация указывает, что между двумя сущностями существует связь "многие ко многим".

Это лишь некоторые из важных аннотаций, используемых в Hibernate. Они позволяют определить отображение объектов Java на таблицы базы данных и устанавливают связи между сущностями.
## 2738. Что вы знаете о Hibernate SessionFactory и как его сконфигурировать?

Hibernate SessionFactory - это ключевой компонент в фреймворке Hibernate, который отвечает за создание и управление сессиями Hibernate. Сессия Hibernate представляет собой интерфейс для взаимодействия с базой данных и выполняет операции сохранения, обновления, удаления и извлечения данных.

Для конфигурации SessionFactory в Hibernate требуется указать несколько параметров, таких как URL базы данных, имя пользователя, пароль и драйвер базы данных. Кроме того, необходимо указать файл маппинга, который определяет соответствие между классами Java и таблицами базы данных.

Вот пример конфигурации SessionFactory в Hibernate:
```java
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class HibernateUtil {
    private static final SessionFactory sessionFactory;

    static {
        try {
            Configuration configuration = new Configuration();
            configuration.configure("hibernate.cfg.xml");
            sessionFactory = configuration.buildSessionFactory();
        } catch (Throwable ex) {
            throw new ExceptionInInitializerError(ex);
        }
    }

    public static SessionFactory getSessionFactory() {
        return sessionFactory;
    }
}
```
В этом примере мы используем файл конфигурации "hibernate.cfg.xml", который содержит информацию о подключении к базе данных и маппинге классов Java. Мы создаем объект Configuration, загружаем конфигурацию из файла и строим SessionFactory с помощью метода buildSessionFactory().

Важно отметить, что конфигурация SessionFactory может отличаться в зависимости от версии Hibernate и способа конфигурации, который вы выбираете.
## 2739. Является ли Hibernate SessionFactory потокобезопасным?
## 2740. Как получить Hibernate Session и что это такое?
Hibernate Session - это один из ключевых компонентов Hibernate Framework, который предоставляет интерфейс для взаимодействия с базой данных. Session представляет собой логическую единицу работы с базой данных в рамках одной транзакции. Он обеспечивает методы для сохранения, обновления, удаления и извлечения объектов из базы данных.

Для получения Hibernate Session в приложении можно использовать SessionFactory. SessionFactory - это объект, который создается один раз при запуске приложения и представляет собой фабрику сессий. Он отвечает за создание и управление экземплярами Session.

Вот пример кода, который показывает, как получить Hibernate Session:
```java
// Создание объекта SessionFactory
SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();

// Получение Session из SessionFactory
Session session = sessionFactory.openSession();

// Использование Session для выполнения операций с базой данных
// Например, сохранение объекта в базу данных
session.beginTransaction();
session.save(object);
session.getTransaction().commit();

// Закрытие Session
session.close();
```

Важно отметить, что в более новых версиях Hibernate рекомендуется использовать метод getCurrentSession() вместо openSession(). getCurrentSession() автоматически управляет жизненным циклом сессии и не требует явного закрытия.
## 2741. Является ли Hibernate Session потокобезопасным?

Hibernate Session в Java не является потокобезопасным. Каждый поток должен иметь свой собственный экземпляр Session для выполнения операций с базой данных. Если несколько потоков пытаются использовать один и тот же экземпляр Session одновременно, могут возникнуть проблемы с согласованностью данных и возникновением ошибок. Поэтому рекомендуется создавать новый экземпляр Session для каждого потока.

Пример использования Hibernate Session в многопоточной среде:
```java
public class MyThread implements Runnable {
    private SessionFactory sessionFactory;

    public MyThread(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    @Override
    public void run() {
        Session session = sessionFactory.openSession();
        // Выполнение операций с базой данных с использованием session
        session.close();
    }
}

// Создание SessionFactory
SessionFactory sessionFactory = // инициализация SessionFactory

// Создание и запуск потоков
Thread thread1 = new Thread(new MyThread(sessionFactory));
Thread thread2 = new Thread(new MyThread(sessionFactory));
thread1.start();
thread2.start();
```

В этом примере каждый поток создает свой собственный экземпляр Session с использованием одной и той же SessionFactory. Каждый поток может безопасно выполнять операции с базой данных с использованием своего экземпляра Session
## 2742. В чем разница между openSession и getCurrentSession

openSession и getCurrentSession - это два метода, используемых в Hibernate для получения объекта сессии. Вот их различия:

openSession:

+ Метод openSession всегда создает новый объект сессии и возвращает его.
+ Вам необходимо явно вызывать методы flush и close для управления этими объектами сессии.
+ Объекты сессии не являются потокобезопасными, поэтому в многопоточной среде вам необходимо создавать один объект сессии на каждый запрос, а в веб-приложениях - один объект сессии на каждый запрос.



getCurrentSession:

+ Метод getCurrentSession предоставляет вам объект сессии, который находится в контексте Hibernate и управляется Hibernate внутренне.
+ Этот объект сессии привязан к области транзакции.
+ Если вызвать getCurrentSession, когда сессия не существует, будет создан новый объект сессии. В противном случае будет использоваться та же самая сессия, которая находится в текущем контексте Hibernate.
+ Сессия автоматически сбрасывается и закрывается при завершении транзакции, поэтому вам не нужно делать это внешне.
+ Если вы используете Hibernate в однопоточной среде, вы можете использовать getCurrentSession, так как это быстрее в производительности по сравнению с созданием новой сессии каждый раз.



Пример использования:
```java
// Использование openSession
Session session = sessionFactory.openSession();
// Выполнение операций с объектом сессии
session.flush();
session.close();

// Использование getCurrentSession
Session session = sessionFactory.getCurrentSession();
// Выполнение операций с объектом сессии
// Нет необходимости вызывать методы flush() и close()
```

Обратите внимание, что для использования getCurrentSession вам необходимо настроить контекст текущей сессии в конфигурации Hibernate, например, установив свойство hibernate.current_session_context_class в значение thread
## 2743. Какая разница между методами Hibernate Session get() и load()?

Методы get() и load() в Hibernate Session используются для получения объектов из базы данных. Вот основные различия между этими методами:

Метод get():

+ Метод get() возвращает объект из базы данных, соответствующий указанному идентификатору.
+ Если объект не найден в базе данных, метод get() вернет null.
+ Метод get() выполняет запрос к базе данных немедленно и возвращает полностью инициализированный объект.
+ Если объект уже находится в сессии Hibernate, метод get() просто возвращает его из сессии, без обращения к базе данных.


Метод load():

+ Метод load() также возвращает объект из базы данных, соответствующий указанному идентификатору.
+ Если объект не найден в базе данных, метод load() генерирует исключение ObjectNotFoundException.
+ Метод load() не выполняет запрос к базе данных немедленно. Вместо этого, он возвращает прокси-объект, который является "ленивым" и будет инициализирован только при доступе к его свойствам.
+ Если объект уже находится в сессии Hibernate, метод load() просто возвращает его из сессии, без обращения к базе данных.


Таким образом, основное отличие между методами get() и load() заключается в том, что get() возвращает полностью инициализированный объект или null, в то время как load() возвращает прокси-объект, который будет инициализирован только при доступе к его свойствам и генерирует исключение, если объект не найден в базе данных.

get () загружает данные сразу при вызове, в то время как load () использует прокси объект и загружает данные только тогда, когда это требуется на самом деле. В этом плане load () имеет преимущество в плане ленивой загрузки данных. load () бросает исключение, когда данные не найдены.
## 2744. Что вы знаете о кэшировании в Hibernate? Объясните понятие кэш первого уровня в Hibernate?

Кэширование в Hibernate - это механизм, который позволяет улучшить производительность приложения, сохраняя часто используемые данные в памяти для более быстрого доступа к ним. Hibernate предоставляет два уровня кэширования: кэш первого уровня и кэш второго уровня.

Кэш первого уровня (также известный как кэш сессии) является встроенным кэшем, который Hibernate предоставляет для каждой сессии. Он хранит объекты, полученные из базы данных во время выполнения операций чтения. Кэш первого уровня является локальным для каждой сессии и не доступен для других сессий или потоков. Когда приложение запрашивает объект из базы данных, Hibernate сначала проверяет наличие объекта в кэше первого уровня. Если объект найден, Hibernate возвращает его из кэша, что позволяет избежать повторного обращения к базе данных.

Кэш первого уровня в Hibernate работает на уровне сессии и автоматически управляется Hibernate. Он обновляется автоматически при выполнении операций сохранения, обновления и удаления объектов. Кэш первого уровня также обеспечивает механизм отслеживания изменений, что позволяет Hibernate эффективно управлять состоянием объектов и автоматически применять изменения в базу данных при необходимости.

Однако, следует помнить, что кэш первого уровня в Hibernate является локальным для каждой сессии и не обеспечивает общий доступ к данным между разными сессиями или потоками. Если необходимо обеспечить общий доступ к данным между разными сессиями или потоками, можно использовать кэш второго уровня.
## 2745. Как настроить кэш второго уровня в Hibernate с помощью EHCache?

Кэш второго уровня в Hibernate представляет собой механизм кэширования данных, который помогает улучшить производительность приложений, использующих Hibernate ORM. Кэш второго уровня хранит данные, полученные из базы данных, в памяти, что позволяет избежать повторных запросов к базе данных при обращении к одним и тем же данным.

Преимущества использования кэша второго уровня в Hibernate:

+ Улучшение производительности приложения путем сокращения количества запросов к базе данных.
+ Снижение нагрузки на базу данных и сеть.
+ Улучшение отзывчивости приложения.
+ Повышение масштабируемости приложения.

Ограничения кэша второго уровня в Hibernate:

+ Кэш второго уровня может занимать дополнительную память.
+ Необходимо правильно настроить стратегии кэширования для каждой сущности или коллекции.
+ В случае изменения данных в базе данных, кэш второго уровня должен быть обновлен, чтобы избежать несогласованности данных.


Для настройки кэша второго уровня в Hibernate с использованием EHCache, вам потребуется выполнить следующие шаги:

+ Добавьте зависимость EHCache в файле конфигурации вашего проекта. Пример зависимости для Maven:
```xml
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-ehcache</artifactId>
    <version>версия</version>
</dependency>
```
+ Создайте файл конфигурации EHCache (например, ehcache.xml) и определите настройки кэша в нем. Пример конфигурации:
```xml
<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="http://www.ehcache.org/ehcache.xsd"
         updateCheck="false">

    <defaultCache
        maxEntriesLocalHeap="10000"
        eternal="false"
        timeToIdleSeconds="120"
        timeToLiveSeconds="120"
        memoryStoreEvictionPolicy="LRU"/>

    <cache name="myCache"
           maxEntriesLocalHeap="1000"
           eternal="false"
           timeToIdleSeconds="300"
           timeToLiveSeconds="600"
           memoryStoreEvictionPolicy="LFU"/>

</ehcache>
```
В этом примере определены два кэша: defaultCache и myCache. Вы можете настроить параметры кэша в соответствии с вашими потребностями.

+ В файле конфигурации Hibernate (например, hibernate.cfg.xml) добавьте следующую настройку для включения кэша второго уровня:
```xml
<property name="hibernate.cache.use_second_level_cache">true</property>
```
+ Укажите провайдер кэша второго уровня в файле конфигурации Hibernate:
```xml
<property name="hibernate.cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property>
```

+ Для каждой сущности, которую вы хотите кэшировать, добавьте аннотацию @Cacheable:
```java
import javax.persistence.Cacheable;
import javax.persistence.Entity;

@Entity
@Cacheable
public class YourEntity {
    // ...
}
```

Это позволит Hibernate кэшировать сущности этого класса.

+ После выполнения этих шагов, кэш второго уровня будет настроен и готов к использованию в вашем проекте Hibernate с EHCache.

Обратите внимание, что приведенные выше шаги являются общими и могут потребовать дополнительной настройки в зависимости от вашего проекта и требований.
## 2746. Какие существуют различные состояния у entity bean

Сущность Entity Bean может находиться в различных состояниях. Вот некоторые из них:

+ Transient (преходящее) состояние: это состояние, в котором сущность только что была создана и еще не связана с постоянным хранилищем данных.
+ Persistent (постоянное) состояние: это состояние, в котором сущность связана с постоянным хранилищем данных и может быть сохранена, обновлена или удалена.
+ Detached (отсоединенное) состояние: это состояние, в котором сущность была отсоединена от постоянного хранилища данных, но все еще содержит данные, которые были сохранены ранее.
+ Removed (удаленное) состояние: это состояние, в котором сущность была помечена для удаления из постоянного хранилища данных, но еще не была фактически удалена.

Это лишь некоторые из возможных состояний сущности Entity Bean. В зависимости от используемого фреймворка и контекста, могут существовать и другие состояния.
## 2747. Как используется вызов метода Hibernate Session merge()?


Метод merge() в Hibernate используется для объединения состояния объекта с состоянием объекта в базе данных. Вот как можно использовать этот метод:

+ Создайте объект, который вы хотите объединить с базой данных.
+ Вызовите метод merge() на объекте Session и передайте в качестве аргумента объект, который вы хотите объединить.
+ Метод merge() вернет объединенный объект, который можно использовать для дальнейшей работы.


Пример использования метода merge():
```java
User user = new User();
user.setName("John");
session.save(user);
session.evict(user);

// Изменяем имя объекта user
user.setName("John Doe");

// Объединяем объект с базой данных
User mergedUser = (User) session.merge(user);
```

В этом примере мы создаем объект User, сохраняем его в базе данных, а затем изменяем его имя. Затем мы вызываем метод merge() на объекте Session и передаем объект user в качестве аргумента. Метод merge() вернет объединенный объект mergedUser, который содержит изменения, сделанные в объекте user.

Обратите внимание, что метод merge() возвращает объединенный объект, поэтому важно сохранить его и использовать его для дальнейшей работы.
## 2748. В чем разница между Hibernate save(), saveOrUpdate() и persist()?

Hibernate предоставляет несколько методов для сохранения объектов в базе данных, таких как save(), saveOrUpdate() и persist(). Вот их различия:


save():

+ Метод save() используется для сохранения нового объекта в базе данных.
+ Если объект уже имеет идентификатор (ID), то save() генерирует исключение.
+ Если объект не имеет идентификатора, то save() генерирует новый идентификатор и сохраняет объект в базе данных.


saveOrUpdate():

+ Метод saveOrUpdate() используется для сохранения или обновления объекта в базе данных.
+ Если объект уже имеет идентификатор (ID), то saveOrUpdate() обновляет его в базе данных.
+ Если объект не имеет идентификатора, то saveOrUpdate() сохраняет его в базе данных.



persist():

+ Метод persist() также используется для сохранения нового объекта в базе данных.
+ Если объект уже имеет идентификатор (ID), то persist() генерирует исключение.
+ Если объект не имеет идентификатора, то persist() сохраняет его в базе данных.
+ Отличие persist() от save() заключается в том, что persist() не гарантирует мгновенное выполнение операции сохранения в базе данных. Она может быть отложена до момента фиксации транзакции или выполнения других операций.

Таким образом, основное различие между save(), saveOrUpdate() и persist() заключается в их поведении при сохранении объектов в базе данных. save() всегда сохраняет новый объект, saveOrUpdate() сохраняет или обновляет объект в зависимости от наличия идентификатора, а persist() также сохраняет новый объект, но может отложить выполнение операции сохранения до определенного момента.

Пример использования:
```java

// Пример использования методов save(), saveOrUpdate() и persist() в Hibernate

// Создание нового объекта
User user = new User();
user.setName("John");
user.setEmail("john@example.com");

// Использование метода save()
session.save(user); // Сохранение нового объекта в базе данных

// Использование метода saveOrUpdate()
user.setName("John Doe");
session.saveOrUpdate(user); // Обновление существующего объекта в базе данных

// Использование метода persist()
User newUser = new User();
newUser.setName("Jane");
newUser.setEmail("jane@example.com");
session.persist(newUser); // Сохранение нового объекта в базе данных
```
Примечание: В приведенном выше примере session представляет объект Session в Hibernate, который используется для выполнения операций с базой данных
## 2749. Что произойдет, если будет отсутствовать конструктор без аргументов у Entity Bean?

Если отсутствует конструктор без аргументов у Entity Bean, то возможны следующие последствия:

+ Не будет возможности создать экземпляр Entity Bean без передачи аргументов в конструктор.
+ Возможны проблемы при использовании Entity Bean в контексте Java Persistence API (JPA) или других фреймворках, которые требуют наличия конструктора без аргументов.
+ Если другие компоненты или фреймворки ожидают наличия конструктора без аргументов, то может возникнуть исключение или ошибка во время выполнения программы.


Пример кода:
```java
public class MyEntity {
    private String name;

    public MyEntity(String name) {
        this.name = name;
    }

    // Отсутствие конструктора без аргументов
}
```

В данном примере класс MyEntity имеет только один конструктор с аргументом name. Если попытаться создать экземпляр MyEntity без передачи аргумента, то возникнет ошибка компиляции или исключение во время выполнения программы, так как отсутствует конструктор без аргументов.
## 2750. В чем разница между sorted collection и ordered collection? Какая из них лучше?

В Hibernate есть разница между отсортированной коллекцией (sorted collection) и упорядоченной коллекцией (ordered collection).

Отсортированная коллекция (Sorted Collection) - это коллекция, которая сортируется с использованием фреймворка Java Collections. Сортировка происходит в памяти JVM, в которой работает Hibernate, сразу после чтения данных из базы данных с использованием Java Comparator. Эффективность сортировки зависит от размера коллекции - чем меньше коллекция, тем более эффективна сортировка.

Упорядоченная коллекция (Ordered Collection) - это коллекция, которая также сортируется с использованием оператора ORDER BY при извлечении результатов. Упорядоченная коллекция может быть более эффективной для сортировки, если размер коллекции большой.

Таким образом, выбор между отсортированной и упорядоченной коллекцией в Hibernate зависит от размера коллекции и требуемой эффективности сортировки. Если коллекция небольшая, то отсортированная коллекция может быть предпочтительнее. Если же коллекция очень большая, то упорядоченная коллекция может быть более эффективной.

Пример кода
Вот пример кода, демонстрирующий разницу между отсортированной и упорядоченной коллекцией в Hibernate:
```java
// Пример отсортированной коллекции
@OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
@OrderBy("name ASC")
private List<Child> children;

// Пример упорядоченной коллекции
@OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
@OrderColumn(name = "position")
private List<Child> children;
```


В приведенном выше коде @OrderBy используется для указания сортировки по имени (ASC - по возрастанию), а @OrderColumn используется для указания столбца позиции, по которому будет происходить упорядочивание.

Примечание: Важно помнить, что выбор между отсортированной и упорядоченной коллекцией зависит от конкретных требований вашего проекта и контекста использования Hibernate.
## 2751. Какие типы коллекций в Hibernate вы знаете?

Hibernate поддерживает различные типы коллекций. Некоторые из них включают:

+ List: Hibernate поддерживает использование списков для хранения коллекций объектов. Списки могут быть упорядочеными и могут содержать дубликаты.
+ Set: Hibernate также поддерживает использование множеств для хранения коллекций объектов. Множества не содержат дубликатов и могут быть упорядочеными или неупорядоченными.
+ Map: Hibernate позволяет использовать Map для хранения коллекций пар "ключ-значение". Карты могут быть упорядоченными или неупорядоченными.
+ Array: Hibernate также поддерживает использование массивов для хранения коллекций объектов.

Это только некоторые из типов коллекций, которые поддерживает Hibernate. Существуют и другие типы коллекций, такие как Bag и Ordered List, которые также могут быть использованы в Hibernate.
## 2752. Как реализованы Join’ы Hibernate?

Hibernate реализует Join'ы с помощью различных аннотаций и методов. Вот некоторые из них:

+ @ManyToOne - аннотация, которая указывает на отношение "многие к одному" между двумя сущностями. Она используется для создания Join'а между двумя таблицами, где одна таблица имеет внешний ключ на другую таблицу.
+ @OneToMany - аннотация, которая указывает на отношение "один ко многим" между двумя сущностями. Она используется для создания Join'а между двумя таблицами, где одна таблица имеет коллекцию объектов другой таблицы.
+ @JoinTable - аннотация, которая позволяет настраивать таблицу соединения для связи между двумя сущностями. Она используется для создания таблицы соединения, которая содержит внешние ключи на обе таблицы.
+ @JoinColumn - аннотация, которая указывает на столбец в таблице соединения, который является внешним ключом для Join'а.
+ Criteria API - это программный интерфейс, который позволяет строить запросы на основе критериев. Он предоставляет методы для создания Join'ов между таблицами.
+ HQL (Hibernate Query Language) - это язык запросов, который аналогичен SQL, но использует имена классов и свойств сущностей вместо имен таблиц и столбцов. HQL позволяет создавать Join'ы между таблицами с помощью ключевых слов, таких как JOIN, LEFT JOIN, RIGHT JOIN и INNER JOIN.

Вот пример использования аннотаций для создания Join'а между двумя сущностями в Hibernate:


```java
@Entity
@Table(name = "orders")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields and annotations

    @ManyToOne
    @JoinColumn(name = "customer_id")
    private Customer customer;

    // Getters and setters
}

@Entity
@Table(name = "customers")
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Other fields and annotations

    @OneToMany(mappedBy = "customer")
    private List<Order> orders;

    // Getters and setters
}
```

В приведенном выше примере используется аннотация @ManyToOne для создания Join'а между таблицами "orders" и "customers". Аннотация @JoinColumn указывает на столбец "customer_id" в таблице "orders", который является внешним ключом для Join'а.
## 2753. Почему мы не должны делать Entity class как final?

В Java, ключевое слово final используется для указания, что класс, метод или переменная не может быть изменены или наследованы. В контексте Entity классов, которые используются в ORM (Object-Relational Mapping) фреймворках, таких как Hibernate или JPA (Java Persistence API), есть несколько причин, почему мы не должны делать Entity классы как final:

+ Наследование: Entity классы обычно представляют таблицы в базе данных и могут иметь связи с другими классами. Если класс объявлен как final, то он не может быть наследован другими классами, что может ограничить возможности расширения и создания связей между классами.
+ Прокси и ленивая загрузка: ORM фреймворки, такие как Hibernate, могут использовать прокси-объекты для реализации ленивой загрузки данных. Если класс объявлен как final, то ORM фреймворк не сможет создать прокси-объекты для этого класса, что может привести к потере некоторых возможностей оптимизации и производительности.
+ Рефлексия: ORM фреймворки могут использовать рефлексию для доступа к полям и методам классов. Если класс объявлен как final, то доступ к нему через рефлексию может быть ограничен, что может затруднить работу с ORM фреймворком.
+ Сериализация: Если класс объявлен как final, то он может иметь проблемы с сериализацией, особенно если используется механизм сериализации по умолчанию. Это может привести к ошибкам или нежелательному поведению при сериализации и десериализации объектов.

В целом, хотя нет строгих правил запрещающих использование ключевого слова final для Entity классов, его использование может ограничить гибкость и функциональность ORM фреймворков. Поэтому, в большинстве случаев, рекомендуется не делать Entity классы как final, чтобы избежать потенциальных проблем и ограничений.

Пример кода:
```java
@Entity
public class Customer {
    @Id
    private Long id;
    private String name;
    // ...
}
```

В приведенном выше примере кода, класс Customer объявлен как обычный класс без использования ключевого слова final. Это позволяет ORM фреймворкам создавать прокси-объекты, использовать рефлексию и обеспечивать гибкость при работе с этим классом в контексте ORM.
## 2754. Что вы знаете о HQL и какие его преимущества

HQL (Hibernate Query Language) - это язык запросов, который используется в фреймворке Hibernate для работы с базами данных. HQL предоставляет альтернативу SQL для выполнения операций выборки, вставки, обновления и удаления данных в базе данных.

Преимущества HQL:

+ Объектно-ориентированный подход: HQL использует имена классов и свойств объектов вместо имен таблиц и столбцов в SQL запросах.
+ Поддержка наследования и ассоциаций: HQL позволяет работать с наследованием и ассоциациями между объектами, что делает запросы более гибкими и удобными.
+ Поддержка параметризованных запросов: HQL позволяет использовать параметры в запросах, что обеспечивает безопасность и предотвращает атаки SQL-инъекций.
+ Кросс-платформенность: HQL является независимым от базы данных языком запросов, что позволяет использовать один и тот же код для разных СУБД.

Примеры HQL запросов:

+ Пример запроса на выборку данных:
```java
String hql = "FROM Employee";
Query query = session.createQuery(hql);
List<Employee> employees = query.list();
```

+ Пример запроса с условием:
```java
String hql = "FROM Employee WHERE age > :age";
Query query = session.createQuery(hql);
query.setParameter("age", 30);
List<Employee> employees = query.list();
```


+ Пример запроса на вставку данных:
```java
String hql = "INSERT INTO Employee (firstName, lastName, age) SELECT firstName, lastName, age FROM TempEmployee";
Query query = session.createQuery(hql);
int rowCount = query.executeUpdate();
```


+ Пример запроса на обновление данных:
```java
String hql = "UPDATE Employee SET salary = :newSalary WHERE department = :department";
Query query = session.createQuery(hql);
query.setParameter("newSalary", 5000);
query.setParameter("department", "IT");
int rowCount = query.executeUpdate();
```


+ Пример запроса на удаление данных:
```java
String hql = "DELETE FROM Employee WHERE age < :age";
Query query = session.createQuery(hql);
query.setParameter("age", 25);
int rowCount = query.executeUpdate();
```
## 2755. Что такое Query Cache в Hibernate?

Query Cache в Hibernate - это механизм кэширования, который позволяет сохранять результаты выполнения запросов в памяти для повторного использования. Когда приложение выполняет запрос к базе данных через Hibernate, результаты запроса могут быть сохранены в кэше. При последующих запросах с теми же параметрами, Hibernate может использовать кэшированные результаты вместо повторного выполнения запроса к базе данных.

Использование Query Cache может значительно улучшить производительность приложения, так как избегается необходимость повторного выполнения запросов к базе данных. Однако, не все запросы могут быть кэшированы, и эффективность кэширования зависит от характеристик приложения и типа запросов.

Пример использования Query Cache в Hibernate:
```java
// Включение Query Cache
query.setCacheable(true);

// Выполнение запроса
List results = query.list();
```

В этом примере, setCacheable(true) указывает Hibernate сохранить результаты запроса в кэше. При последующих запросах с теми же параметрами, Hibernate будет использовать кэшированные результаты, если они доступны.

Важно отметить, что использование Query Cache требует аккуратного управления кэшем, чтобы избежать несогласованности данных. Например, если данные в базе данных изменяются, кэшированные результаты запросов могут стать устаревшими. Поэтому необходимо правильно настроить кэширование и обновлять его при необходимости.
## 2756. Можем ли мы выполнить нативный запрос SQL (sql native) в Hibernate?

Нативный запрос SQL (sql native) в Hibernate - это возможность написания и выполнения SQL-запросов непосредственно на языке SQL в рамках Hibernate, без использования Hibernate Query Language (HQL) или Criteria API. Это позволяет разработчикам использовать привычный SQL-синтаксис и функции базы данных при работе с Hibernate.

Hibernate предоставляет возможность выполнения нативных SQL-запросов с помощью метода createSQLQuery() или createNativeQuery(). Эти методы позволяют передавать SQL-запрос в виде строки и получать результаты запроса в виде объектов или массивов.

Пример использования нативного SQL-запроса в Hibernate:
```java
String sql = "SELECT * FROM users WHERE age > 18";
SQLQuery query = session.createSQLQuery(sql);
List<Object[]> results = query.list();

for (Object[] row : results) {
    Long id = (Long) row[0];
    String name = (String) row[1];
    // обработка результатов запроса
}
```

Примечание: При использовании нативных SQL-запросов в Hibernate следует быть осторожным, так как это может привести к проблемам с портируемостью и безопасностью. Рекомендуется использовать нативные SQL-запросы только в случаях, когда HQL или Criteria API не могут обеспечить необходимую функциональность.

Да, в Hibernate можно выполнить нативный запрос SQL (sql native). Hibernate предоставляет возможность использовать нативные запросы SQL с помощью аннотации @NamedNativeQuery или с использованием класса SQLQuery.

Например, для выполнения нативного запроса SQL в Hibernate можно использовать следующий код:
```java
String sql = "SELECT * FROM table_name";
SQLQuery query = session.createSQLQuery(sql);
List<Object[]> results = query.list();
```

В этом примере мы создаем объект SQLQuery с помощью метода createSQLQuery, передавая ему строку с нативным SQL-запросом. Затем мы вызываем метод list(), чтобы получить результаты запроса в виде списка массивов объектов.

Обратите внимание, что использование нативных запросов SQL может снизить переносимость кода между различными базами данных, поскольку SQL-запросы могут отличаться в разных СУБД. Поэтому рекомендуется использовать нативные запросы SQL только в случаях, когда это необходимо и когда нет альтернативных способов выполнения запросов с использованием HQL (Hibernate Query Language).
## 2757. Назовите преимущества поддержки нативного sql в Hibernate.

Hibernate предоставляет поддержку нативного SQL, что означает возможность написания и выполнения SQL-запросов непосредственно в коде при использовании Hibernate. Вот некоторые преимущества поддержки нативного SQL в Hibernate:

+ Гибкость: Использование нативного SQL позволяет разработчикам писать сложные запросы, которые могут быть трудно выразить с помощью Hibernate Query Language (HQL) или Criteria API. Нативный SQL позволяет использовать все возможности SQL, включая сложные операции объединения, агрегации и т.д.
+ Оптимизация производительности: В некоторых случаях использование нативного SQL может быть более эффективным с точки зрения производительности, чем использование HQL или Criteria API. Нативный SQL позволяет напрямую взаимодействовать с базой данных и оптимизировать запросы для конкретной СУБД.
+ Поддержка сложных сценариев: Нативный SQL может быть полезен при работе с хранимыми процедурами, функциями базы данных или другими сложными сценариями, которые не могут быть реализованы с помощью HQL или Criteria API.
+ Использование существующего SQL-кода: Если у вас уже есть существующий SQL-код, который вы хотите использовать с Hibernate, вы можете легко интегрировать его, используя нативный SQL.

Вот пример использования нативного SQL в Hibernate:
```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

SQLQuery query = session.createSQLQuery("SELECT emp_id, emp_name, emp_salary FROM Employee");
List<Object[]> rows = query.list();

for (Object[] row : rows) {
    Employee emp = new Employee();
    emp.setId(Long.parseLong(row[0].toString()));
    emp.setName(row[1].toString());
    emp.setSalary(Double.parseDouble(row[2].toString()));
    System.out.println(emp);
}

tx.commit();
session.close();
```
## 2758. Расскажите о преимуществах использования Hibernate Criteria API

Hibernate Criteria API - это удобный способ создания запросов к базе данных в Hibernate, используя объекты критериев (Criteria). Он предоставляет возможность создавать запросы без написания SQL-кода и позволяет компоновать условия для фильтрации результатов.

Hibernate Criteria API позволяет создавать запросы с использованием различных критериев, таких как ограничения (Restrictions), выражения (Expressions), сортировка (Order) и другие. Он также поддерживает комплексные запросы с использованием связанных сущностей и агрегатных функций.

Пример использования Hibernate Criteria API:
```java
Criteria criteria = session.createCriteria(ContactEntity.class);
criteria.add(Restrictions.ge("birthDate", startDate.getTime()));
criteria.add(Restrictions.le("birthDate", endDate.getTime()));
criteria.addOrder(Order.asc("birthDate"));
List<ContactEntity> results = criteria.list();
```

В этом примере мы создаем Criteria для сущности ContactEntity и добавляем ограничения на дату рождения (birthDate). Затем мы сортируем результаты по возрастанию даты рождения и получаем список результатов.

Hibernate Criteria API также поддерживает JPA Criteria API, который предоставляет альтернативный способ создания запросов с использованием стандартных JPA-классов и методов.

Важно отметить, что Hibernate Criteria API является устаревшим в Hibernate 5.2 и рекомендуется использовать JPA Criteria API вместо него.


Вот некоторые преимущества использования Hibernate Criteria API:

+ Удобство использования: Hibernate Criteria API предоставляет высокоуровневый и декларативный подход к созданию запросов, что делает его более понятным и легким в использовании, особенно для разработчиков, знакомых с объектно-ориентированным программированием.
+ Типобезопасность: Hibernate Criteria API предоставляет типобезопасные методы для создания запросов, что позволяет обнаруживать ошибки на этапе компиляции, а не во время выполнения.
+ Поддержка динамических запросов: Hibernate Criteria API позволяет строить запросы динамически в зависимости от условий или параметров, что делает его очень гибким для создания сложных запросов.
+ Удобство работы с ассоциациями: Hibernate Criteria API предоставляет удобные методы для работы с ассоциациями между сущностями, такими как связи один-к-одному, один-ко-многим и многие-ко-многим.
+ Возможность создания агрегатных функций: Hibernate Criteria API позволяет создавать запросы с агрегатными функциями, такими как сумма, среднее значение, максимум и минимум.
+ Поддержка пагинации и сортировки: Hibernate Criteria API предоставляет удобные методы для настройки пагинации и сортировки результатов запроса.
+ Интеграция с другими частями Hibernate: Hibernate Criteria API интегрируется с другими частями Hibernate, такими как Hibernate Session и Hibernate Query Language (HQL), что позволяет использовать их вместе для более сложных запросов и операций с базой данных.

Пример использования Hibernate Criteria API для создания запроса:
```java
CriteriaBuilder builder = session.getCriteriaBuilder();
CriteriaQuery<Employee> critQuery = builder.createQuery(Employee.class);
Root<Employee> root = critQuery.from(Employee.class);
critQuery.select(root);
Query<Employee> query = session.createQuery(critQuery);
List<Employee> results = query.getResultList();
```
## 2759. Как логировать созданные Hibernate SQL запросы в лог-файлы?

Для логирования созданных Hibernate SQL запросов в лог-файлы вы можете использовать следующие настройки:

В файле application.properties вашего проекта, установите следующие свойства:
```xml
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.show_sql=true
```
Установите уровень логирования для Hibernate на уровне DEBUG. Это можно сделать в файле application.properties следующим образом:
```xml
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```
Теперь Hibernate будет логировать созданные SQL запросы в лог-файлы вашего приложения.

Пример:
```bash
2023-12-23 11:23:21.123 DEBUG [main] org.hibernate.SQL - SELECT * FROM users
2023-12-23 11:23:21.456 DEBUG [main] org.hibernate.SQL - INSERT INTO products (name, price) VALUES ('Product 1', 10.99)
```

Обратите внимание, что для логирования вам также может понадобиться настройка логгера, такого как Log4j, чтобы управлять выводом логов Hibernate.

Hibernate предоставляет несколько способов логирования, которые могут быть использованы для отслеживания и анализа выполняемых SQL-запросов и других операций. Вот некоторые из них:

+ Логирование SQL-запросов:

Можно включить логирование SQL-запросов, чтобы видеть, какие запросы выполняются Hibernate. Для этого можно использовать следующие настройки в файле application.properties:
```xml
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.show_sql=true
```
Это позволит выводить SQL-запросы в логах приложения.


+ Настройка уровня логирования Hibernate:

Можно настроить уровень логирования для Hibernate, чтобы получать более подробную информацию о его работе. Например, можно использовать следующие настройки в файле application.properties:
```xml
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```
Это позволит выводить отладочные сообщения о SQL-запросах и привязках параметров в логах приложения [[2[2].

+ Использование логгера Hibernate:

Можно использовать логгер Hibernate для записи собственных сообщений или отладочной информации. Например, можно использовать следующий код для записи сообщения в лог:
```java
import org.hibernate.Logger;

Logger logger = Logger.getLogger(YourClass.class);
logger.info("Your log message");
```

Здесь YourClass - это класс, в котором происходит запись в лог.
## 2760. Что вы знаете о Hibernate прокси и как это помогает в ленивой загрузке (lazy load)?

Hibernate прокси - это механизм, который используется в Hibernate для реализации ленивой загрузки (lazy load) объектов. Ленивая загрузка позволяет отложить загрузку связанных объектов до момента, когда они действительно понадобятся.

Hibernate создает прокси-объекты, которые являются подклассами оригинальных объектов. Когда вы получаете ссылку на объект, который должен быть лениво загружен, Hibernate возвращает прокси-объект вместо реального объекта из базы данных. Прокси-объект содержит только идентификатор объекта и не загружает остальные данные, пока не будет вызвано какое-либо свойство, требующее доступа к этим данным.

Когда вызывается свойство прокси-объекта, Hibernate инициирует запрос к базе данных для загрузки оставшихся данных объекта. Это позволяет избежать загрузки всех связанных объектов сразу, что может быть неэффективно и приводить к избыточному использованию ресурсов.

Использование Hibernate прокси в ленивой загрузке имеет несколько преимуществ:

+ Улучшение производительности, поскольку загрузка данных происходит только при необходимости.
+ Экономия памяти, так как не все связанные объекты загружаются сразу.
+ Упрощение кода, поскольку разработчику не нужно явно управлять загрузкой связанных объектов.


Пример использования Hibernate прокси в ленивой загрузке:
```java
@Entity
public class Order {
    // ...

    @ManyToOne(fetch = FetchType.LAZY)
    private Customer customer;

    // ...
}

@Entity
public class Customer {
    // ...

    @OneToMany(mappedBy = "customer")
    private List<Order> orders;

    // ...
}

// Загрузка заказов без загрузки связанных объектов Customer
List<Order> orders = entityManager.createQuery("SELECT o FROM Order o", Order.class).getResultList();

// Загрузка связанного объекта Customer для каждого заказа
for (Order order : orders) {
    Customer customer = order.getCustomer(); // Здесь происходит загрузка связанного объекта
    // ...
}
```
## 2761. Как реализованы отношения в Hibernate?


Отношения в Hibernate реализуются с помощью аннотаций и конфигураций. Вот некоторые основные способы реализации отношений в Hibernate:

+ Однонаправленная связь многие-к-одному (Many-to-One): Это отношение, при котором много объектов одного класса связаны с одним объектом другого класса. В Hibernate это реализуется с помощью аннотации @ManyToOne.
+ Однонаправленная связь один-к-одному (One-to-One): Это отношение, при котором один объект одного класса связан с одним объектом другого класса. В Hibernate это реализуется с помощью аннотации @OneToOne.
+ Однонаправленная связь многие-ко-многим (Many-to-Many): Это отношение, при котором много объектов одного класса связаны с многими объектами другого класса. В Hibernate это реализуется с помощью аннотации @ManyToMany.
+ Двунаправленная связь многие-к-одному (Bidirectional Many-to-One): Это отношение, при котором много объектов одного класса связаны с одним объектом другого класса, и наоборот. В Hibernate это реализуется с помощью аннотаций @ManyToOne и @OneToMany.
+ Двунаправленная связь один-к-одному (Bidirectional One-to-One): Это отношение, при котором один объект одного класса связан с одним объектом другого класса, и наоборот. В Hibernate это реализуется с помощью аннотаций @OneToOne и @OneToOne.
+ Двунаправленная связь многие-ко-многим (Bidirectional Many-to-Many): Это отношение, при котором много объектов одного класса связаны с многими объектами другого класса, и наоборот. В Hibernate это реализуется с помощью аннотаций @ManyToMany и @ManyToMany.

Hibernate также предоставляет возможность настройки каскадных операций, таких как сохранение, обновление и удаление связанных объектов, а также опций для оптимизации запросов и управления кэшированием.

Пример кода:
```java
@Entity
public class User {
    @Id
    private Long id;
    private String name;

    @ManyToOne
    private Role role;

    // Геттеры и сеттеры
}

@Entity
public class Role {
    @Id
    private Long id;
    private String name;

    @OneToMany(mappedBy = "role")
    private List<User> users;

    // Геттеры и сеттеры
}
```

В приведенном выше примере класс User имеет связь многие-к-одному с классом Role, а класс Role имеет обратную связь один-ко-многим с классом User. Аннотация @ManyToOne указывает на однонаправленную связь многие-к-одному, а аннотация @OneToMany с атрибутом mappedBy указывает на обратную связь один-ко-многим.

Обратите внимание: Это только один из множества способов реализации отношений в Hibernate. В зависимости от требований проекта и предпочтений разработчика, могут быть использованы и другие подходы и аннотации.
## 2762. Какие типы менеджмента транзакций поддерживаются в Hibernate?
## 2763. Что такое каскадные связи (обновления) и какие каскадные типы есть в Hibernate?
## 2764. Что вы знаете о классе HibernateTemplate?
## 2765. Какие паттерны применяются в Hibernate?
## 2766. Расскажите о Hibernate Validator Framework.
## 2767. Какие преимущества дает использование плагина Hibernate Tools Eclipse?
## 2768. Чем отличается Lazy от Eager в Hibernate?
## 2769. Что такое проблема N+1 запроса при использовании Hibernate? Когда возникает? Как решить? Как обнаружить?
## 2770. Как описать составной ключ при использовании Hibernate?
## 2771. Как можно отобразить наследование на БД с помощью JPA (Hibernate)?
## 2772. Что такое диалект?
## 2773. Как Hibernate создает соединение с базой данных?
## 2774. Какая аннотация используется для объявления класса как сущность ?
## 2775. Как мне указать имя таблицы, связанной с объектом, используя аннотацию?
## 2776. Как переменная в сущности соединяется со столбцом базы данных?
## 2777. Как указать другое имя столбца для отображения переменных?
## 2778. Как мы указываем переменную, которая будет первичным ключом для таблицы?
## 2779. Как мы определяем логику генерации значения первичного ключа?
## 2780. Как вы настраиваете диалект в hibernate.cfg.xml?
## 2781. Как настроить URL базы данных и учетные данные в hibernate.cfg.xml?
## 2782. Как настроить размер пула соединений?
## 2783. Как мы совершаем транзакцию в Hibernate?
## 2784. Можно ли подключить несколько баз данных в одном приложении Java с помощью Hibernate?
## 2785. Поддерживает ли Hibernate полиморфизм?
## 2786. Сколько сессий Hibernate существует в любой момент времени в приложении?
## 2787. Какие изоляции транзакций есть в Hibernate?
## 2788. Чем отличаются JPA и Hibernate?
## 2789. Как интегрировать Hibernate и Spring?


Список вопросов и ответов по теме «Веб-сервисы» в Java (Java web services).
Вопросы

1.    Что такое веб сервисы?
2.    В чем разница между SOA и web service?
3.    Что такое SOAP?
4.    Что такое REST?
5.    В чем разница между REST и SOAP веб сервисами?
6.    Как бы вы решили какой из REST или SOAP веб сервисов использовать?
7.    Объясните понятие WSDL.
8.    Что такое JAX-WS?
9.    Расскажите о JAXB.
10.   Можем ли мы посылать soap сообщения с вложением?
11.   Что такое MTOM?
12.   Что такое XOP?
13.   Объясните элемент SOAP envelope.
14.   Как определяется пространство имен SOAP?
15.   Что вы знаете о кодировании в SOAP (encoding)?
16.   Что определяет атрибут encodingStyle в SOAP?
17.   Какие два конечных типа веб сервисов используют JAX-WS?
18.   Какие существуют правила для кодирования записи header?
19.   Что вы знаете об инструменте wsimport?
20.   Что вы знаете об инструменте wsgen?
21.   Какие вы можете выделить различия между SOAP и другими техниками удаленного доступа?
22.   Что такое resource в REST?
23.   Какие HTTP методы поддерживаются в REST?
24.   Когда можно использовать GET запрос вместо POST для создания ресурса?
25.   Какая разница между GET и POST запросами?
26.   Что означает WADL?
27.   Какие вы знаете фреймворки, которые реализуют REST веб сервисы?
28.   Какая разница между AJAX и REST?
29.   Что делает аннотация @Path?
30.   Что делает аннотация @PathParam?
31.   Что делает аннотация @QueryParam?
32.   Что делает аннотация @MatrixParam?
33.   Что делает аннотация @FormParam?
34.   Какие два способа получения заголовка HTTP запроса в JAX-RS вы знаете?
35.   Как скачать файл с помощью JAX-RS?













Собеседование по Java EE — Spring Framework (вопросы и ответы). Часть 1

1.    Расскажите о Spring Framework.
2.    Какие некоторые из важных особенностей и преимуществ Spring Framework?
3.    Что вы понимаете под Dependency Injection (DI)?
4.    Как реализуется DI в Spring Framework?
5.    Какие преимущества использования Spring Tool Suite?
6.    Приведите названия некоторых важных Spring модулей.
7.    Что вы понимаете под аспектно-ориентированным программированием (Aspect Oriented Programming — AOP)?
8.    Что такое Aspect, Advice, Pointcut, JoinPoint и Advice Arguments в АОП?
9.    В чем разница между Spring AOP и AspectJ АОП?
10.   Что такое IoC контейнер Spring?
11.   Что такое Spring бин?
12.   Какое значение имеет конфигурационный файл Spring Bean?
13.   Какие различные способы настроить класс как Spring Bean?
14.   Какие вы знаете различные scope у Spring Bean?
15.   Что такое жизненный цикл Spring Bean?
16.   Как получить объекты ServletContext и ServletConfig внутри Spring Bean?
17.   Что такое связывание в Spring и расскажите об аннотации @Autowired?
18.   Какие различные типы автоматического связывания в Spring?
19.   Является ли Spring бин потокобезопасным?
20.   Что такое контроллер в Spring MVC?
21.   Какая разница между аннотациями @Component, @Repository и @Service в Spring?
22.   Расскажите, что вы знаете о DispatcherServlet и ContextLoaderListener.
23.   Что такое ViewResolver в Spring?
24.   Что такое MultipartResolver и когда его использовать?
25.   Как обрабатывать исключения в Spring MVC Framework?
26.   Как создать ApplicationContext в программе Java?
27.   Можем ли мы иметь несколько файлов конфигурации Spring?
28.   Какие минимальные настройки, чтобы создать приложение Spring MVC?
29.   Как бы вы связали Spring MVC Framework и архитектуру MVC?
30.   Как добиться локализации в приложениях Spring MVC?
31.   Как мы можем использовать Spring для создания веб-службы RESTful, возвращающей JSON?
32.   Приведите пример часто используемых аннотаций Spring.
33.   Можем ли мы послать объект как ответ метода обработчика контроллера?
34.   Как загрузить файл в Spring MVC?
35.   Как проверить (валидировать) данные формы в Spring Web MVC Framework?
36.   Что вы знаете Spring MVC Interceptor и как он используется?
37.   Spring JdbcTemplate класс и его применение.
38.   Как использовать Tomcat JNDI DataSource в веб-приложении Spring?
39.   Каким образом можно управлять транзакциями в Spring?
40.   Расскажите о Spring DAO.
41.   Как интегрировать Spring и Hibernate?
42.   Расскажите о Spring Security.
43.   Как внедрить java.util.Properties в Spring Bean?
44.   Назовите некоторые из шаблонов проектирования, используемых в Spring Framework?
45.   Best Practices в Spring Framework.


Собеседование по Java EE — Java Server Faces (JSF) (вопросы и ответы). Часть 1
2865. Что такое JSF?
2866. Что такое Managed Bean?
2867. Какие три типа тегов для текстовых полей существуют в JSF?
2868. Что означает аннотация @ManagedProperty?
2869. На что указывает аннотация @ApplicationScoped?
2870. Что такое связывание ресурсов в JSF?
2871. Объясните разницу между required и requiredMessage атрибутов в теге <h:inputText>.
2872. Какие различные типы навигации по страницам поддерживаются в JSF?
2873. Какие фазы жизненного цикла в JSF вы знаете?
2874. Объясните назначение тега <h:form>.
2875. Какие теги используются для action и navigation?
2876. Какие компоненты используются для отображения данных в табличном виде?
2877. Что такое событие (event)?
2878. Как мы можем получить generated event?
2879. Какие различные типы событий существуют в JSF?
2880. Что такое класс-слушатель?
2881. Какое назначение тега facelets?
2882. Назовите несколько facelets тегов.
2883. Какие различные типы валидации используются в JSF?
2884. Какие различные типы выражений поддерживаются JSF EL (Expression Language)?
2885. В чем разница между мгновенными и отложенными выражениями?
2886. Объясните разницу между value expression и method expression.
2887. Расскажите о @ViewScoped, @SessionScoped, @CustomScoped и @RequestScoped аннотациях.
2888. Какие существую способы объявить класс управляемым бином JSF?
2889. Как используются атрибуты name и eager в Managed Bean?
2890. Какие теги для валидации существуют в JSF?
2891. Какие преимущества использования JSF Framework?
2892. Какие различные теги JSF используются для конвертации?
2893. Перечислите преимущества использования языка выражений (expression language)?
2894. Поясните название backing bean.
2895. Какие стандартные библиотеки тегов JSF вы знаете?
2896. Какие основные функции выполняет метод в backing bean?
2897. Какие различные реализации JSF API вы знаете?
2898. Объясните архитектуру JSF.
2899. Как различные компоненты рендерятся на JSF странице?
2900. Может JSF содержать несколько файлов конфигурации?
2901. Чем различается понятия backing bean и managed bean?
2902. Как отобразить сообщения об ошибках в JSF?
2903. Объясните назначение тега selectOne menu в JSF.
2904. Объясните в чем разница между атрибутами immediate и rendered?
2905. Какие два способа связывания поддерживается JSF?
2906. Какая минимальная конфигурация необходима для JSF приложения?
2907. Что означает navigation rule в JSF?
2908. Расскажите о назначение тегов converter в JSF.
2909. Перечислите преимущества таблицы данных в JSF.
2910. Как реализовать интернационализацию (локализацию) (i18n) в JSF?
2911. Какая модель рендеринга применяется в JSF?
2912. Что такое render kit?
2913. Что такое view object?
2914. Что подразумевается под Bean Scope?
2915. В чем разница между JSF-1 и JSF-2?
2916. Может ли отсутствовать faces-config.xml у JSF приложения?
2917. Сравните JSF и Spring Framework.
2918. Почему JSF не так популярна как, например, MVC фреймворки вроде Spring MVC, хотя JSF старше и входит в JEE?
2919. Можем ли мы интегрировать JSF с другими популярными фреймворками вроде Spring, Hibernate и т.д.?
2920. JSF Best Practices.






Собеседование по Java EE — JEE Servlet API (вопросы и ответы)
2968. Что такое сервлет?
2969. Какова структура веб-проекта?
2970. Что такое контейнер сервлетов?
2971. Какие задачи, функциональность контейнера сервлетов?
2972. Что вы знаете о сервлет фильтрах?
2973. Зачем нужны слушатели в сервлетах?
2974. Когда вы будете использовать фильтры, а когда слушатели?
2975. Как обработать исключения, выброшенные другим сервлетом в приложении?
2976. Что такое дескриптор развертывания?
2977. Как реализовать запуск сервлета с запуском приложения?
2978. Что представляет собой объект ServletConfig?
2979. Что представляет собой объект ServletContext?
2980. В чем отличия ServletContext и ServletConfig?
2981. Что такое Request Dispatcher?
2982. Как можно создать блокировку (deadlock) в сервлете?
2983. Как получить адрес сервлета на сервере?
2984. Как получить информацию о сервере из сервлета?
2985. Как получить ip адрес клиента на сервере?
2986. Что вы знаете о классах обертках (wrapper) для сервлетов?
2987. Каков жизненный цикл сервлета и когда какие методы вызываются?
2988. Какие методы необходимо определить при создании сервлетов?
2989. В каком случае вы будете переопределять метод service()?
2990. Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?
2991. В чем отличия GenericServlet и HttpServlet?
2992. Как вызвать из сервлета другой сервлет этого же и другого приложения?
2993. Что вы знаете и в чем отличия методов forward() и sendRedirect()?
2994. Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?
2995. В чем отличие между веб сервером и сервером приложений?
2996. Какой метод HTTP не является неизменяемым?
2997. Почему HttpServlet класс объявлен как абстрактный?
2998. В чем разница между методами GET и POST?
2999. Что такое MIME-тип?
3000. Назовите преимущества Servlet над CGI?
3001. Какие наиболее распространенные задачи выполняемые в Servlet контейнере?
3002. В чем разница между PrintWriter и ServletOutputStream?
3003. Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?
3004. Расскажите о интерфейсе SingleThreadModel.
3005. Какие существуют атрибуты у сервлетов и какая сфера их применения?
3006. Почему необходимо переопределить только init() метод без аргументов?
3007. Что означает URL encoding? Зачем нужны методы java.net.URLEncoder.encode() и decode()?
3008. Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?
3009. Какие различные методы управления сессией в сервлетах вы знаете?
3010. Что означает URL Rewriting?
3011. Как применяются Cookies в сервлетах?
3012. Как уведомить объект в сессии, что сессия недействительна или закончилась?
3013. Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?
3014. Как мы можем обеспечить transport layer security для нашего веб приложения?
3015. Как организовать подключение к базе данных и обеспечить логирование log4j в сервлете?
3016. Какие важные особенности существуют в Servlet 3?
3017. Какие различные способы аутентификации сервлета?
3018. Написать сервлет, реализующий загрузку файла на сервер.


Собеседование по Java EE — JEE API (вопросы и ответы)
3019. Что такое Java EE?
3020. Какие модули входят в Java EE?
3021. Какие типы Java EE клиентов вы знаете? (applets, Application clients, Java Web Start-enabled clients, by Java Web Start technology.
Wireless clients, based on MIDP technology)
3022. Что вы знаете о EJB?
3023. Какая разница между .jar, .war и .ear файлами?
3024. Какие компоненты содержит веб модуль?
3025. Java CDI.
3026. Какие технологии поддерживает Java EE?
3027. Расскажите о Java Persistense API.
3028. Что входит в web уровень JEE?
3029. Java Bean Validation.
3030. Java EE Security.
3031. Java EE Messaging.









Квалификационные задания для Java разработчиков
Теперь подробнее о заданиях. Задания разделены на 3 категории.
Level 1 позволяет оценить базовые знания, насколько вы, знаете базовые
основы языка, основы программирования и насколько хорошо владеете
программами необходимыми для разработки продуктов.
Level 2 содержит вопросы, позволяющие оценить глубину ваших знаний в той
или иной части языка программирования, а так же узнать о знании смежных
технологий.
Ну и последняя часть, это Level 3 в которой собранны вопросы и задачи по
разработке масштабируемых высоконагруженных систем, а так же вопросы
на знание низкоуровнего устройства технологий.



Level I
Вопросы данной категории не имеют однозначного ответа который можно было нагуглить или
найти в википедии. Если вы еще в ответах укажите, как, при каких обстоятельствах
сталкивались с проблемой на собственном опыте и как решили - это будет несомненным
плюсом, и будет засчитано как COMBO X8.
Q1
Опишите основные плюсы разработки на Java. Как Вы производите сборку (build)?
Q2
Какие технологии Java Enterprise Edition вы чаще всего используете? В чем
сложность их использования?
Q3
Расскажите о плюсах использования паттерна MVC. В каких случаях не стоит его
использовать? Какие в нем минусы?
Q4
Расскажите об используемых Вами фреймворках (программных каркасах). В чем их
плюсы? Для каких задач лучше использовать существующий фреймворк, а когда
лучше все написать самому?
Q5
Сборка мусора. Какие проблемы с ней связанны? Какие решения вы бы предложили?
Q6
В чем плюсы использования SVN/CVS/GIT? Какие сложности при работе с ним у вас возникали?

Q7
При работе в команде, каким бы местам в разработке, вы бы удилили большее
внимание? Какие бы соглашения (Coding Conventions) вам бы помогли в командной
разработке?
Q8
Использование баг-трекеров. В чем плюсы? Расскажите о проблемах использования
вами баг-трекеров.


Level II
Вопросы данной категории содержат технические вопросы, в некоторых вам даже придется
попробовать себя в роли компилятора. Если вы сможете в ваших ответах на данные вопросы
указать, что же еще происходит на низком уровне или почему так происходит - это будет
засчитано как COMBO X16.
Q1
Объясните почему происходит следующее: Расскажите, в каких случаях, какой
контейнер сервлетов лучше использовать:
• Resin
• Tomcat
• Jetty
• WebSphere
• GlassFish
• JBoss

Q2
Расскажите о использовании Java Message Service (JMS), какие проблемы могут
возникнуть при работе сним?
Q3
Каковы плюсы использования Enterprise Java Beans (EJB)? Какие альтернативные
технологии можно использовать вместо EJB?


Q4
Есть большая продакшен система. Поступает информация, что одна из основных
частей (ORM) начала выдавать ошибки. Вам нужно эти ошибки исправить. ORM
система работает с базой C-Store, используя С++ код, через JNI.
• Опишите как Вы начнете анализ места генерации ошибок.
• Какие варианты временного устранения неполадки (костыля) Вы можете предложить?
Q5
Нужно написать прослойку между почтовым сервером и front-end приложением
(Flash AS3 Application). Опишите следующие моменты:
• Какой формат обмена данными вы бы использовали, для минимального трафико-обмена
(по умолчанию считаем, front-end сможет читать абсолютно любой формат)?
• В чем плюсы выбранного вами формата?
• Какие бы технологии (сервера/фреймворки/утилиты) вы использовали?


Level III
В данной категории содержатся задачи и описание реально возникающих проблем. Постарайтесь
придумать и описать ваше решение данных задач. Чем более детализовано будет решение, тем
лучше! Вы можете искать решения в интернете, гуглить, читать википедию и так далее, но
помните, что вероятнее всего в будущем вам придется столкнутся с такими задачами. Если вы
решите все эти задачи, то вы - TRUE HARDCORE JAVA DEVELOPER.
Q1
Есть проект, суть которого в продаже автомобилей. Требования у заказчиков
такие: версионность данных(как Wikipedia), возможность расширения моделей
данных (можно добавить к описанию автомобиля кастомное свойство, например
наличие модинга). Опишите следующие моменты:
• Какую базу данных лучше всего использовать?
• Как реализовать версионность в данном случае?
• Как реализовать возможность расширения моделей?
• Какова будет конечная структура базы данных?
• Какие сложности могут возникнуть в реализации проекта?


Q2
Планируется проект, рассчитанный на большое количество информации, для
этого изначально планируется использовать более 6 серверов с MySQL базами
данных (есть возможность докупить любое количество серверов). Опишите
следующие моменты:
• Как распределить нагрузку между всеми серверами?
• Как реализовать максимальную стабильность работы серверов?
• Как можно снизить загрузку серверов?
• Оптимально ли использовать MySQL? Каковы плюсы и минусы использования?
Q3
Поступило предложение заказчика, на создания аналога сервиса микроблогинга
Twitter. На вас ложится задача разработки первичной версии архитектуры
проекта. По-умолчанию считаем, что заказчик готов предоставить
неограниченные средства. Опишите следующие моменты:
• Какую конфигурацию программной части вы бы составили для проекта (Операционная
система, языки программирования, база данных, фреймворки или сторонние разработки)?
Опишите в чем плюсы вашей конфигурации.
• Какие слабые стороны возможны у данного проекта? Какие решения Вы можете
предложить?
• Опишите схему внутренней работы проекта.


1. Общие вопросы



1.1 Каковы основные функции разных версий Spring Framework?

1.2 Что такое Spring Framework?

1.3. Перечислите преимущества Spring Framework.

1.4 Каковы различные функции Spring Framework?

1.5 Сколько модулей в Spring Framework и какие они?

1.6 Что такое файл конфигурации Spring?

1.7 Каковы различные компоненты приложения Spring?

1.8 Как можно использовать Spring?



2. Внедрение зависимости (Ioc)



2.1 Что такое контейнер Spring IOC?

2.2 Что такое внедрение зависимостей?

2.3 Сколько способов может быть выполнено внедрение зависимостей?

2.4 Различия между внедрением конструктора и внедрением сеттера.

2.5 Сколько контейнеров с МОК будет весной?

2.6 Различия между BeanFactory и ApplicationContext.

2.7. Перечислите некоторые преимущества IoC.

2.8 Механизм реализации Spring IoC.



3. Beans



3.1 Что такое весенняя фасоль?

3.2 Какие методы настройки предоставляет Spring?

3.3 Поддерживает ли Spring централизованную область видимости компонентов?

3.4 Каков жизненный цикл контейнера для весенних зерен?


3.5 Что такое внутренняя составляющая весны?

3.6. Что такое пружинный узел




3.7 Какие существуют методы автоматической сборки?


3.8 Каковы ограничения автоматической сборки?



4. Аннотация



4.1 Какие важные аннотации Spring вы использовали?

4.2 Как начать сборку аннотации весной?


4.3 В чем разница между @Component, @Controller, @Repository, @Service?

4.4 Какая польза от аннотации @Required?

4.5. Какая польза от аннотации @Autowired?

4.6 Какая польза от аннотации @Qualifier?

4.7. Какая польза от аннотации @RequestMapping?



5. Доступ к данным



5.1 Какая польза от Spring DAO?

5.2 Перечислите исключения, создаваемые Spring DAO.


5.3 Какие классы существуют в Spring JDBC API?


5.4 Как можно получить доступ к Hibernate с помощью Spring?

5.5. Перечислите типы управления транзакциями, поддерживаемые Spring

5.6 Какие рамки ORM поддерживает Spring?



6. AOP




6.1 Что такое АОП?



6.2 Что такое параметры Aspect, Advice, Pointcut, JointPoint и Advice в АОП?


6.3 Что такое совет?


6.4 Какие существуют советы (советы)?

6.5 Укажите на разницу между беспокойством и сквозным беспокойством в весеннем сезоне.


6.6 Каковы методы реализации АОП?

6.7 В чем разница между Spring AOP и AspectJ AOP?

6.8 Как понять прокси в Spring?

6.9 Что такое ткачество?



7. MVC



7.1 Какая польза от Spring MVC framework?

7.2. Опишите рабочий процесс DispatcherServlet.

7.3. Введение в контекст WebApplicationContext