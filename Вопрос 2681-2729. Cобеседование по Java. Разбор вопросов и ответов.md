# Cобеседование по Java. Разбор вопросов и ответов.


<a href="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%">
    <img src="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%" />
  </a>&nbsp;&nbsp;
<a href="https://mc.yandex.ru/watch/92801430">
    <img src="https://mc.yandex.ru/watch/92801430" />
  </a>&nbsp;&nbsp;

с 2681 вопрос по 2729 вопрос


Нажмите ★, если вам нравится проект. Ваш вклад сердечно ♡ приветствуется.

Если вам интересно мое резюме: https://github.com/DEBAGanov




Собеседование по Java EE — Java Persistence API (JPA)

## 2681. Что такое JPA?
JPA (Java Persistence API) - это спецификация Java для управления постоянными объектами в реляционных базах данных. JPA предоставляет разработчикам удобный способ работать с базами данных, абстрагируясь от деталей реализации. Он позволяет сохранять, извлекать, обновлять и удалять объекты в базе данных, используя объектно-ориентированный подход.

JPA является частью Java EE (Enterprise Edition) и предоставляет стандартный способ работы с базами данных в Java-приложениях. Он определяет аннотации и интерфейсы, которые разработчики могут использовать для описания сущностей (Entity) и их отношений в базе данных. JPA также предоставляет API для выполнения операций с базой данных, таких как сохранение, извлечение и обновление данных.

JPA может использоваться с различными реализациями, такими как Hibernate, EclipseLink и другими. Hibernate является одной из самых популярных реализаций JPA и предоставляет дополнительные функции и возможности, такие как кэширование, ленивая загрузка и поддержка различных стратегий сопоставления объектов и таблиц.

Некоторые ключевые термины, связанные с JPA:

+ Entity (сущность): это класс Java, который представляет объект, который будет сохранен в базе данных. Класс сущности обычно аннотируется с помощью аннотации @Entity.
+ POJO (Plain Old Java Object): это обычный класс Java, который не зависит от какой-либо специфической платформы или фреймворка. В контексте JPA, классы сущностей являются POJO-классами.
+ ORM (Object-Relational Mapping): это технология, которая позволяет сопоставлять объекты в приложении с таблицами в базе данных. JPA предоставляет ORM-функциональность, позволяя разработчикам работать с объектами, а не с SQL-запросами.

## 2682. В чем её отличие JPA от Hibernate?
JPA (Java Persistence API) и Hibernate - это два различных, но связанных понятия в контексте работы с базами данных в Java.

JPA является стандартным интерфейсом программирования для работы с объектно-реляционным отображением (ORM) в Java. Он предоставляет API для управления объектами в базе данных, а также для выполнения операций чтения и записи данных. JPA определяет набор аннотаций и интерфейсов, которые разработчик может использовать для описания сущностей базы данных и их отношений.

Hibernate является одной из реализаций JPA. Он предоставляет конкретную реализацию JPA API и дополнительные функции для работы с базами данных. Hibernate выполняет маппинг объектов Java на таблицы базы данных и обеспечивает автоматическую генерацию SQL-запросов для выполнения операций с данными.

Таким образом, отличие между JPA и Hibernate заключается в следующем:

+ JPA является стандартным интерфейсом программирования для работы с ORM в Java.
+ Hibernate является одной из реализаций JPA и предоставляет конкретную реализацию JPA API и дополнительные функции для работы с базами данных.

## 2683. Можно ли использовать JPA c noSQl базами?

Да, можно использовать JPA с NoSQL базами данных. JPA (Java Persistence API) - это стандартный интерфейс для работы с объектно-реляционным отображением (ORM) в Java. Он предоставляет возможность взаимодействия с различными базами данных, включая SQL и NoSQL базы данных.

JPA обычно ассоциируется с ORM-фреймворками, такими как Hibernate, который предоставляет реализацию JPA. Hibernate позволяет использовать JPA для работы с NoSQL базами данных, такими как MongoDB и Apache Cassandra.

Однако, важно отметить, что поддержка NoSQL баз данных может различаться в зависимости от конкретной реализации JPA и ORM-фреймворка. Некоторые ORM-фреймворки, такие как Hibernate OGM, специально разработаны для работы с NoSQL базами данных.

Таким образом, JPA может быть использован с NoSQL базами данных, но необходимо учитывать особенности конкретной реализации JPA и ORM-фреймворка, а также поддержку NoSQL баз данных в выбранной реализации

## 2684. В чем её отличие JPA от JDO?
JPA (Java Persistence API) и JDO (Java Data Objects) - это два различных подхода к сохранению и извлечению данных в Java приложениях.

JPA является частью Java EE (Enterprise Edition) и предоставляет стандартный способ работы с реляционными базами данных в Java приложениях. JPA определяет API для управления объектно-реляционным отображением (ORM) и предоставляет возможность работать с базами данных, используя объектно-ориентированный подход. Одним из самых популярных реализаций JPA является Hibernate.

JDO также является стандартом для работы с объектно-ориентированными базами данных в Java приложениях. JDO предоставляет API для сохранения и извлечения объектов из базы данных, не завися от конкретной реализации базы данных или ORM. JDO поддерживает различные реализации, такие как DataNucleus и ObjectDB.

Вот основные отличия между JPA и JDO:

+ JPA является частью Java EE, в то время как JDO является отдельным стандартом.
+ JPA предоставляет стандартный способ работы с реляционными базами данных, в то время как JDO предоставляет более общий подход к работе с объектно-ориентированными базами данных.
+ JPA имеет широкую поддержку и популярность, особенно с использованием Hibernate, в то время как JDO имеет более ограниченную поддержку и использование.

## 2685. Что такое Entity?
Entity в контексте JPA (Java Persistence API) представляет собой класс, который отображается на таблицу в базе данных. Он представляет сущность, с которой мы работаем в приложении и которую мы хотим сохранить, обновить или удалить в базе данных.

Пример использования Entity в JPA:
```java
@Entity
@Table(name = "employees")
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name")
    private String name;

    // Другие поля и методы
}
```
В приведенном выше примере Employee является Entity классом, который отображается на таблицу employees в базе данных. Он имеет аннотацию @Entity, которая указывает JPA, что этот класс является сущностью. Аннотация @Table указывает имя таблицы, на которую отображается этот класс.

Entity классы могут иметь поля, которые отображаются на столбцы таблицы, а также аннотации для определения отношений между сущностями, ограничений и других аспектов.

## 2686. Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?

Да, в JPA классы сущностей (Entity) могут наследоваться от классов, которые не являются сущностями (non-entity classes) Это означает, что вы можете создавать иерархию классов, где классы сущностей наследуют свойства и методы от других классов, которые не являются сущностями.

Например, у вас может быть класс Person, который является сущностью и представляет информацию о человеке. Вы также можете создать класс Employee, который наследует класс Person и представляет информацию о сотруднике. Класс Employee будет также являться сущностью и будет иметь свои собственные атрибуты и методы, а также унаследованные от класса Person.

Вот пример кода на языке Java, демонстрирующий наследование класса сущности от класса, который не является сущностью:
```java
@Entity
public class Person {
    // Атрибуты и методы класса Person
}

@Entity
public class Employee extends Person {
    // Дополнительные атрибуты и методы класса Employee
}
```

В этом примере класс Employee наследует атрибуты и методы класса Person, а также имеет свои собственные атрибуты и методы.

Таким образом, JPA позволяет создавать иерархию классов сущностей, где классы сущностей могут наследоваться от классов, которые не являются сущностями.


## 2687. Может ли Entity класс наследоваться от других Entity классов?

Да, в JPA классы сущностей (Entity) могут наследоваться от других классов сущностей или от обычных классов (non-entity classes). Это позволяет создавать иерархию классов и наследовать общие свойства и методы от родительских классов. Наследование в JPA осуществляется с помощью ключевого слова extends. Например, если у вас есть класс сущности Person, вы можете создать класс Employee, который наследует свойства и методы класса Person с помощью наследования в JPA:
```java
@Entity
public class Person {
    // свойства и методы класса Person
}

@Entity
public class Employee extends Person {
    // свойства и методы класса Employee
}
```

Таким образом, класс Employee будет иметь все свойства и методы класса Person, а также свои собственные свойства и методы.

Важно отметить, что при наследовании классов сущностей в JPA существуют некоторые ограничения и правила, которые нужно учитывать. Например, классы сущностей должны иметь аннотацию @Entity, а также должны иметь уникальное имя в пределах персистентного контекста. Более подробную информацию о наследовании классов сущностей в JPA можно найти в документации Java Persistence API.

## 2688. Может ли не Entity класс наследоваться от Entity класса?
Да, в JPA не-Entity классы могут наследоваться от Entity классов. JPA позволяет использовать наследование для создания иерархии классов, где родительский класс является Entity, а дочерний класс наследует его свойства и атрибуты. Это позволяет создавать более гибкую структуру данных и управлять наследованием в контексте хранения данных в базе данных.

Пример:
```java
@Entity
public class BaseEntity {
    @Id
    private Long id;
    // other properties and methods
}

@Entity
public class ChildEntity extends BaseEntity {
    // additional properties and methods specific to ChildEntity
}
```

В этом примере класс ChildEntity наследуется от класса BaseEntity, который является Entity классом. ChildEntity будет иметь все свойства и атрибуты BaseEntity, а также может добавлять свои собственные свойства и методы.

## 2689. Может ли Entity быть абстрактным классом?
Да, в JPA абстрактный класс может быть сущностью (entity). Абстрактная сущность отличается от конкретной сущности только тем, что она не может быть напрямую создана. Абстрактная сущность также может быть отображена как сущность и может быть целью запросов (которые будут работать с экземплярами ее конкретных подклассов).

Пример:
```java
import javax.persistence.Entity;

@Entity
public abstract class AbstractEntity {
    // поля и методы абстрактной сущности
}
```

Важно отметить, что абстрактные сущности не могут быть напрямую сохранены в базе данных, но их конкретные подклассы могут быть сохранены и использованы в запросах.

## 2690. Какие требования JPA к Entity классам вы можете перечислить (не менее шести требований)?
JPA (Java Persistence API) устанавливает некоторые требования к классам сущностей. Вот несколько из них:

+ Класс сущности должен быть аннотирован аннотацией @Entity.
+ Класс сущности должен иметь публичный конструктор без аргументов.
+ Класс сущности должен иметь уникальный идентификатор, который может быть определен с помощью аннотации @Id.
+ Класс сущности должен иметь аннотацию @Table, если требуется настройка имени таблицы.
+ Класс сущности может иметь аннотацию @Column, чтобы настроить свойства столбцов.
+ Класс сущности может иметь аннотацию @GeneratedValue, чтобы настроить автоматическую генерацию значений первичного ключа.

Это лишь некоторые из требований JPA к классам сущностей. Существуют и другие требования, которые можно изучить в документации JPA.

Пример кода:
```java
@Entity
@Table(name = "my_entity")
public class MyEntity {
    @Id
    @GeneratedValue
    private Long id;

    // Другие поля и методы класса
}
```

Обратите внимание: Это лишь пример кода, и требования JPA к классам сущностей могут быть более сложными и разнообразными в зависимости от конкретных требований вашего приложения и используемого поставщика JPA, такого как Hibernate

## 2691. Какие два типа элементов есть у Entity классов. Или другими словами перечислите два типа доступа (access) к элементам Entity классов.
Entity классы в JPA имеют два типа доступа к элементам:

Property Access (Доступ через свойства): При использовании этого типа доступа, элементы Entity класса доступны через геттеры и сеттеры свойств. Это означает, что для доступа к полям Entity класса используются методы доступа, а не непосредственно обращение к полям класса.

Field Access (Доступ через поля): При использовании этого типа доступа, элементы Entity класса доступны напрямую через поля класса, без использования геттеров и сеттеров. Это означает, что для доступа к полям Entity класса можно обращаться непосредственно к полям класса.

Таким образом, в JPA существуют два типа доступа к элементам Entity классов: Property Access (доступ через свойства) и Field Access (доступ через поля)



## 2692. Что такое атрибут Entity класса в терминологии JPA?

Атрибут Entity класса в терминологии JPA относится к Java Persistence API (JPA) и представляет собой свойство или поле класса, которое используется для доступа к постоянному состоянию сущности. Постоянное состояние сущности может быть доступно через методы доступа к свойствам JavaBeans (property access) или через переменные экземпляра (field access).

JPA предоставляет возможность выбора между использованием свойств или полей для доступа к постоянному состоянию класса или иерархии сущностей Этот выбор определяется с помощью аннотации @Access или другими средствами, описанными в разделе 2.3 спецификации JPA.

Например, если у вас есть класс с аннотацией @Entity, то атрибуты этого класса могут быть определены как свойства с помощью методов доступа к свойствам JavaBeans или как поля класса.

Пример использования свойств (property access):
@Entity
public class Person {
    private String name;

    @Id
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
Пример использования полей (field access):
@Entity
@Access(AccessType.FIELD)
public class Person {
    @Id
    private Long id;

    private String name;

    // геттеры и сеттеры опущены для краткости
}
В обоих примерах атрибуты id и name являются атрибутами сущности (Entity) и могут быть доступными для постоянного хранения и извлечения данных с помощью JPA.

## 2693. Какие типы данных допустимы в атрибутах Entity класса (полях или свойствах)?

PA (Java Persistence API) позволяет использовать различные типы данных в атрибутах Entity класса. Атрибуты могут быть определены как поля (fields) или свойства (properties).

Атрибуты класса могут быть примитивными типами данных, такими как целые числа (int, long), числа с плавающей точкой (float, double), логические значения (boolean), символы (char) и строки (String). Они также могут быть объектами других классов, включая пользовательские классы.

Кроме того, JPA поддерживает использование коллекций, таких как списки (List), множества (Set) и карты (Map), в атрибутах Entity класса. Это позволяет представлять связи между сущностями и обеспечивает возможность хранения и извлечения связанных данных.

Важно отметить, что типы данных, поддерживаемые JPA, зависят от используемого поставщика JPA (например, Hibernate). Различные поставщики могут предоставлять дополнительные типы данных или расширенные возможности для работы с типами данных.

Примеры типов данных, допустимых в атрибутах Entity класса:
+ Примитивные типы данных: int, long, float, double, boolean, char
+ Строки: String
+ Другие классы: пользовательские классы, классы из стандартной библиотеки Java
+ Коллекции: List, Set, Map

Примечание: Перечисленные типы данных являются лишь примерами и не исчерпывают все возможности JPA. Реальные типы данных, которые можно использовать в атрибутах Entity класса, зависят от конкретной реализации JPA и используемого поставщика

## 2694. Какие типы данных можно использовать в атрибутах, входящих в первичный ключ Entity класса (составной или простой), чтобы полученный первичный ключ мог использоваться для любой базы данных? А в случае автогенерируемого первичного ключа (generated primary keys)?

Для того чтобы полученный первичный ключ мог использоваться для любой базы данных, можно использовать различные типы данных в атрибутах, входящих в первичный ключ Entity класса.

1. Простой первичный ключ:

+ Целочисленные типы данных, такие как INT, BIGINT, SMALLINT.
+ Символьные типы данных, такие как CHAR, VARCHAR.
+ Уникальные идентификаторы, такие как GUID (глобально уникальный идентификатор).
+ Другие типы данных, такие как DOUBLE, FLOAT.

2. Составной первичный ключ:

+ Можно использовать комбинацию различных типов данных, таких как INT и VARCHAR.
+ Также можно использовать уникальные идентификаторы, такие как GUID.

3. Автогенерируемый первичный ключ
В случае автогенерируемого первичного ключа, тип данных может зависеть от конкретной базы данных, которую вы используете.

Некоторые базы данных предоставляют специальные типы данных для автогенерируемых первичных ключей, такие как:

+ В MS SQL Server используется тип данных IDENTITY.
+ В MySQL используются типы данных INT, DOUBLE, FLOAT.
+ В PostgreSQL можно использовать тип данных SERIAL.

Также можно использовать другие типы данных, такие как целочисленные типы данных, чтобы автоматически генерировать значения для первичного ключа.

Примеры
Пример создания таблицы с простым первичным ключом в MySQL:
```sql
CREATE TABLE CUSTOMERS (
  ID INT NOT NULL,
  NAME VARCHAR(20) NOT NULL,
  AGE INT NOT NULL,
  ADDRESS CHAR(25),
  SALARY DECIMAL(18, 2),
  PRIMARY KEY (ID)
);
```

Пример создания таблицы с автогенерируемым первичным ключом в MS SQL Server:
```sql
CREATE TABLE TableName (
  id INT IDENTITY(1, 1),
  column1 VARCHAR(50),
  column2 MONEY,
  column3 NUMERIC(10, 2),
  CONSTRAINT PK_id PRIMARY KEY (id)
);
```

Примечание: При выборе типа данных для первичного ключа, рекомендуется учитывать требования и особенности конкретной базы данных, с которой вы работаете.



## 2695. Что такое встраиваемый (Embeddable) класс?
Встраиваемый (Embeddable) класс в JPA (Java Persistence API) представляет собой класс, который может быть встроен в другой класс в качестве его составной части. Он используется для моделирования сложных структур данных, когда необходимо объединить несколько полей в одно логическое целое.

Встраиваемый класс помечается аннотацией @Embeddable, а поле, содержащее этот класс, помечается аннотацией @Embedded. Это позволяет JPA автоматически сохранять и извлекать данные из встраиваемого класса вместе с основным классом.

Пример использования встраиваемого класса в JPA:
```java
@Embeddable
public class Address {
    private String street;
    private String city;
    private String zipCode;
    // геттеры и сеттеры
}

@Entity
public class Employee {
    @Id
    private Long id;
    private String name;
    @Embedded
    private Address address;
    // геттеры и сеттеры
}
```
В приведенном примере класс Address является встраиваемым классом, который содержит поля street, city и zipCode. Класс Employee содержит поле address, которое является экземпляром класса Address и помечено аннотацией @Embedded.

Таким образом, встраиваемый класс позволяет объединить несколько полей в одну логическую единицу и использовать его в других классах для упрощения моделирования данных.

## 2696. Может ли встраиваемый (Embeddable) класс содержать другой встраиваемый (Embeddable) класс?

Да, встраиваемый (Embeddable) класс в JPA может содержать другой встраиваемый (Embeddable) класс. Встраиваемые классы позволяют вам создавать структурированные объекты данных, которые могут быть вложены в другие классы или сущности. Вы можете определить встраиваемые классы внутри других встраиваемых классов, чтобы создать иерархию встраиваемых объектов. Это позволяет вам создавать более сложные структуры данных, которые хранятся в одном поле или столбце базы данных.

## 2697. Может ли встраиваемый (Embeddable) класс содержать связи (relationship) с другими Entity или коллекциями Entity? Если может, то существуют ли какие-то ограничение на такие связи (relationship)?

Да, встраиваемый (Embeddable) класс в Java может содержать связи (relationship) с другими Entity или коллекциями Entity. Однако, существуют некоторые ограничения на такие связи. Например, встраиваемый класс не может содержать связь типа "ManyToOne" или "OneToMany". Также, встраиваемый класс не может быть корневым сущностным классом, то есть он должен быть вложенным в другой сущностный класс.

Пример:
```java
@Embeddable
public class Address {
    private String street;
    private String city;
    private String state;
    private String country;

    // Конструкторы, геттеры и сеттеры
}

@Entity
public class Person {
    @Id
    private Long id;
    private String name;

    @Embedded
    private Address address;

    // Конструкторы, геттеры и сеттеры
}
```
В приведенном примере класс Address является встраиваемым классом, который содержит связи с классом Person. В классе Person используется аннотация @Embedded, чтобы указать, что поле address является встраиваемым классом.

Ограничения на связи (relationship) в встраиваемых классах:

Встраиваемый класс не может содержать связь типа "ManyToOne" или "OneToMany".
Встраиваемый класс не может быть корневым сущностным классом и должен быть вложенным в другой сущностный класс.

## 2698. Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?
JPA устанавливает следующие требования к встраиваемым (Embeddable) классам:

+ Встраиваемый класс может содержать отношение к сущности или коллекции сущностей.
+ Так как экземпляры встраиваемых классов сами по себе не имеют постоянной идентичности, отношение от ссылочной сущности указывает на сущность, которая содержит встраиваемый экземпляр(ы), а не на сам встраиваемый класс.
+ Встраиваемый класс, который используется в качестве встроенного идентификатора или в качестве ключа карты, не должен содержать такого отношения.

## 2699. Какие типы связей (relationship) между Entity вы знаете (перечислите восемь типов, либо укажите четыре типа связей, каждую из которых можно разделить ещё на два вида)?
В JPA (Java Persistence API) существует несколько типов связей между Entity. Вот четыре основных типа связей, каждый из которых можно разделить на два вида:

+ Однонаправленная связь "Один-к-Одному" (One-to-One):

Вид 1: Одна сущность связана с другой сущностью через атрибут-ссылку.
Вид 2: Одна сущность связана с другой сущностью через атрибут-коллекцию.

+ Двунаправленная связь "Один-ко-Многим" (One-to-Many):

Вид 1: Одна сущность связана с несколькими сущностями через атрибут-коллекцию.
Вид 2: Несколько сущностей связаны с одной сущностью через атрибут-ссылку.

+ Двунаправленная связь "Многие-ко-Многим" (Many-to-Many):

Вид 1: Несколько сущностей связаны с несколькими сущностями через атрибут-коллекцию.
Вид 2: Несколько сущностей связаны с несколькими сущностями через атрибут-коллекцию с дополнительной сущностью-связью.

+ Связь "Вложенные коллекции" (Embedded Collections):

Вид 1: Одна сущность содержит вложенную коллекцию других сущностей.
Вид 2: Одна сущность содержит вложенную коллекцию других сущностей с дополнительными атрибутами.

Примечание: В JPA также существуют другие типы связей, такие как "Многие-к-Одному" (Many-to-One) и "Один-ко-Одному с общей таблицей" (One-to-One with Shared Primary Key), но они не были упомянуты в данном списке.

## 2700. Что такое Mapped Superclass?

Mapped Superclass (отображаемый суперкласс) - это аннотация в Java Persistence API (JPA), которая позволяет создавать иерархию классов, где суперкласс содержит общую информацию о сопоставлении с базой данных, но сам не является сущностью.

Основная цель использования аннотации @MappedSuperclass состоит в том, чтобы избежать дублирования кода и сопоставления при работе с несколькими сущностями, которые имеют общие поля и отношения с базой данных.

Когда класс отмечен аннотацией @MappedSuperclass, его сопоставление применяется только к его подклассам, поскольку для самого суперкласса не существует таблицы в базе данных Таким образом, все подклассы наследуют сопоставление и состояние от суперкласса.

Преимущества использования @MappedSuperclass включают:

Избежание дублирования кода и сопоставления при работе с несколькими сущностями.
Возможность определить общую информацию о сопоставлении с базой данных в одном месте.
Поддержка наследования иерархии классов.
Однако, есть некоторые ограничения при использовании @MappedSuperclass:

+ Суперкласс не может быть самостоятельно сущностью и не может быть целью постоянного отношения.
+ Суперкласс не может быть запрошен или передан в операции сущности или запроса.

Пример использования аннотации @MappedSuperclass:
```java
@MappedSuperclass
public abstract class BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Общие поля и методы
}

@Entity
public class Employee extends BaseEntity {
    // Дополнительные поля и методы для класса Employee
}

@Entity
public class Customer extends BaseEntity {
    // Дополнительные поля и методы для класса Customer
}
```

В этом примере класс BaseEntity отмечен аннотацией @MappedSuperclass и содержит общее поле id, которое будет унаследовано подклассами Employee и Customer. Классы Employee и Customer также могут иметь свои собственные дополнительные поля и методы.


## 2701. Какие три типа стратегии наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?
В JPA описаны три типа стратегии наследования мапинга (Inheritance Mapping Strategies):

Одна таблица на иерархию (Single Table): В этой стратегии все классы наследники отображаются в одной таблице. Для различения типов объектов используется специальный столбец, который указывает на конкретный тип объекта. Эта стратегия обеспечивает простоту и производительность, но может привести к большому количеству NULL значений в таблице.

Таблица на класс (Table per Class): В этой стратегии каждый класс наследник отображается в отдельной таблице. Каждая таблица содержит только поля, специфичные для данного класса, а также поля, унаследованные от родительского класса. Эта стратегия обеспечивает более нормализованную структуру базы данных, но может привести к проблемам с производительностью при выполнении запросов, которые требуют объединения таблиц.

Таблица на конкретный класс (Table per Concrete Class): В этой стратегии каждый класс наследник отображается в отдельной таблице, включая все поля, унаследованные от родительского класса. Эта стратегия обеспечивает наиболее нормализованную структуру базы данных, но может привести к дублированию данных и сложностям при поддержке.

Это основные стратегии наследования мапинга в JPA. Каждая из них имеет свои преимущества и недостатки, и выбор конкретной стратегии зависит от требований и особенностей приложения

## 2702. Какие два типа fetch стратегии в JPA вы знаете?
В Java Persistence API (JPA) существуют две стратегии загрузки (fetch strategies): EAGER и LAZY.

EAGER (жадная) стратегия подразумевает, что связанные сущности будут загружены сразу же при загрузке основной сущности. Это означает, что все связанные сущности будут извлечены из базы данных и загружены в память вместе с основной сущностью. Использование EAGER загрузки может привести к избыточной загрузке данных, особенно если связанные сущности содержат большое количество данных или если связь имеет глубокую иерархию.

LAZY (ленивая) стратегия подразумевает, что связанные сущности будут загружены только при первом доступе к ним. Это означает, что связанные сущности не будут извлечены из базы данных и загружены в память, пока не будет выполнен доступ к ним. Использование LAZY загрузки позволяет уменьшить количество загружаемых данных и повысить производительность при работе с большими объемами данных.

Выбор между EAGER и LAZY стратегиями загрузки зависит от конкретных требований приложения и особенностей работы сущностей. Если необходимо всегда загружать связанные сущности вместе с основной сущностью, то можно использовать EAGER загрузку. Если же требуется отложенная загрузка связанных сущностей для оптимизации производительности или уменьшения объема загружаемых данных, то следует использовать LAZY загрузку.

Например, в JPA можно указать стратегию загрузки для связи OneToMany следующим образом:
```java
@OneToMany(fetch = FetchType.LAZY)
```

В данном примере используется LAZY загрузка, что означает, что связанные сущности будут загружены только при первом доступе к ним.

Обратите внимание, что выбор стратегии загрузки зависит от конкретной ситуации и требований приложения. Необходимо тщательно оценить производительность и объем загружаемых данных при выборе стратегии загрузки в JPA.

## 2703. Что такое EntityManager и какие основные его функции вы можете перечислить?
EntityManager - это интерфейс в Java Persistence API (JPA), который предоставляет методы для управления жизненным циклом сущностей в базе данных. Он является основным инструментом для работы с JPA и предоставляет функции для выполнения операций CRUD (создание, чтение, обновление, удаление) с сущностями.

Основные функции EntityManager включают:

Создание и удаление сущностей: EntityManager предоставляет методы для создания новых сущностей и удаления существующих. Например, метод persist(entity) используется для создания новой сущности, а метод remove(entity) - для удаления существующей.

+ Обновление сущностей: EntityManager позволяет обновлять существующие сущности в базе данных. Изменения, внесенные в сущность, могут быть автоматически синхронизированы с базой данных при вызове метода merge(entity).
+ Поиск сущностей: EntityManager предоставляет методы для выполнения запросов к базе данных и поиска сущностей. Например, метод find(entityClass, primaryKey) используется для поиска сущности по ее первичному ключу.
+ Управление транзакциями: EntityManager позволяет управлять транзакциями при выполнении операций с базой данных. Он предоставляет методы для начала, фиксации и отката транзакции.
+ Кэширование: EntityManager поддерживает кэширование сущностей и запросов для улучшения производительности. Он предоставляет методы для управления кэшем сущностей и запросов.
+ Отслеживание изменений: EntityManager отслеживает изменения, внесенные в сущности, и автоматически синхронизирует их с базой данных при фиксации транзакции. Это позволяет обновлять базу данных только при необходимости и уменьшает количество запросов к базе данных.

EntityManager является важной частью JPA и предоставляет удобный способ работы с базой данных в Java-приложениях. Он абстрагирует различные детали взаимодействия с базой данных и предоставляет удобный API для работы с сущностями и выполнения операций с базой данных


## 2704. Какие четыре статуса жизненного цикла Entity объекта (Entity Instance’s Life Cycle) вы можете перечислить?
Entity объекты имеют четыре основных статуса в своем жизненном цикле. Вот они:

+ Transient (Переходный): В этом статусе Entity объект только что был создан и еще не связан с каким-либо постоянным хранилищем данных. Он не имеет идентификатора и не отображается в базе данных.
+ Persistent (Постоянный): Когда Entity объект сохраняется в базе данных, он переходит в статус постоянного объекта. В этом статусе объект имеет идентификатор и отображается в базе данных.
+ Detached (Отсоединенный): Если Entity объект был отсоединен от постоянного хранилища данных, например, после закрытия сессии или завершения транзакции, он переходит в статус отсоединенного объекта. В этом статусе объект не отслеживается фреймворком и не синхронизируется с базой данных.
+ Removed (Удаленный): Когда Entity объект явно помечается для удаления из базы данных, он переходит в статус удаленного объекта. В этом статусе объект будет удален из базы данных при следующей синхронизации с базой данных.

## 2705. Как влияет операция persist на Entity объекты каждого из четырех статусов?
Операция persist влияет на объекты сущностей каждого из четырех статусов следующим образом:

+ Transient (новый) статус: Если объект сущности находится в состоянии transient (новый), то операция persist приведет к переходу объекта в состояние managed (управляемый). Объект будет сохранен в базе данных при следующей транзакции.
+ Managed (управляемый) статус: Если объект сущности находится в состоянии managed (управляемый), то операция persist не будет иметь никакого эффекта. Объект уже находится в управляемом состоянии и будет сохранен в базе данных при следующей транзакции.
+ Detached (отсоединенный) статус: Если объект сущности находится в состоянии detached (отсоединенный), то операция persist приведет к переходу объекта в состояние managed (управляемый). Объект будет снова связан с контекстом персистентности и сохранен в базе данных при следующей транзакции.
+ Removed (удаленный) статус: Если объект сущности находится в состоянии removed (удаленный), то операция persist не будет иметь никакого эффекта. Объект уже помечен для удаления и будет удален из базы данных при следующей транзакции.

## 2706. Как влияет операция remove на Entity объекты каждого из четырех статусов?
Операция remove влияет на объекты сущностей каждого из четырех статусов следующим образом:

+ Новый (New): Если объект сущности находится в статусе "New" и вызывается операция remove, то объект будет удален из контекста персистентности и базы данных. После удаления, объект сущности будет переведен в состояние "Detached" (отсоединенный).
+ Управляемый (Managed): Если объект сущности находится в статусе "Managed" и вызывается операция remove, то объект будет удален из контекста персистентности и базы данных. После удаления, объект сущности будет переведен в состояние "Removed" (удаленный).
+ Удаленный (Removed): Если объект сущности находится в статусе "Removed" и вызывается операция remove, то операция будет проигнорирована, так как объект уже был помечен для удаления.
+ Отсоединенный (Detached): Если объект сущности находится в статусе "Detached" и вызывается операция remove, то операция будет проигнорирована, так как объект не находится в контексте персистентности.

Источник содержит информацию о жизненном цикле сущностей в Java Persistence API (JPA), включая операцию remove.

## 2707. Как влияет операция merge на Entity объекты каждого из четырех статусов?

## 2708. Как влияет операция refresh на Entity объекты каждого из четырех статусов?

## 2709. Как влияет операция detach на Entity объекты каждого из четырех статусов?

## 2710. Для чего нужна аннотация Basic?

## 2711. Для чего нужна аннотация Access?

## 2712. Какими аннотациями можно перекрыть связи (override entity relationship) или атрибуты, унаследованные от суперкласса, или заданные в embeddable классе при использовании этого embeddable класса в одном из entity классов и не перекрывать в остальных?

## 2713. Какой аннотацией можно управлять кешированием JPA для данного Entity?

## 2714. Какие аннотации служит для задания класса преобразования basic атрибута Entity в другой тип при сохранении/получении данных их базы (например, работать с атрибутом Entity boolean типа, но в базу сохранять его как число)?

## 2715. Какой аннотацией можно задать класс, методы которого должен выполнится при определенных JPA операциях над данным Entity или Mapped Superclass (такие как удаление, изменение данных и т.п.)?

## 2716. Для чего нужны callback методы в JPA? К каким сущностям применяются аннотации callback методов? Перечислите семь callback методов (или что тоже самое аннотаций callback методов)

## 2717. Какие аннотации служить для установки порядка выдачи элементов коллекций Entity?

## 2718. Какой аннотацей можно исключить поля и свойства Entity из маппинга (property or field is not persistent)?
## 2719. Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?

## 2720. Какие есть варианты настройки second-level cache (кэша второго уровня) в JPA или что аналогично опишите какие значения может принимать элемент shared-cache-mode из persistence.xml?
## 2721. Как можно изменить настройки fetch стратегии любых атрибутов Entity для отдельных запросов (query) или методов поиска (find), то если у Entity есть атрибут с fetchType = LAZY, но для конкретного запроса его требуется сделать EAGER или наоборот?
## 2722. Каким способом можно в коде работать с кэшем второго уровня (удалять все или определенные Entity из кеша, узнать закэшировался ли данное Entity и т.п.)?
## 2723. Каким способом можно получить метаданные JPA (сведения о Entity типах, Embeddable и Managed классах и т.п.)?
## 2724. Что такое JPQL (Java Persistence query language) и чем он отличается от SQL?
## 2725. Что означает полиморфизм (polymorphism) в запросах JPQL (Java Persistence query language) и как его «выключить»?
## 2726. Что такое Criteria API и для чего он используется?
## 2727. В чем разница в требованиях к Entity в Hibernate, от требований к Entity, указанных в спецификации JPA (см. вопрос 10)?
## 2728. Какая уникальная стратегия наследования есть в Hibernate, но нет в спецификации JPA?
## 2729. Какие основные новые возможности появились в спецификации JPA 2.1 по сравнению с JPA 2.0 (перечислите хотя бы пять-шесть новых возможностей)?



