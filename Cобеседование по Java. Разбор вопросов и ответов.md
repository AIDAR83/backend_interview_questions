# Cобеседование по Java. Разбор вопросов и ответов.


<a href="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%">
    <img src="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%" />        
  </a>&nbsp;&nbsp;
<a href="https://mc.yandex.ru/watch/92801430">
    <img src="https://mc.yandex.ru/watch/92801430" />        
  </a>&nbsp;&nbsp;

1606 вопросов 900 ответов


Нажмите ★, если вам нравится проект. Ваш вклад сердечно ♡ приветствуется.

Если вам интересно мое резюме: https://github.com/DEBAGanov


# 1 Блок вопросов


Junior

Общие



## 1. `Какие знаете шаблоны проектирования? Расскажите о двух шаблонах, используемых в работе.`


Core Java



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 2. `Какие типы данных в Java? Чем отличается объект от простых типов данных?`
В Java существует 8 простых типов данных:

+ byte - 8-битное целое число со знаком (-128 до 127)
+ short - 16-битное целое число со знаком (-32,768 до 32,767)
+ int - 32-битное целое число со знаком (-2,147,483,648 до 2,147,483,647)
+ long - 64-битное целое число со знаком (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807)
+ float - 32-битное число с плавающей точкой (1.4E-45 до 3.4028235E+38)
+ double - 64-битное число с плавающей точкой (4.9E-324 до 1.7976931348623157E+308)
+ char - 16-битный символ Unicode ('\u0000' до '\uffff')
+ boolean - логическое значение (true или false)

Также в Java есть объектные типы данных, которые являются экземплярами классов, и могут хранить некоторые данные и иметь методы. Объекты могут хранить данные разных типов, даже простых типов данных. Например, объект типа Integer может хранить целое число типа int.

Разница между простыми типами данных и объектами заключается в способе хранения данных и доступе к ним. Простые типы данных хранятся в стеке, в то время как объекты - в куче. Объекты также могут иметь методы для обработки своих данных, тогда как простые типы данных этого не могут.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 3. `В чем разница передачи параметров по ссылке и значению?`

В Java все аргументы метода передаются по значению, то есть копируется значение переменной (даже если она ссылочного типа). Однако у ссылочных переменных копируется лишь значение ссылки, а не объекта, на который она ссылается. Поэтому, если произойдет изменение состояния объекта, на который ссылается переданная ссылка, то эти изменения будут отражены на объекте, на который ссылается исходная переменная. Таким образом, то, что большинство людей называют "передачей по ссылке", на самом деле называется "передачей значения ссылки".

Пример:
```java
public class Test {
    public static void main(String[] args) {
        StringBuffer str = new StringBuffer("hello");
        change(str);
        System.out.println(str);
    }

    public static void change(StringBuffer newStr) {
        newStr.append(" world");
    }
}
```
В этом примере метод change() принимает ссылку на объект StringBuffer и модифицирует его, добавляя к нему строку " world". В методе main() переменная str также ссылается на этот же самый объект StringBuffer, поэтому после вызова метода change() будет выведена строка "hello world".



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 4. `Что такое JVM, JDK, JRE?`

JVM, JDK и JRE - это три основных понятия в мире Java-разработки.

`JVM (Java Virtual Machine)` - виртуальная машина Java , которая выполняет Java-байткод. Все программы на Java компилируются в байткод, который может быть выполнен на любой платформе, на которую установлена JVM.

`JDK (Java Development Kit)` - это пакет разработчика Java , который включает в себя всё необходимое для разработки Java-приложений, включая компилятор javac, библиотеки классов, документацию, примеры кода и JVM.

`JRE (Java Runtime Environment)` - это пакет для запуска Java-приложений, который включает в себя JVM, библиотеки классов и другие необходимые компоненты для запуска Java-приложений.

Кратко говоря, если вы планируете разработку Java-приложений, то вам нужна JDK. Если же вы планируете только запускать Java-приложения, то вам достаточно установить JRE, которая включает в себя JVM.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 6. `Зачем используют JVM?`

`JVM (виртуальная машина Java)` — важнейший компонент языка программирования Java. Это абстрактная машина, предоставляющая среду выполнения, в которой может выполняться скомпилированный код Java. Вот несколько причин, почему JVM важна и широко используется в разработке программного обеспечения:

+ `Переносимость`: код Java можно написать один раз и запустить на любой платформе, на которой установлена ​​JVM, независимо от базового оборудования и операционной системы. Это делает Java-программы легко переносимыми и уменьшает количество кода, необходимого для конкретной платформы. 
+ `Управление памятью`: JVM управляет распределением памяти и автоматически освобождает неиспользуемую память посредством сборки мусора. Это освобождает разработчиков от утомительной и чреватой ошибками задачи ручного управления памятью. 
+ `Безопасность`. Поскольку JVM выполняет код Java в изолированной среде, это предотвращает причинение вреда базовой системе вредоносным кодом. Это делает Java популярным выбором для создания безопасных и надежных приложений. 
+ `Производительность`: JVM создана для оптимизации выполнения кода Java и использует передовые методы, такие как своевременная компиляция, для достижения высокой производительности.

В целом, JVM играет критическую роль в языке программирования Java, предоставляя многочисленные преимущества, которые делают его популярным выбором для создания надежных, безопасных и переносимых приложений.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 7. `Что такое bytecode?`

`Bytecode` в Java - это набор инструкций, разработанных для исполнения на виртуальной машине Java (JVM). Он представляет собой низкоуровневый, но переносимый по архитектуре набор инструкций, который может быть выполняем на любой машине Java. Java-программы компилируются в байт-код, который может быть распространен и загружен на любой машине, на которой установлено соответствующее окружение выполнения Java. После того как байт-код загружается в виртуальную машину, он транслируется в машинный код и исполняется. Это позволяет программам Java быть переносимыми между различными платформами без необходимости перекомпилировать их на каждой платформе.


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 8. `Какие признаки JavaBean?`
`JavaBeans` - это классы в языке Java, которые следуют определенным правилам и используются для управления объектами в приложениях. Вот некоторые основные признаки JavaBean:

+ Класс должен иметь стандартный конструктор без параметров.
+ Свойства должны быть доступны через геттеры (get) и сеттеры (set) методы.
+ Имена геттеров и сеттеров должны соответствовать стандартной схеме: для свойства "foo" геттер должен иметь имя "getFoo", а сеттер - "setFoo".
+ Класс должен реализовывать java.io.Serializable интерфейс, чтобы его можно было сериализовать.

Некоторые другие признаки включают использование аннотации @ManagedBean, наличие методов добавления и удаления для свойств типа коллекций и поддержку событий с помощью методов с именами типа add<EventListenerType>Listener и remove<EventListenerType>Listener.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 9. `Что такое OutOfMemoryError?`

`OutOfMemoryError` — это ошибка времени выполнения в языке программирования Java, которая возникает, когда виртуальная машина Java (JVM) не может выделить память для создания новых объектов, поскольку пространство кучи заполнено и больше нет места для хранения новых объектов. 
`Куча space` — это пространство памяти, используемое JVM для выделения и освобождения объектов, созданных во время выполнения. Важно эффективно управлять использованием памяти в Java, чтобы избежать исключений OutOfMemoryError. Этого можно добиться путем оптимизации кода, сокращения потребления памяти и использования соответствующих методов управления памятью, таких как сборка мусора, эффективные структуры данных и шаблоны проектирования. Кроме того, вы можете увеличить максимальный размер кучи, доступный для JVM, используя такие параметры командной строки, как -Xmx, чтобы избежать нехватки памяти.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 10. `Что такое стектрейс? Как его получить?`

`Стек-трейс (stack trace)` - это список вызовов методов, которые привели к возникновению исключения (exception) в программе на языке Java. С помощью стек-трейса можно определить, в какой части программы произошла ошибка, и узнать, как программа пришла к этому месту.

Для получения стек-трейса в Java вы можете воспользоваться методом printStackTrace() класса Throwable. Пример использования:
```java
try {
  // some code that may throw an exception
} catch (Exception e) {
  e.printStackTrace();
}
```
Этот код вызовет метод printStackTrace() для исключения, которое было поймано в блоке catch, и выведет стек-трейс в консоль.

Также в Java есть возможность получить объект типа StackTraceElement[], который представляет собой список элементов стека вызовов. Пример использования:
```java
try {
  // some code that may throw an exception
} catch (Exception e) {
  StackTraceElement[] stackTraceElements = e.getStackTrace();
  // do something with the array of stack trace elements
}
```
Этот код вызовет метод getStackTrace() для исключения, которое было поймано в блоке catch, и получит список элементов стека вызовов в виде массива объектов типа StackTraceElement. Далее этот массив можно использовать для анализа и отладки ошибок в программе.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 11. `Назовите все методы класса object.`

В Java все классы наследуются от класса Object. Некоторые методы, определенные в классе Object, включают в себя:

+ `getClass()`: возвращает объект Class, который представляет класс объекта
+ `hashCode()`: возвращает хэш-код объекта
+ `equals(Object obj)`: определяет, равен ли данный объект указанному объекту
+ `clone()`: создает и возвращает копию данного объекта
+ `toString()`: возвращает строковое представление объекта
+ `notify()`: возобновляет выполнение потока, заблокированного на объекте
+ `notifyAll()`: возобновляет выполнение всех потоков, заблокированных на данном объекте
+ `wait()`: ожидает до тех пор, пока другой поток не уведомит о возможности продолжения выполнения
+ `finalize()`: вызывается сборщиком мусора перед тем, как объект будет удален

Важно отметить, что эти методы могут быть переопределены в производных классах, если необходимо изменить их реализацию для совместимости с конкретными требованиями приложения.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 12. `В чем разница между try-with-resources и try-catch-finally при работе с ресурсами?`

В Java `try-with-resources` - это новый способ работы с ресурсами, введенный в версии JDK 7. Он автоматически закрывает используемые ресурсы после того, как выполнение блока try завершится. Таким образом, вы можете избежать вручную закрытия ресурсов в блоке finally.

Пример с try-with-resources:
```java
try (InputStream in = new FileInputStream("file.txt")) {
    // считывание данных из потока
} catch (IOException e) {
    // обработка ошибок ввода/вывода
} // здесь in будет автоматически закрыт
```
В то время как в блоке `try-catch-finally`, блок finally выполняется после того, как выполнение блока try завершилось, но перед тем, как управление передается дальше по стеку вызовов. Это означает, что блок finally может использоваться для закрытия ресурсов, открытых в блоке try.

Пример с try-catch-finally:
```java
InputStream in = null;
try {
    in = new FileInputStream("file.txt");
    // считывание данных из потока
} catch (IOException e) {
    // обработка ошибок ввода/вывода
} finally {
    if (in != null) {
        try {
            in.close();
        } catch (IOException e) {
            // обработка ошибок ввода/вывода
        }
    }
}
```
Таким образом, try-with-resources упрощает и уменьшает количество кода при работе с ресурсами и обеспечивает безопасное закрытие использованных ресурсов, в то время как try-catch-finally позволяет закрыть ресурсы, если они были открыты в блоке try и выполнен блок catch, и выполняется в любом случае.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 13. `Что такое конструкторы? Какие типы знаете?`

`Конструкторы` - это методы класса в Java, которые вызываются при создании нового объекта этого класса. Их основная задача - инициализировать поля нового объекта.

Существует два типа конструкторов в Java:

+ `Конструктор по умолчанию` - это конструктор без параметров, который создается компилятором, если в классе не определен ни один конструктор. Он просто инициализирует все поля значениями по умолчанию.

+ `Пользовательский конструктор` - это конструктор, который создается программистом и который может иметь параметры. Он может выполнять любой код и инициализировать поля объекта значениями, переданными в параметрах.

Пример создания пользовательского конструктора в Java:
```java
public class MyClass {
    int x;
    
    // Пользовательский конструктор с одним параметром
    public MyClass(int x) {
        this.x = x;
    }
}
```
Этот конструктор принимает один параметр x и инициализирует поле класса значением этого параметра. Ключевое слово this используется для ссылки на текущий объект класса. Вы можете создавать любое количество пользовательских конструкторов с разными параметрами.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 14. `Что такое побитовые операции?`
Побитовые операции в Java позволяют работать с двоичным представлением чисел на уровне отдельных битов. В Java доступны следующие побитовые операции:
+ `& (побитовое AND)`: возвращает 1 в каждом разряде двоичного представления, если оба операнда содержат 1, в противном случае - 0.
+ `| (побитовое OR)`: возвращает 1 в каждом разряде двоичного представления, если хотя бы один операнд содержит 1, в противном случае - 0.
+ `^ (побитовое исключающее OR)`: возвращает 1 в каждом разряде двоичного представления, если только один из операндов содержит 1, в противном случае - 0.
+ `~ (побитовое NOT)`: инвертирует каждый бит операнда. 1 становится 0 и наоборот.
+ `<< (сдвиг влево)`: сдвигает биты левого операнда на указанное количество разрядов влево. Недостающие биты заполняются нулями.
+ `>> (сдвиг вправо)`: сдвигает биты левого операнда на указанное количество разрядов вправо. Недостающие биты заполняются нулями. Оставшиеся биты соответствуют знаку операнда.
+ `>>> (беззнаковый сдвиг вправо)`: сдвигает биты левого операнда на указанное количество разрядов вправо. Недостающие биты заполняются

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 15. `Объекты каких стандартных классов immutable в Java?`

В языке Java объекты классов String, Integer, Byte, Character, Short, Boolean, Long, Double и Float являются immutable. Это означает, что значения их полей не могут быть изменены после создания объекта. Таким образом, любые операции с ними, которые изменяют значение, на самом деле создают новый объект. Примером может быть метод substring() в классе String, который создает новый объект строки, содержащий подстроку из исходной строки. Кроме того, вы также можете создавать свои собственные immutable классы в Java, объявляя поля и устанавливая им значения только в конструкторе, а затем делая их final. Это гарантирует, что их значения не могут быть изменены после создания объекта.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 16. `Дайте краткую характеристику immutable object. Зачем они нужны?`

Неизменяемые объекты `(immutable objects)` в Java - это объекты, которые нельзя изменить после их создания. Объекты, такие как строки (String) или числа (Integer), являются неизменяемыми. Когда вы создаете новое значение для такого объекта, на самом деле создается новый объект, и старый объект остается неизменяемым.

Основное преимущество неизменяемых объектов - это их надежность и защита от изменений со стороны других частей программы. Также они обеспечивают безопасность многопоточного программирования, поскольку неизменяемые объекты могут быть разделены между несколькими потоками без риска изменений и ошибок.

Также неизменяемые объекты помогают улучшить производительность программы, потому что их не нужно копировать или клонировать для сохранения неизменным.

Например, вместо создания нового массива при изменении элемента в массиве, вы можете создать новый массив, который копирует все элементы и изменить нужный элемент в нем. Это будет более эффективным по времени и памяти, чем изменение изначального массива.

В целом, неизменяемые объекты помогают упростить разработку и обеспечить надежность программы за счет уменьшения риска ошибок в результате непреднамеренных изменений объектов.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 17. `Как сделать immutable object?`

В Java вы можете сделать объект неизменяемым `(immutable)`, задав его поля как final. `Неизменяемый объект` - это объект, который не может быть изменен после своего создания. Это обычно рекомендуется для создания объектов, которые должны оставаться постоянными во время жизни программы, такие как уникальные идентификаторы или настройки приложения.

Вот пример класса Person, который является неизменяемым:
```java
public final class Person {
    private final String name;
    private final Date birthDate;

    public Person(String name, Date birthDate) {
        this.name = name;
        this.birthDate = new Date(birthDate.getTime());
    }

    public String getName() {
        return name;
    }

    public Date getBirthDate() {
        return new Date(birthDate.getTime());
    }
}
```
В этом примере оба поля name и birthDate помечены как final, что делает их неизменяемыми. Конструктор класса создает новый объект Person с заданными именем и датой рождения. Обратите внимание, что для даты рождения создается новый объект Date, чтобы можно было избежать ее изменения после создания объекта Person.

В целом, чтобы сделать объект неизменяемым, все его поля должны быть объявлены как final и не должны иметь сеттеры для изменения значений после создания объекта.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 18. `Каковы преимущества immutable object перед обычными объектами?`
Преимущества неизменяемых (immutable) объектов перед обычными объектами в Java включают в себя:

+ `Безопасность потоков`: неизменяемые объекты могут быть безопасно использованы в многопоточной среде, так как они не могут быть изменены другим потоком.
+ `Простота`: неизменяемые объекты проще в использовании, так как их значения не могут быть изменены. Это уменьшает количество ошибок и делает программу проще для понимания.
+ `Повторное использование`: неизменяемые объекты могут быть повторно использованы в разных контекстах, так как их значения не изменяются.
+ `Кешеруемость`: неизменяемые объекты могут быть безопасно закэшированы, так как их значения не изменяются.
+ `Сравнение`: неизменяемые объекты могут быть сравнены просто по их значениям, а не по их ссылкам, так как их значения всегда остаются неизменными.
+ `Безопасность`: неизменяемые объекты обеспечивают надежность программы путем предотвращения изменения их значений после создания объекта.

Некоторые из классов Java, такие как String и BigInteger, являются неизменяемыми. Вы можете создать свой собственный класс неизменяемости, объявив все поля как final, а конструктор только со значениями полей. Это защищает поля от изменений и делает объект неизменяемым.


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV> 

ООП


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 19. `Что такое ООП? Назовите принципы с примерами.`
ООП (объектно-ориентированное программирование) - это методология программирования, в которой программа строится на основе объектов, которые имеют свойства и поведение. Основные принципы ООП включают инкапсуляцию, наследование и полиморфизм.

Инкапсуляция - это принцип, который позволяет скрыть детали реализации объекта от других объектов. Таким образом, объект может предоставить только необходимый интерфейс для работы с ним. Например, класс "Человек" может иметь свойство "Возраст", но этот возраст может быть доступен только через метод получения.

Наследование - это принцип, который позволяет создавать новые классы на основе уже существующих. Новый класс наследует свойства и методы родительского класса и может добавить свои собственные свойства и методы. Например, класс "Сотрудник" может наследовать свойства и методы от класса "Человек".

Полиморфизм - это принцип, который позволяет объектам с одинаковым интерфейсом иметь различную реализацию. Такой подход позволяет использовать один и тот же метод для работы с разными типами объектов. Например, метод "рисовать" может иметь различную реализацию для объектов "Круг", "Прямоугольник" и "Треугольник".

В Java эти принципы используются везде - от создания классов до работы с наследованием и полиморфизмом. Например, в классе "Автомобиль" могут быть инкапсулированы свойства, такие как скорость и количество топлива, а метод "двигаться" может использовать полиморфизм, чтобы вызвать различные способы движения для разных типов автомобилей.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 20. `В чем преимущества ООП перед процедурным программированием?`

ООП имеет ряд преимуществ перед процедурным программированием:

+ `Инкапсуляция`: объекты в ООП скрывают свои детали реализации от других объектов, что уменьшает сложность кода и делает его более понятным. Это также обеспечивает более легкое тестирование и модификацию кода.
+ `Наследование`: наследование позволяет создавать новые классы, которые могут наследовать свойства и методы от родительских классов. Это позволяет избежать дублирования кода и уменьшить количество ошибок при изменении кода.
+ `Полиморфизм`: полиморфизм позволяет использовать один и тот же интерфейс для работы с разными типами объектов. Это увеличивает гибкость кода и позволяет повторно использовать уже написанный код.
+ `Безопасность`: ООП позволяет контролировать доступ к свойствам и методам объекта. Таким образом, возможность ошибки в программе сокращается, а ее безопасность увеличивается.
+ `Модульность`: ООП позволяет разбить программу на модули, каждый из которых может быть независимо разработан и тестирован. Это позволяет повысить эффективность разработки и сопровождения программного обеспечения.

В целом, ООП предоставляет ряд методов и инструментов для создания более гибких, масштабируемых и безопасных приложений. Однако, в зависимости от конкретной задачи, процедурное программирование также может быть достаточным и эффективным способом разработки.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 21. `В чем состоит главная особенность ООП?`

Главная особенность ООП (объектно-ориентированного программирования) заключается в том, что программа строится на основе объектов, которые имеют свойства и поведение. В этом подходе данные и функции для их обработки объединены в одном компоненте - классе. Классы могут наследоваться друг от друга, и таким образом создавать дополнительные классы с более сложным поведением.

Это отличается от процедурного программирования, где данные и функции для их обработки могут быть разбиты на отдельные функции, которые работают независимо друг от друга. В ООП, данные и функции для их обработки упаковываются в объекты, которые затем могут использоваться в других частях программы.

Таким образом, ООП позволяет создавать более гибкие и модульные приложения, которые могут быть легко изменены и расширены. Кроме того, ООП позволяет создавать более понятный и читаемый код, так как он базируется на концепции реального мира, что облегчает процесс разработки.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 22. `Расскажите, какие преимущества мы получаем с использованием ООП?`

Использование ООП (объектно-ориентированного программирования) предоставляет множество преимуществ:

+ `Инкапсуляция` - объекты в ООП скрывают свою реализацию от других объектов, что уменьшает сложность кода и делает его более понятным. Это также обеспечивает более легкое тестирование и модификацию кода.
+ `Наследование` - наследование позволяет создавать новые классы, которые могут наследовать свойства и методы от родительских классов. Это позволяет избежать дублирования кода и уменьшить количество ошибок при изменении кода.
+ `Полиморфизм` - полиморфизм позволяет использовать один и тот же интерфейс для работы с разными типами объектов. Это увеличивает гибкость кода и позволяет повторно использовать уже написанный код.
+ `Безопасность` - ООП позволяет контролировать доступ к свойствам и методам объекта. Таким образом, возможность ошибки в программе сокращается, а ее безопасность увеличивается.
+ `Модульность` - ООП позволяет разбить программу на модули, каждый из которых может быть независимо разработан и тестирован. Это позволяет повысить эффективность разработки и сопровождения программного обеспечения.
+ `Улучшенное переиспользование кода` - ООП позволяет создавать гибкие и многократно используемые компоненты, что уменьшает время и затраты на разработку новых приложений.
+ `Повышенная производительность` - ООП-приложения могут быть более производительными, чем их процедурные аналоги, благодаря тому, что объекты могут работать параллельно и использовать локальные кеш-памяти.
+ `Более удобное масштабирование` - ООП позволяет разрабатывать программное обеспечение для сложных систем, которые могут быть масштабированы и модифицированы без необходимости изменения всей программы.

В целом, ООП предоставляет разработчикам ряд методов и инструментов для создания более гибких, масштабируемых и безопасных приложений.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 23. `Расскажите какие недостатки в ООП?`
Как и любой подход к программированию, ООП имеет свои недостатки:

+ `Сложность` - ООП может быть сложным для понимания и использования начинающими разработчиками, особенно если они не имеют опыта работы с объектно-ориентированными языками программирования.
+ `Избыточность` - ООП может приводить к избыточности кода, что увеличивает размер программа и затрудняет ее понимание и сопровождение.
+ `Производительность` - ООП-приложения могут потреблять больше ресурсов, чем процедурные аналоги, благодаря тому, что объекты могут работать параллельно и использовать локальные кеш-памяти.
+ `Наследование` - наследование может вызывать проблемы, если оно не правильно используется. В некоторых случаях наследование может приводить к созданию излишне сложных иерархий классов.
+ `Полиморфизм` - полиморфизм может привести к ошибкам во время выполнения программы, если тип переменной не соответствует ожидаемому типу объекта.
+ `Тестирование` - тестирование ООП-приложений может быть сложнее, чем тестирование процедурных приложений, потому что объекты могут взаимодействовать друг с другом и создавать сложные зависимости.
+ `Ресурсоемкость` - ООП может потреблять больше памяти, чем процедурное программирование, из-за дополнительной информации, которая хранится в каждом объекте.

В целом, ООП имеет свои недостатки, но они не являются серьезными проблемами, если использовать ООП с умом и оптимизировать код.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 24. `Расскажите о принципе наследования в ООП? Зачем он нужен?`

Принцип наследования является одним из основных принципов объектно-ориентированного программирования (ООП). С помощью наследования один класс может наследовать свойства и методы другого класса (родительского класса), что позволяет избежать дублирования кода и повысить его переиспользуемость.

Наследование нужно для уменьшения дублирования кода и повторного использования кода, что позволяет сократить время разработки и упростить сопровождение программного обеспечения. Если у нескольких классов есть общие свойства или методы, то можно выделить эти общие элементы в базовый класс и наследовать их в других классах.

Когда новый класс наследует свойства и методы родительского класса, он может изменять их или добавлять свои собственные свойства и методы. Таким образом, наследование позволяет создавать дополнительные классы с более сложным поведением на основе уже существующих классов.

В Java наследование осуществляется с помощью ключевого слова extends. Например, если хотим создать класс Cat, который наследует свойства и методы класса Animal, код может выглядеть так:
```java
public class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

public class Cat extends Animal {
    public void meow() {
        System.out.println("Cat is meowing");
    }
}

// Использование класса Cat
Cat cat = new Cat();
cat.eat(); // Выводит "Animal is eating"
cat.meow(); // Выводит "Cat is meowing"
```
Класс Cat наследует метод eat() от класса Animal, и также имеет собственный метод meow().

Также можно использовать ключевое слово super для обращения к родительскому классу. Например, если мы хотим передать параметр конструктора класса Cat в конструктор класса Animal, код может выглядеть так:
```java
public class Animal {
    private String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    public void eat() {
        System.out.println(name + " is eating");
    }
}

public class Cat extends Animal {
    public Cat(String name) {
        super(name);
    }
    
    public void meow() {
        System.out.println("Cat is meowing");
    }
}

// Использование класса Cat
Cat cat = new Cat("Whiskers");
cat.eat(); // Выводит "Whiskers is eating"
cat.meow(); // Выводит "Cat is meowing"
```

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 25. `Дайте определение принципа полиморфизма в ООП? Как работает полиморфизм?`

Принцип полиморфизма в ООП (объектно-ориентированном программировании) предполагает использование одного и того же имени метода или свойства для объектов разных классов. Иными словами, полиморфизм позволяет обращаться к объектам разных классов с помощью одних и тех же методов или свойств.

Работа полиморфизма основывается на наследовании и переопределении методов в наследниках. Когда мы создаем новый класс, наследующий свойства и методы от родительского класса, мы можем переопределить некоторые методы в наследнике. Таким образом, если у нас есть переменная с типом родительского класса, то ее можно использовать для хранения экземпляра любого из наследников этого класса. При вызове метода через эту переменную будет вызываться метод из соответствующего наследника.


Еще один способ реализации полиморфизма - это использование интерфейсов. Интерфейс определяет набор методов, которые должны быть реализованы всеми классами, которые реализуют этот интерфейс. Это позволяет использовать объекты разных классов, которые реализуют один и тот же интерфейс, как если бы это были объекты одного класса.

Пример использования полиморфизма в Java:
```java
public class Animal {
   public void makeSound() {
      System.out.println("Animal is making a sound");
   }
}

public class Dog extends Animal {
   public void makeSound() {
      System.out.println("Dog is barking");
   }
}

public class Cat extends Animal {
   public void makeSound() {
      System.out.println("Cat is meowing");
   }
}

public class Main {
   public static void main(String[] args) {
      Animal animal1 = new Dog();
      Animal animal2 = new Cat();
      animal1.makeSound();
      animal2.makeSound();
   }
}
```
Этот код использует наследование и переопределение методов для реализации полиморфизма. Объекты animal1 и animal2 имеют тип Animal, но на самом деле являются объектами производных классов Dog и Cat соответственно.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 26. `Что такое статический и динамический полиморфизм?`

Статический и динамический полиморфизм - это два типа полиморфизма в объектно-ориентированном программировании.

`Статический полиморфизм` - это механизм, при котором выбор вызываемой функции происходит на этапе компиляции, основываясь на типах аргументов. Это означает, что функция будет вызвана согласно своей сигнатуре без учета того, какой объект на самом деле находится за ссылкой. Примерами статического полиморфизма могут служить перегрузка функций и шаблоны функций.

`Динамический полиморфизм` - это механизм, при котором выбор вызываемой функции происходит во время выполнения программы, основываясь на реальном типе объекта находящегося за ссылкой. Это означает, что функция будет вызвана согласно типу объекта, который находится за ссылкой. Примерами динамического полиморфизма могут служить виртуальные функции и наследование классов.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 27. `Дайте определение принципу абстракции в ООП.`
Принцип абстракции в объектно-ориентированном программировании означает, что объекты должны быть спроектированы таким образом, чтобы они представляли собой абстрактные концептуальные модели реальных объектов и процессов, которые могут взаимодействовать друг с другом. Он подразумевает, что каждый объект имеет свои собственные свойства и функциональность, которые могут быть использованы другими объектами без необходимости знать, как эта функциональность была реализована.

Другими словами, принцип абстракции означает, что детали реализации объектов должны быть скрыты от других объектов, которые используют эти объекты, и доступны только через интерфейсы. Это позволяет создавать более гибкие, расширяемые и переносимые системы, которые могут изменяться без влияния на остальную часть программы.

Принцип абстракции является одним из основных принципов ООП и обеспечивает более высокий уровень абстракции в программировании.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 28. `Какие элементы речи отвечают за инкапсуляцию?`

Элементы речи, отвечающие за инкапсуляцию в объектно-ориентированном программировании - это классы и методы.

`Классы` - это основные единицы инкапсуляции в ООП. Класс определяет состояние и поведение объектов. Состояние объекта представляет собой набор свойств или переменных, которые хранят данные объекта. Поведение объекта определяется набором методов, которые могут изменять состояние объекта и выполнять операции с данными.

`Методы` - это функции, определенные внутри класса, которые предоставляют интерфейс для работы с объектом. Методы обычно работают с закрытыми (private) свойствами объекта и скрывают детали реализации объекта от внешнего мира. Это позволяет изменять реализацию объекта без изменения кода, который использует этот объект.

Таким образом, классы и методы служат основными элементами инкапсуляции в ООП, обеспечивая защиту данных объекта и поддерживая его целостность.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 29. `Какие элементы речи отвечают за подражание?`
В языке Java элементы речи не отвечают за подражание. Элементы речи используются для определения синтаксиса и логической структуры программы. Однако, в некоторых языках программирования, например, Python, имеются такие элементы, как декораторы, которые могут использоваться для подражания или изменения поведения уже существующих функций или классов.


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 30. `Какие элементы языка отвечают за полиморфизм?`

В языке Java полиморфизм реализуется с помощью элементов объектно-ориентированного программирования, таких как классы, интерфейсы, абстрактные классы и методы.

В частности, полиморфизм в Java может быть достигнут через использование следующих элементов:

+ `Наследование`: классы могут наследовать свойства и методы других классов, что позволяет им использовать их функциональность. При этом дочерний класс может переопределять методы родительского класса для более точной настройки поведения.
+ `Интерфейсы`: интерфейсы определяют набор методов, которые должны быть реализованы в любом классе, который реализует интерфейс. Это позволяет создавать общие контракты для классов, которые могут использоваться в общем коде.
+ `Абстрактные классы`: абстрактные классы похожи на интерфейсы, за исключением того, что они могут содержать реализацию методов. Классы, которые наследуются от абстрактных классов, должны реализовывать все абстрактные методы, а также могут использовать реализацию, предоставленную абстрактным классом.
+ `Полиморфные методы`: методы могут быть переопределены в дочерних классах, что позволяет им использовать свою собственную реализацию метода вместо реализации родительского класса. Это обеспечивает возможность более точной настройки поведения в зависимости от конкретного класса объекта.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 31. `Что такое SOLID? Приведите примеры.`

SOLID - это аббревиатура, используемая для описания пяти основных принципов объектно-ориентированного программирования (ООП), которые помогают разработчикам создавать более поддерживаемый и расширяемый код.

+ `Принцип единственной ответственности (Single Responsibility Principle, SRP)` - класс должен иметь только одну ответственность. Например, класс, отвечающий за работу с базой данных, не должен также заниматься обработкой пользовательского ввода или выводом на экран.
+ `Принцип открытости/закрытости (Open/Closed Principle, OCP)` - классы должны быть открыты для расширения, но закрыты для модификации. Это означает, что новый функционал должен добавляться через добавление новых классов или методов, а не изменение существующих.
+ `Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)` - объекты одного класса могут быть заменены объектами другого класса, производного от него, не нарушая работоспособность программы. Например, класс "фрукт" может быть заменен производными классами "яблоко", "груша", "апельсин" и т. д.
+ `Принцип разделения интерфейса (Interface Segregation Principle, ISP)` - клиенты не должны зависеть от интерфейсов, которые они не используют. Интерфейсы должны быть маленькими и специфическими для конкретных задач.
+ `Принцип инверсии зависимостей (Dependency Inversion Principle, DIP)` - модули верхнего уровня не должны зависеть от модулей нижнего уровня. Их зависимости должны быть инвертированы через абстракции. Например, класс, который использует базу данных, должен зависеть от абстрактного интерфейса базы данных, а не от конкретной реализации базы данных.

Примеры применения этих принципов:

+ `SRP`: класс UserService отвечает только за работу с пользователями, а не занимается другими функциями, такими как работа с базой данных или обработка ввода/вывода.
+ `OCP`: вместо изменения класса UserService при добавлении новой функциональности связанной с пользователями, создается новый класс, например, UserPermissionsService.
+ `LSP`: производный класс Apple является полноценной заменой базового класса Fruit. Таким образом, метод, который ожидает объект типа Fruit, может использовать объект типа Apple без изменения своей работы.
+ `ISP`: интерфейс UserService содержит только методы, относящиеся к пользователям. Таким образом, клиентский код, который использует UserService, не зависит от других, неиспользуемых интерфейсов.
+ `DIP`: класс UserService зависит от абстрактного интерфейса UserDatabase, а не от конкретной реализации базы данных. Это позволяет легко заменять одну реализацию базы данных на другую без изменения UserService.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 32. `Что такое перегрузка (overloading) метода?`

`Перегрузка метода (method overloading)` в Java - это возможность определения нескольких методов с одним и тем же именем, но с разными параметрами. Компилятор определяет, какой из перегруженных методов нужно вызвать на основе типов аргументов, переданных в вызове.

При определении перегруженных методов важно учитывать следующие правила:

+ Имена методов должны быть одинаковыми.
+ Число и тип параметров должны отличаться.
+ Тип возвращаемого значения может отличаться, но это не является обязательным условием.

Например, рассмотрим следующий код для класса Calculator:
```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }
}
```
В этом примере мы определили два метода add с одним и тем же именем, но с разными параметрами. Первый метод принимает два целых числа и возвращает их сумму, второй метод принимает два числа с плавающей точкой и также возвращает их сумму.

При вызове метода add компилятор будет определять, какой метод нужно использовать, основываясь на типах аргументов. Например, если мы вызываем метод add с двумя целыми числами:
```java
Calculator calc = new Calculator();
int sum = calc.add(2, 3);
```
то будет использован первый метод, который принимает два целых числа и возвращает целое число.

Если бы мы вызывали метод add с двумя числами с плавающей точкой:
```java
Calculator calc = new Calculator();
double sum = calc.add(2.5, 3.7);
```
то был бы использован второй метод, который принимает два числа с плавающей точкой и возвращает число с плавающей точкой.

Перегрузка метода позволяет программистам создавать более гибкий и удобный интерфейс для работы с классом, позволяя использовать одно имя метода для различных операций с разными типами данных.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 33. `Что такое переопределение (override) метода?`

`Переопределение метода (method overriding)` в Java - это возможность заменить реализацию метода из базового класса (или интерфейса), который уже определен в производном классе, с тем же именем, списком аргументов и типом возвращаемого значения. Переопределение метода позволяет производному классу изменять поведение унаследованного метода без необходимости изменять его имя или сигнатуру.

Для успешного переопределения метода нужно учитывать следующие правила:

Имя метода, список аргументов и тип возвращаемого значения должны быть точно такими же, как у метода в базовом классе (или интерфейсе).
Модификаторы доступа для переопределяемого метода должны быть такими же или менее строгими, чем в базовом классе (или интерфейсе). Например, если метод в базовом классе имеет модификатор доступа "public", то метод в производном классе может иметь такой же модификатор или более ограничивающий модификатор доступа, например, "protected" или "package-private".
Тип возвращаемого значения должен быть совместим с типом, указанным в базовом классе (или интерфейсе). Например, если метод в базовом классе возвращает объект типа Animal, то метод в производном классе должен также возвращать объект типа Animal или его производный класс.
Например, рассмотрим следующий код для классов Animal и Cat:
```java
public class Animal {
    public void makeSound() {
        System.out.println("Animal is making a sound");
    }
}

public class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Meow!");
    }
}
```
В этом примере мы переопределили метод makeSound из базового класса Animal в классе Cat. Метод makeSound в классе Animal выводит сообщение "Animal is making a sound", а метод makeSound в классе Cat выводит сообщение "Meow!".

При вызове метода makeSound для экземпляра класса Cat будет использована переопределенная реализация метода, а не реализация из базового класса. Например, если мы создаем экземпляр класса Cat и вызываем его метод makeSound:
```java
Cat cat = new Cat();
cat.makeSound();
```
то на консоль будет выведено сообщение "Meow!".

Переопределение метода позволяет производным классам изменять поведение унаследованных методов и адаптироваться к своим потребностям. Однако при переопределении методов нужно учитывать правила, чтобы избежать ошибок и неожиданного поведения программы.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 34. `Что такое класс, объект, интерфейс?`
`Класс` - это шаблон, определяющий состояние и поведение объектов. Он содержит переменные экземпляра (состояние) и методы (поведение), которые определяют, что объекты могут делать.

`Объект` - это экземпляр класса. Когда вы создаете объект, он получает свою собственную копию переменных экземпляра класса. Вы можете вызывать методы класса на этом объекте, чтобы изменить его состояние или получить информацию из него.

`Интерфейс` - это контракт, который гарантирует, что класс, который реализует интерфейс, будет иметь определенные методы. Он определяет только имена методов, а не их реализацию. Класс должен реализовать все методы интерфейса, чтобы соответствовать контракту.

В Java вы можете использовать классы для определения объектов, интерфейсы для создания контрактов и объекты для выполнения кода, определенного в классах и интерфейсах.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 35. `Что такое класс POJO? Приведите пример такого класса.`

`Класс POJO` - это простой Java-класс, который не зависит от каких-либо фреймворков или библиотек и следует определенным правилам. POJO означает "Plain Old Java Object" (Простой старый Java-объект) и используется для передачи данных между различными слоями приложения.

Правила для POJO класса включают в себя:

+ Класс должен быть public и иметь пустой конструктор.
+ Переменные экземпляра класса должны быть private и иметь геттеры и сеттеры для доступа к ним.
+ Должны быть реализованы методы toString(), equals() и hashCode().
+ Класс не должен реализовывать никаких интерфейсов или наследоваться от других классов, которые не являются также POJO.


Вот пример POJO класса в Java для представления пользователя:

```java
public class User {
    private Long id;
    private String name;
    private int age;
    
    public User() {}
    
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
    
    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return age == user.age && Objects.equals(id, user.id) && Objects.equals(name, user.name);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(id, name, age);
    }
}
```
Обратите внимание, что переменные класса private и имеют геттеры и сеттеры для доступа к ним. Также класс имеет пустой конструктор, методы toString(), equals() и hashCode(). Класс также не наследуется от других классов или не реализует интерфейсы, которые не являются POJO.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 36. `Какие элементы могут содержать класс?`
Класс в Java может содержать следующие элементы:

+ `Переменные класса (fields)` - это переменные, определенные внутри класса, которые используются для хранения данных. Они могут быть объявлены с модификатором доступа public, private, protected или без модификатора доступа.
+ `Конструкторы (constructors)` - это специальные методы, которые используются для создания объектов класса. Они имеют тот же идентификатор, что и имя класса и могут принимать аргументы.
+ `Методы (methods)` - это функции, определенные внутри класса, которые могут выполнять различные действия. Они также могут принимать аргументы и возвращать значения.
+ `Вложенные классы (nested classes)` - это классы, определенные внутри других классов. Они могут быть объявлены как static или неstatic и могут использоваться для организации кода и управления доступом к данным.
+ `Интерфейсы (interfaces)` - это абстрактные классы, определяющие набор методов, которые должны быть реализованы классами, которые реализуют данный интерфейс.
+ `Перечисления (enumerations)` - это специальный тип классов, который позволяет определять константы, которые могут быть использованы в качестве значений переменных.
+ `Аннотации (annotations)` - это специальные маркеры или описания, которые могут быть добавлены к классам, методам и переменным для предоставления дополнительной информации для компилятора или других инструментов.
+ `Статические блоки инициализации (static initialization blocks)` - это блоки кода, которые выполняются, когда класс загружается в память. Они могут быть использованы для инициализации статических переменных.

В целом, классы в Java используются для определения объектов, которые могут хранить данные и выполнять действия в программе. Они являются основными строительными блоками для создания приложений на Java.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 37. `Дайте определение объекта?`
`Объект` - это экземпляр класса в объектно-ориентированном программировании (ООП). Он содержит данные и методы, которые могут использоваться для выполнения определенных задач. Например, класс "Автомобиль" может быть использован для создания объектов-автомобилей с разными характеристиками, такими как цвет, скорость и количество мест. Каждый объект-автомобиль будет иметь свои уникальные значения этих характеристик. Объекты позволяют организовать код в модули, которые могут быть легко переиспользованы и расширены.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 38. `Расскажите о подражании Java. Каковы особенности использования ключевого слова super?`

`Подражание (наследование)` — это механизм, позволяющий создавать новый класс на основе существующего, заимствуя его свойства и методы. В Java подражание реализуется с помощью ключевого слова "extends".

Например, если у нас есть класс "Фрукт", мы можем создать другой класс, который наследует свойства и методы класса "Фрукт". Например:
```java
class Apple extends Fruit {
  // ...
}
```
В этом примере класс "Apple" будет иметь все свойства и методы класса "Fruit". Мы также можем переопределить методы класса "Fruit" в классе "Apple", чтобы изменить или расширить их функциональность.

Особенностью использования ключевого слова "super" является то, что оно позволяет обращаться к методам и свойствам родительского класса из дочернего класса. Например, если мы переопределяем метод "toString()" в классе "Apple", но хотим сохранить функциональность метода "toString()" родительского класса, мы можем использовать ключевое слово "super":
```java
class Apple extends Fruit {
  @Override
  public String toString() {
    return super.toString() + ", type: Apple";
  }
}
```
Здесь метод "toString()" класса "Apple" вызывает метод "toString()" класса "Fruit" с помощью "super.toString()", а затем добавляет строку ", type: Apple". Таким образом, мы сохраняем функциональность метода "toString()" родительского класса и расширяем ее в классе "Apple".

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 39. `Что такое сигнатура метода? Приведите примеры правильных и неправильных сигнатур.`

`Сигнатура метода` - это уникальная строка, которая описывает типы и порядок аргументов, а также возвращаемый тип метода. Сигнатура используется компилятором Java для различения методов с одинаковым именем, но отличающихся по своим параметрам.

Пример правильной сигнатуры метода:

```java
public int addNumbers(int a, int b) {
    return a + b;
}
```
В этом примере addNumbers - имя метода, int - возвращаемый тип, a и b - типы и порядок параметров. Сигнатура метода будет выглядеть следующим образом:
```java
addNumbers(int, int) -> int
```
Пример неправильной сигнатуры метода:

```java
public String addNumbers(int a, float b) {
    return "Result: " + (a + b);
}
```
В этом примере мы изменили тип второго параметра на float. Сигнатура метода будет выглядеть следующим образом:
```java
addNumbers(int, float) -> String
```
Эта сигнатура отличается от первой, что значит, что это уже другой метод с тем же именем addNumbers.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 40. `Можно ли в конструкторе использовать return?`

В Java конструкторы обычно не возвращают значения, так как они создают новый объект и заполняют его поля. Если вы попытаетесь использовать оператор return в конструкторе, компилятор выдаст ошибку.

Однако, есть две ситуации, когда можно использовать оператор return в конструкторе:

+ В конструкторе класса-наследника, если он вызывает конструктор родительского класса с помощью ключевого слова super и передает ему аргументы, то после этого может использовать оператор return. Например:
```java
public class ChildClass extends ParentClass {
    public ChildClass(int arg) {
        super(arg);
        // дальнейшие инструкции
        return;
    }
}
```
+ В конструкторе для инициализации статических полей, например:
```java
public class MyClass {
    private static int x;
    static {
        x = 10;
        return;
    }
}
```
Но в целом, использование оператора return в конструкторе нежелательно, так как это может привести к непредсказуемому поведению вашего кода.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 41. `Можно ли в конструкторе выполнить исключение (exception)?`

Да, в конструкторе можно сгенерировать исключение (exception). Если при создании объекта возникает ошибка, которая не может быть обработана внутри конструктора, то можно выбросить исключение, чтобы сообщить об ошибке вызывающему коду.

Для выбрасывания исключения из конструктора можно использовать ключевое слово throw, за которым следует экземпляр класса исключения. Например:
```java
public class MyClass {
    public MyClass(int value) throws IllegalArgumentException {
        if (value < 0) {
            throw new IllegalArgumentException("Значение не может быть отрицательным");
        }
        // дальнейшие инструкции
    }
}
```
В этом примере мы проверяем передаваемый аргумент на отрицательность и если он отрицательный, выбрасываем исключение IllegalArgumentException с указанным текстом ошибки.

Также, как и в других методах, в конструкторе можно указать с помощью ключевого слова throws, какие исключения могут быть выброшены из конструктора.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 42. `Из каких элементов состоит название класса? Напишите пример.`

Название класса в Java состоит из идентификатора, который может содержать символы латинского алфавита (a-z, A-Z), цифры (0-9) и знак $. Название класса должно начинаться с буквы верхнего или нижнего регистра.

Примеры правильных названий классов:
```java
public class MyClass {
    // тело класса
}

class MyOtherClass {
    // тело класса
}

public class MyExampleClass$InnerClass {
    // тело вложенного класса
}
```
Примеры неправильных названий классов:
```java
public class 123Class { // использование цифр в начале названия
    // тело класса
}

class my-bad-class { // использование дефиса в названии
    // тело класса
}

public class Bad Class { // использование пробела в названии
    // тело класса
}
```
Важно придерживаться этих правил, чтобы ваш код был понятным и легко читаемым.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 43. `Из каких элементов состоит название метода? Напишите пример.`
В языке программирования Java название метода обычно состоит из имени метода и списка его параметров. Например, рассмотрим следующий метод:

```java
public int sum(int a, int b) {
    return a + b;
}
```

Этот метод называется "sum", что указывает на его назначение - вычисление суммы двух целых чисел. В скобках после имени метода перечислены его параметры: "int a" и "int b". Эти параметры определяют тип данных, которые принимает метод для обработки. В данном случае метод "sum" принимает два целых числа и возвращает их сумму также в виде целого числа. Таким образом, название метода "sum" включает в себя информацию о его назначении и используемых параметрах.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 44. `Создайте в объекте-наследнике конструктор по умолчанию, если в базовом классе он не определен (но определен другой конструктор).`

Если в базовом классе определен конструктор, то конструктор по умолчанию создается автоматически. Однако, если базовый класс не имеет конструктора по умолчанию и в нем определен другой конструктор, то в объекте-наследнике можно создать конструктор по умолчанию с помощью ключевого слова super.

Вот пример такого конструктора:

```java
public class MyBaseClass {
    private int value;
    
    public MyBaseClass(int value) {
        this.value = value;
    }
    
    public int getValue() {
        return value;
    }
}

public class MyDerivedClass extends MyBaseClass {
    public MyDerivedClass() {
        super(0);
    }
}
```
Здесь класс MyBaseClass имеет только один конструктор, который принимает целочисленный параметр. В классе MyDerivedClass определен конструктор по умолчанию, который вызывает конструктор базового класса с помощью super(0). Конструктор класса MyDerivedClass создает объект MyDerivedClass со значением value, равным 0.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 45. `Когда используется ключевое слово this?`
В Java ключевое слово "this" используется для ссылки на текущий объект внутри класса.

Конкретно, это может быть использовано в следующих случаях:

+ Для ссылки на переменные экземпляра класса, чтобы различать их от локальных переменных или параметров метода, имеющих тот же самый идентификатор.
+ Для вызова другого конструктора в текущем классе (с помощью ключевого слова this), что позволяет избежать дублирования кода и повторения инициализации полей.
+ Для передачи ссылки на текущий объект другому методу или конструктору в качестве аргумента.
Например, в следующем фрагменте кода мы используем ключевое слово "this", чтобы получить доступ к переменной экземпляра "name":
```java
public class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    public void printName() {
        System.out.println("My name is " + this.name);
    }
}
```
Здесь мы можем использовать "this.name" вместо просто "name", чтобы указать, что мы обращаемся к переменной экземпляра класса "Person", а не к параметру конструктора "name".

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 46. `Что такое инициализатор?`
В Java `инициализатор` - это блок кода внутри класса, который выполняется при создании объекта класса.

Программист может добавить инициализаторы в свой класс, чтобы выполнить некоторые действия перед тем, как объект будет использоваться. Это может быть полезно, например, для инициализации переменных экземпляра, создания новых объектов или установки начального состояния.

Существует два типа инициализаторов в Java:

+ `Статический (static) инициализатор` - это блок кода, который выполняется при первой загрузке класса в память JVM. Он используется для инициализации статических переменных класса. Статический инициализатор можно определить с помощью ключевого слова "static" перед блоком кода:
```java
public class MyClass {
    static {
        // static initialization code here
    }
}
```

+ `Нестатический (instance) инициализатор` - это блок кода, который выполняется каждый раз при создании нового объекта класса. Он используется для инициализации переменных экземпляра класса. Нестатический инициализатор можно определить без ключевого слова "static":
```java
public class MyClass {
    {
        // instance initialization code here
    }
}
```
Например, следующий код содержит оба типа инициализаторов:
```java
public class MyClass {
    static int staticVar;
    int instanceVar;

    static {
        // static initialization code here
        staticVar = 10;
    }

    {
        // instance initialization code here
        instanceVar = 20;
    }
}
```
Здесь статический инициализатор устанавливает значение статической переменной "staticVar" в 10, а нестатический инициализатор устанавливает значение переменной экземпляра "instanceVar" в 20 при каждом создании объекта класса.


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 47. `Для наследования класса public class Child extends Parent напишите порядок инициализации объекта.`

Порядок инициализации объекта при наследовании класса в Java следующий:

+ Статические поля класса Parent инициализируются в порядке их объявления и вызова статических блоков кода.
+ Статические поля класса Child инициализируются аналогично - в порядке объявления и вызова статических блоков, если они есть.
+ Создается объект класса Parent.
+ Конструктор класса Parent выполняется и инициализирует его поля.
+ Создается объект класса Child.
+ Конструктор класса Child выполняется и инициализирует его поля.

Более точно, порядок инициализации объекта выглядит следующим образом:
```
1. Выполнение статического блока кода класса Parent, если такой есть.
2. Выполнение статического блока кода класса Child, если такой есть.
3. Вызов конструктора класса Parent.
4. Инициализация полей класса Parent.
5. Вызов конструктора класса Child.
6. Инициализация полей класса Child.
```
Важно помнить, что конструкторы вызываются только для создания новых экземпляров объектов, а статические блоки кода - при первом обращении к классу (или при загрузке класса в память JVM). Кроме того, при наследовании класса конструкторы инициализируются сначала в родительском классе, а потом в дочернем.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 48. `Какие ассоциативные связи между объектами вы знаете?`

В объектно-ориентированном программировании существует несколько видов ассоциативных связей между объектами. Некоторые из них:

+ `Агрегация` - это отношение целое-часть, где один объект является "контейнером" для другого объекта, и включает его в свой состав. Объекты могут существовать независимо друг от друга.
+ `Композиция` - это также отношение целое-часть, но здесь объекты жестко связаны друг с другом, при этом родительский объект создает и управляет жизненным циклом дочернего объекта. Если родительский объект уничтожается, то дочерний объект также уничтожается.
+ `Ассоциация` - это обобщенное отношение между двумя объектами, которые могут взаимодействовать друг с другом. Один объект может иметь ссылку на другой объект, но это не означает, что они являются частями друг друга или зависят друг от друга.
+ `Наследование` - это отношение, при котором класс наследует свойства и методы другого класса (родительского класса). Это позволяет создавать более специализированные версии классов на основе базовых классов.
+ `Реализация` - это отношение, при котором класс реализует (или выполняет) методы интерфейса. Это позволяет использовать объекты различных классов с единым интерфейсом.

Кроме того, в рамках ассоциативных связей могут использоваться и другие термины, такие как "зависимость", "агрегация с разделением", "ассоциация с квалификацией" и т.д. Однако вышеперечисленные виды связей - наиболее распространенные и широко используемые в объектно-ориентированном программировании.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 49. `Что такое модификаторы доступа в Java? Назовите их. Для чего используются?`
`Модификаторы доступа` в Java - это ключевые слова, которые определяют уровень доступа к классам, переменным и методам.

Существует четыре модификатора доступа в Java:

+ `Private` - ограничивает доступ к членам класса только внутри самого класса. Другие классы не могут получить доступ к приватным членам.
+ `Protected` - предоставляет доступ к членам класса внутри самого класса, а также дочерним классам. Члены с модификатором protected также могут быть доступны и для классов из того же пакета.
+ `Package-private (также называемый default)` - ограничивает доступ к членам класса только внутри того же пакета. Это является наиболее ограничительным уровнем доступа в Java.
+ `Public` - предоставляет доступ к членам класса из любого места программы, включая другие классы и пакеты.

Модификаторы доступа используются для обеспечения безопасности и контроля доступа к классам, переменным и методам. Они также помогают избежать ошибок и конфликтов имён при использовании одного и того же имени для разных классов или переменных в разных частях программы. Также модификаторы доступа дают возможность скрыть детали реализации класса от других частей программы, что позволяет более гибко управлять кодом и изменять его при необходимости.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 50. `Назовите основную особенность статических переменных и методов.`
Основной особенностью статических переменных и методов в Java является то, что они принадлежат классу, а не конкретному объекту класса. Это означает, что все объекты этого класса будут использовать одно и то же значение для статических переменных и методов.

Конкретно, статические переменные используются для хранения общей информации, которая доступна всем объектам класса, независимо от их состояния. Статические методы используются для выполнения действий, которые не зависят от состояния объектов, например, для обработки данных или выполнения служебных задач, связанных с классом.

Ещё одной особенностью статических методов и переменных является то, что они могут быть вызваны без создания экземпляра класса. Доступ к статическим элементам класса можно получить через имя класса, например, MyClass.staticVar или MyClass.staticMethod(). Это удобно при работе с классами утилитами, когда не требуется создание новых объектов, а нужно только использовать методы и переменные класса.

Важно помнить, что из-за того, что статические переменные и методы принадлежат классу, они имеют общее состояние и могут использоваться в многопоточной среде с осторожностью. Неправильное использование статических переменных и методов может привести к неожиданному поведению программы и ошибкам выполнения.


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 51. `Какие основные ограничения действуют на статические переменные и методы?`

В Java статические переменные и методы имеют некоторые ограничения, которые важно учитывать при использовании этого механизма:

+ Нельзя обращаться к нестатическим (инстанс) переменным и методам из статических методов или блоков кода. Так как статический метод принадлежит классу, он может использовать только другие статические переменные и методы, а не инстанс переменные и методы, которые относятся к конкретному объекту класса.
+ Статические переменные и методы наследуются дочерними классами, но не переопределяются. Это значит, что если дочерний класс определяет свою статическую переменную или метод с тем же именем, что и в родительском классе, то эта переменная или метод будет скрытой версией родительской.
+ Статические переменные и методы находятся в общем доступе для всех экземпляров данного класса и для всех классов, которые имеют доступ к данному классу. Это может привести к конфликту имён, если два разных класса имеют одноимённую статическую переменную или метод.
+ Статические переменные и методы могут использоваться без создания объекта класса, что означает, что эти переменные и методы всегда будут иметь общее состояние для всех объектов данного класса.
+ Из-за общего состояния статических переменных и методов рекомендуется использовать их только в тех случаях, когда это необходимо, и с осторожностью при работе с многопоточностью.
+ Нельзя переопределить статический метод в дочернем классе, но можно создать метод с таким же именем в дочернем классе, который будет скрывать родительский статический метод.
+ Статические переменные и методы доступны из любого места программы, поэтому следует быть осторожным при работе со статическими переменными и методами и устанавливать правильные модификаторы доступа, чтобы обеспечить безопасность программы.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 52. `Что означает ключевое слово? Может ли статический метод быть переопределенным или перегруженным?`

Ключевые слова в языке программирования используются для указания определенной семантики, свойств и функций. Ключевое слово является зарезервированным словом, которое имеет специальный смысл в контексте языка программирования, и не может использоваться как имя переменной, класса, метода или другого символа.

Относительно статических методов, в Java они могут быть только перегружены, но не переопределены. При наследовании класса дочерний класс может создать метод со своим же именем, что и статический метод родительского класса с тем же именем, чтобы объединить его принципиально новой реализацией. Эта возможность расширения статического поведения называется перегрузкой методов.

Статические методы не могут быть переопределены, потому что они относятся к классу, а не объекту. В Java концепция переопределения методов подразумевает замену реализации метода в дочернем классе на реализацию из родительского класса, при условии, что метод имеет одинаковый набор параметров. Но поскольку статические методы принадлежат классу, а не экземпляру класса, то переопределение не имеет смысла.

Однако статические методы могут быть перегружены, то есть класс-наследник может определить свой собственный статический метод с тем же именем, но другими параметрами. При вызове метода для каждого типа параметров будет выбран соответствующий перегруженный метод.

Итак, можно сказать, что статические методы в Java могут быть только перегружены, но не переопределены.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 53. `Может ли быть метод статическим и абстрактным одновременно?`

Да, в Java метод может быть как статическим, так и абстрактным одновременно. Однако этот метод должен быть определен в абстрактном классе.

`Абстрактный класс` - это класс, который не может быть создан непосредственно, то есть он не может иметь объектов. Он используется для определения общих свойств и методов для группы подклассов. `Абстрактные методы` - это методы, которые объявляются без реализации, они используются для определения сигнатуры метода и типов возвращаемых значений, но не могут содержать тело метода.

`Статический метод` - это метод класса, поэтому он может быть вызван без создания экземпляра класса. Но также статический метод может быть использован с объектом класса.

Поэтому, если вы определяете статический метод в абстрактном классе, то этот метод будет доступен для всех подклассов, а также может быть использован без создания экземпляра любого объекта этого класса. Если этот метод объявлен абстрактным, то каждый подкласс должен реализовать его самостоятельно, независимо от того, является ли указанный метод статическим или нет.

Таким образом, метод может быть как статическим, так и абстрактным одновременно в контексте абстрактного класса.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 54. `Можно ли использовать статические методы внутри обычных? Напротив? Почему?`

Да, в Java можно использовать статические методы внутри обычных методов. Кроме того, обычные методы могут быть вызваны из статических методов, но только если они принадлежат к экземпляру класса.

Статические методы могут быть использованы внутри обычных методов без каких-либо проблем. Это может быть полезно, когда вы хотите использовать общую функциональность или константы в нескольких методах класса. Вы можете определить статический метод, который решает общую задачу и затем вызывать его из разных методов класса.

Однако, если вы пытаетесь вызвать обычный метод из статического метода, это возможно только в случае, если вы создали экземпляр класса, а затем вызываете метод этого экземпляра. Статический метод не имеет доступа к объекту, поэтому он не может вызвать обычный метод, который требует доступа к полям или методам объекта.

В целом, использование статических методов внутри обычных методов является распространенной практикой в Java, но следует помнить, что статические методы могут иметь побочные эффекты на глобальные переменные и могут быть более сложными в тестировании. Однако, правильно используя статические методы, можно существенно упростить код и уменьшить повторение кода.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 55. `Что означает ключевое слово final?`

В Java ключевое слово final может использоваться для определения констант, переменных, методов и классов. Константы, объявленные с помощью ключевого слова final, не могут изменять свои значения после инициализации. Переменные, объявленные с помощью ключевого слова final, могут быть инициализированы только один раз и их значение не может быть изменено после этого.

Ключевое слово final может также использоваться для определения методов, которые не могут быть переопределены подклассами. В этом случае ключевое слово final следует перед модификатором доступа и типом возвращаемого значения.

Ключевое слово final также может использоваться для определения классов, которые не могут быть наследованы. Если класс объявлен как final, то его методы автоматически становятся final, и их переопределение невозможно.

Некоторые примеры:

+ `Константа`:

```java
final int MAX_VALUE = 100;
```
+ `Переменная`:

```java
final String name = "John";
```
+ `Метод`:

```java
public final void printMessage() {
    System.out.println("Hello, world!");
}
```
+ `Класс`:

```java
public final class MyFinalClass {
    // implementation code
}
```
Использование ключевого слова final позволяет создавать более безопасный и надежный код, который легче поддерживать и тестировать. например, если переменная объявлена как final, то она не может быть случайно изменена в другой части программы, что упрощает отладку и обеспечивает более стабильную работу приложения.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 56. `Что такое abstract? Абстрактный класс? aбстрактный метод?`
Ключевое слово "abstract" в Java используется для определения абстрактных классов и абстрактных методов.

`Абстрактный класс` - это класс, который не может быть создан непосредственно экземпляром. Он служит только для описания интерфейса для классов-наследников. Абстрактный класс содержит хотя бы один абстрактный метод (метод без тела), который должен быть реализован в каждом классе-наследнике. Абстрактные классы могут также содержать обычные методы с конкретной реализацией.

`Абстрактный метод` - это метод, который объявлен, но не реализован в абстрактном классе. Он не имеет тела и используется для определения сигнатуры метода и типа возвращаемого значения. Это означает, что любой класс, который наследует абстрактный класс, должен реализовать все его абстрактные методы, предоставляя свою собственную реализацию.

Пример абстрактного класса:

```java
public abstract class Animal {
    public abstract void makeSound();
    public void eat() {
        System.out.println("I am eating");
    }
}
```
В этом примере класс Animal объявлен как абстрактный, потому что он содержит абстрактный метод makeSound(). Этот метод должен быть реализован в каждом конкретном классе наследнике. Метод eat() является обычным методом, который имеет конкретную реализацию и не требует переопределения.

Абстрактные классы используются для создания общего интерфейса или шаблона для группы связанных классов, но не могут существовать как самостоятельные объекты. Они предоставляют удобный способ определения основных методов и свойств, которые должны присутствовать во всех классах-наследниках. Абстрактные классы позволяют разработчикам избежать дублирования кода и повторного использования функциональности в различных частях программы, что упрощает ее разработку и поддержку.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 57. `Что такое interface? Может быть final interface?`

В Java, `интерфейс (interface)` является типом данных, описывающим набор абстрактных методов без их реализации. Интерфейсы позволяют определить контракты для классов, которые реализуют эти интерфейсы, обеспечивая таким образом более гибкое проектирование программного обеспечения.

Нет, нельзя использовать ключевое слово final для интерфейса в Java. Ключевое слово final используется для указания, что переменная, метод или класс не может быть изменен после их определения. Таким образом, если бы мы могли использовать ключевое слово final для интерфейса, то это противоречило бы концепции интерфейсов, которые предоставляют шаблоны для реализации методов в классах, которые реализуют интерфейс.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 58. `В чем разница между абстрактным классом и интерфейсом Java?`

Абстрактный класс и интерфейс являются основными концепциями для реализации полиморфизма в Java. Вот некоторые ключевые отличия между абстрактным классом и интерфейсом:

+ `Реализация методов`: Абстрактные классы могут содержать как абстрактные, так и конкретные методы, тогда как интерфейсы могут содержать только абстрактные методы (без реализации). Также, начиная с версии Java 8, интерфейсы могут иметь реализацию методов по умолчанию (default methods).
+ `Наследование`: Класс может наследоваться только от одного абстрактного класса, но он может реализовывать несколько интерфейсов.
+ `Использование`: Абстрактные классы обычно используются там, где у нас есть общие атрибуты и поведение для группы классов, а интерфейсы используются там, где мы хотим обеспечить общую функциональность для разных классов без привязки к их иерархии наследования.
+ `Наличие конструктора`: Абстрактные классы могут иметь конструкторы, тогда как интерфейсы не могут иметь конструкторов.
+ `Модификаторы доступа`: Абстрактные классы могут иметь модификаторы доступа (public, protected, private и default), тогда как методы интерфейса по умолчанию являются public, а переменные интерфейса - public static final.

Общим для абстрактных классов и интерфейсов является то, что они используются для определения общих свойств и методов, которые могут быть использованы во многих классах и подклассах.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 59. `Где можно инициализировать статические поля?`

Статические поля в Java могут быть инициализированы в различных местах, например:

+ `Прямо при объявлении`: статическое поле может быть объявлено и проинициализировано в одной строке:
```java
public static int myInt = 10;
```
+ `В блоке статической инициализации`: статический блок инициализации - это блок кода, который выполняется только один раз, когда класс загружается в память JVM. Можно использовать этот блок для инициализации статических переменных.
```java
static {
    myInt = 20;
}
```
+ `В статическом методе`: можно также использовать статический метод для инициализации статических переменных:
```java
public static void init() {
    myInt = 30;
}
```
+ `С помощью обычного метода, вызываемого через конструктор`: такой подход менее распространен, но возможен. Например:
```java
public class MyClass {
   public static int myInt;
   
   public MyClass() {
      init();
   }
   
   public static void init() {
      myInt = 40;
   }
}
```
Важно понимать, что статические поля инициализируются только один раз при загрузке класса в память JVM и сохраняют свое значение до конца работы программы.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 60. `Что такое анонимные классы?`

`Анонимные классы` в Java - это специальный вид классов, которые не имеют явного имени и создаются непосредственно в месте использования. Они могут быть полезны для реализации интерфейсов или классов-абстракций "на лету", т.е. без необходимости определения нового класса.

Синтаксис анонимных классов представляет собой объявление класса на основе интерфейса или абстрактного класса, после которого следуют фигурные скобки с определением методов. Пример использования анонимного класса для реализации интерфейса ActionListener:
```java
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        System.out.println("Button clicked!");
    }
});
```
В этом примере мы создаем экземпляр анонимного класса, который реализует интерфейс ActionListener, и передаем его в качестве аргумента методу addActionListener(). При нажатии на кнопку будет вызван метод actionPerformed() анонимного класса, который выведет сообщение в консоль.

Анонимные классы могут быть очень удобны в некоторых случаях, но требуют осторожности при использовании из-за своей неявной природы.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 61. `Что такое примитивные классы?`

В Java `примитивные классы` - это встроенные типы данных, которые не являются объектами и имеют фиксированный размер.

Список примитивных классов включает в себя:

+ `byte`: целочисленный тип данных, который используется для хранения значений от -128 до 127.
+ `short`: целочисленный тип данных, который используется для хранения значений от -32 768 до 32 767.
+ `int`: целочисленный тип данных, который используется для хранения значений от -2 147 483 648 до 2 147 483 647.
+ `long`: целочисленный тип данных, который используется для хранения значений от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807.
+ `float`: тип данных с плавающей точкой одинарной точности, который используется для хранения действительных чисел с точностью до 6-7 знаков после запятой.
+ `double`: тип данных с плавающей точкой двойной точности, который используется для хранения действительных чисел с точностью до 15 знаков после запятой.
+ `boolean`: логический тип данных, который может принимать только значения true или false.
+ `char`: символьный тип данных, который используется для хранения одиночного символа Unicode.
Примитивные классы в Java имеют маленький размер и хранятся непосредственно в памяти, что делает их более эффективными для работы с большими объемами данных. Однако, они не поддерживают методов или свойств объекта, которые доступны в классах-объектах. Для работы с примитивными типами данных в Java есть специальные классы-обертки (wrapper classes), такие как Integer, Double, Boolean и др., которые предоставляют методы и свойства объекта для работы с примитивными значениями.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 62. `Что такое класс «обертка» (wrapper)?`

В Java `классы-обертки (wrapper classes)` - это специальные классы, которые позволяют работать с примитивными типами данных как с объектами. Такие классы представлены в стандартной библиотеке Java и используются для трансформации значений примитивных типов данных в объекты и обратно.

Список классов-оберток включает в себя:

+ `Byte`: для работы с примитивным типом byte.
+ `Short`: для работы с примитивным типом short.
+ `Integer`: для работы с примитивным типом int.
+ `Long`: для работы с примитивным типом long.
+ `Float`: для работы с примитивным типом float.
+ `Double`: для работы с примитивным типом double.
+ `Boolean`: для работы с примитивным типом boolean.
+ `Character`: для работы с примитивным типом char.

Классы-обертки обеспечивают несколько преимуществ при работе с примитивными типами данных. В частности, они предоставляют методы и свойства объекта для работы с примитивами, такие как возможность преобразования значения в строку, выполнение математических операций, а также проверка на равенство или сравнение с другими объектами. Кроме того, использование классов-оберток может быть полезно при работе с некоторыми библиотеками, которые требуют передачи параметров в виде объектов.
<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 63. `Что такое Nested class? Когда используется?`

Nested class (вложенный класс) в Java - это класс, который определен внутри другого класса. Он может быть объявлен как статический или нестатический, и может иметь различные уровни доступа (public, private, protected).

Nested class используется для группировки связанных классов вместе и облегчения доступа к ним друг другу. Вложенные классы могут использоваться для реализации сложных алгоритмов, для представления компонентов пользовательского интерфейса, для создания логически связанных классов-оберток и т.д.

В Java есть четыре типа вложенных классов:

+ `Nested Inner Class (внутренний вложенный класс)` - это нестатический вложенный класс, который определен внутри другого класса. Он имеет доступ ко всем полям и методам внешнего класса, а также может иметь свои собственные поля и методы.
+ `Static Nested Class (статический вложенный класс)` - это вложенный класс, который объявлен со словом ключевым static. Он не имеет доступа к нестатическим полям и методам внешнего класса, но может иметь собственные статические поля и методы.
+ `Local Inner Class (локальный внутренний класс)` - это вложенный класс, который определен внутри метода. Он имеет доступ к переменным и параметрам метода, а также может иметь доступ к нестатическим полям и методам внешнего класса.
+ `Anonymous Inner Class (анонимный внутренний класс)` - это класс без имени, который создается непосредственно в месте использования. Он обычно используется для реализации интерфейсов или классов-абстракций "на лету" без необходимости определения нового класса.

Nested class является мощным механизмом в Java для организации и структурирования кода, но следует использовать его с осторожностью, чтобы избежать излишней сложности и путаницы в коде.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 64. `Какие модификаторы доступа могут быть у класса?`

В Java есть три модификатора доступа, которые могут применяться к классам:

+ `public` - класс с модификатором доступа public может быть доступен из любого другого класса в любом пакете.
+ `package-private (default)` - если класс не имеет явного модификатора доступа, то он считается package-private или default. Классы с таким модификатором доступа могут быть доступны только из других классов в том же пакете.
+ `private` - класс с модификатором доступа private может быть доступен только внутри того же класса, где он был объявлен.

Модификаторы доступа управляют видимостью и доступностью класса для других классов и пакетов. Они используются для обеспечения безопасности и контроля доступа к классам и их членам.

Библиотеки и стандарты


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 65. `Что такое Hibernate? В чем разница между JPA и Hibernate?`

`Hibernate` - это фреймворк для работы с реляционными базами данных в Java. Он предоставляет объектно-ориентированный подход к работе с базами данных, что позволяет разработчикам избежать написания большого количества SQL-запросов и упрощает взаимодействие между приложениями и базой данных.

`JPA (Java Persistence API)` - это стандарт для работы с объектно-реляционным отображением (ORM) в Java. Он определяет API для работы с базами данных через ORM. JPA не является конкретной реализацией ORM, а скорее стандартизирует работу с ним.

Hibernate - одна из самых популярных реализаций JPA. Hibernate реализует спецификацию JPA и добавляет дополнительные функциональные возможности и расширения. В частности, Hibernate имеет свой язык запросов HQL (Hibernate Query Language), который позволяет разработчикам писать запросы на высоком уровне абстракции, а также его собственный кэш второго уровня, который улучшает производительность приложения.

Разница между JPA и Hibernate заключается в том, что JPA является стандартом, который имеет несколько реализаций, включая Hibernate, EclipseLink и OpenJPA. Hibernate - одна из самых популярных реализаций JPA и предоставляет наиболее широкий набор функциональных возможностей и расширений. Однако, использование JPA позволяет создавать более переносимый код между различными ORM-фреймворками, а также повышает уровень абстракции взаимодействия с базой данных.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 66. `Что такое каскадность? Как она используется в Hibernate?`

`Каскадность (Cascade)` - это механизм в Hibernate, позволяющий автоматически распространять операции сохранения, обновления или удаления сущности на связанные с ней объекты.

Каскадность используется в Hibernate для управления связями между сущностями и уменьшения количества кода, необходимого для выполнения операций CRUD (Create, Read, Update, Delete) с базой данных. Без каскадности при изменении состояния одной сущности, например ее удалении, разработчику пришлось бы явно удалять все связанные сущности вручную.

Hibernate поддерживает несколько типов каскадности:

+ `CascadeType.ALL` - операция каскадного удаления, сохранения и обновления применяется ко всем связанным сущностям.
+ `CascadeType.PERSIST` - каскадное сохранение применяется ко всем связанным сущностям.
+ `CascadeType.MERGE` - каскадное обновление применяется ко всем связанным сущностям.
+ `CascadeType.REMOVE` - каскадное удаление применяется ко всем связанным сущностям.
+ `CascadeType.DETACH` - каскадное отсоединение применяется ко всем связанным сущностям.
+ `CascadeType.REFRESH` - каскадное обновление применяется ко всем связанным сущностям.
+ `CascadeType.NONE` - каскадность не применяется ни к одной связанной сущности.

Каскадность позволяет управлять изменениями в базе данных через ORM, а также уменьшает количество кода, необходимого для выполнения операций CRUD. Однако следует использовать ее осторожно, чтобы избежать нежелательных побочных эффектов и неожиданных изменений в базе данных.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 67. `Может ли entity-класс быть абстрактным классом?`

Да, entity-класс может быть абстрактным классом в Hibernate.

Абстрактный класс является классом, у которого не реализованы некоторые методы и который не может быть инстанцирован напрямую. Вместо этого он может быть использован только как базовый класс для других классов, которые должны реализовать его абстрактные методы.

В Hibernate entity-класс представляет отображение таблицы из базы данных на Java-объект. Абстрактный класс может определять общие поля и методы для сущностей, которые наследуют его, что может быть полезным в случае, когда несколько сущностей имеют общие свойства.

Таким образом, entity-класс может быть абстрактным классом, если это имеет смысл для конкретной модели данных и будет соответствовать логике приложения.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 68. `Что такое entity manager? За что отвечает?`

`Entity Manager` - это интерфейс в JPA, который предоставляет API для управления жизненным циклом сущностей. Entity Manager отвечает за управление связью между объектами Java и базой данных, что позволяет разработчикам использовать объектно-ориентированный подход при работе с базой данных.

Основные задачи Entity Manager включают:

+ Создание, удаление и обновление сущностей в базе данных.
+ Поиск и выборка сущностей из базы данных.
+ Контроль жизненного цикла сущностей, таких как управление их состоянием (managed, detached, transient).
+ Кэширование и оптимизация запросов к базе данных.
+ Управление транзакциями.
+ Работа с ленивой загрузкой (lazy loading) и Eager-загрузкой (Eager loading).

Entity Manager может быть получен через EntityManagerFactory, который создает и конфигурирует соединение с базой данных. Объект EntityManager привязывается к определенной транзакции и управляет делегированием инструкций SQL в базу данных. Также он используется для работы с контекстом персистентности сущностей, что позволяет сохранять изменения объектов Java в базу данных и извлекать данные из нее.

В целом, Entity Manager является важным компонентом JPA, который отвечает за управление связью между объектами Java и базой данных, что делает работу с базой данных более простой и гибкой.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 69. `Что такое класс Assert? Зачем и как его использовать?`

`Класс Assert` - это класс в Java, который позволяет проверять утверждения (assertions) и генерировать ошибку AssertionError в случае нарушения этих утверждений.

Assert используется для тестирования кода и обнаружения ошибок во время разработки приложений. Он предоставляет простой способ проверки соблюдения определенных правил и условий в вашем коде, что помогает отлавливать ошибки еще до запуска приложения.

Пример использования Assert:

```java
int x = 5; 
assert x == 10 : "Ошибка: x не равен 10";
```
В этом примере мы проверяем, что значение переменной x равно 10. Если это не так, то будет выброшено исключение AssertionError с сообщением "Ошибка: x не равен 10".

Assert может быть использован для проверки различных условий, таких как проверка диапазона значений, наличия объектов, корректности данных и других правил, которые должны соблюдаться в вашем коде.

Однако, следует использовать Assert осторожно и только для проверки предполагаемых условий, которые не могут быть изменены во время выполнения программы. Важно не злоупотреблять его использованием и не забывать выключать assertions в релизной версии приложения, чтобы не снижать производительность.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 70. `Дайте характеристику String в Java.`

`String` в Java - это класс, который представляет последовательность символов. Он является неизменяемым (immutable) объектом, что означает, что его значение не может быть изменено после создания.

Характеристики String в Java:

+ `Неизменяемость` - значения объекта String нельзя изменить после его создания. Это делает его безопасным для использования в многопоточном окружении и обеспечивает более простое управление памятью.
+ `Unicode-кодировка` - в Java строки хранятся в формате Unicode, что позволяет использовать различные символы из разных языковых наборов.
+ `Методы работы со строками` - класс String имеет много методов для работы со строками, таких как сравнение, поиск, замена, разделение, конкатенация строк и другие.
+ `Пул строк` - Java использует пул строк (string pool), что позволяет экономить память и повышает производительность при работе со строками.
+ `Использование в качестве ключей Map` - String часто используется в качестве ключей для Map, благодаря своей неизменяемости и возможности реализации методов hashCode() и equals().
+ `Создание объекта String` - объект String можно создать, используя литералы, конструкторы и методы.

В целом, String - это очень важный и широко используемый класс в Java, который предоставляет много возможностей для работы со строками и облегчает разработку приложений. Его неизменяемость и поддержка Unicode-кодировки делают его безопасным и удобным для использования в любых проектах.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 71. `Какие способы создания объекта String? Где он создается?`

В Java объект String можно создать несколькими способами:

+ `С помощью литералов` - это самый простой способ создания объекта String в Java. Литералы представляются как последовательность символов, заключенных в двойные кавычки. Например:
```java
String str = "Hello, World!";
```
+ `С помощью конструктора` - класс String имеет несколько конструкторов, которые могут использоваться для создания новых объектов String. Например:
```java
String str1 = new String(); // пустая строка
String str2 = new String("Hello"); // строка со значением "Hello"
```
+ `С помощью методов` - String также имеет множество методов, которые могут быть использованы для создания новых объектов String. Например:
```java
String str1 = String.valueOf(123); // "123"
String str2 = "Hello, ".concat("World!"); // "Hello, World!"
```
Объект String создается в куче (heap) - области памяти, в которой хранятся динамические объекты в Java. Когда вы создаете новый объект String, он размещается в куче и может быть управляем сборщиком мусора.

Также стоит отметить, что в Java существует pool строк (string pool), который хранит все уникальные строки, созданные с помощью литералов. При создании новой строки с помощью литерала, JVM сначала проверяет, есть ли уже строка с таким же значением в пуле строк. Если она уже там есть, то возвращается ссылка на эту строку, а не создается новый объект. Это может быть полезно при работе со строками, чтобы не создавать дубликаты и экономить память.


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 72. `Как сравнить две строки в Java и/или отсортировать их?`


Для сравнения строк в Java можно использовать методы equals() и compareTo().

Метод equals() сравнивает содержимое двух строк и возвращает значение true, если они равны, и false - в противном случае. Например:

```java
String str1 = "Hello";
String str2 = "hello";

if (str1.equals(str2)) {
    System.out.println("Строки равны");
} else {
    System.out.println("Строки не равны");
}
```
Результат выполнения программы: Строки не равны

Метод compareTo() сравнивает две строки лексикографически и возвращает целое число, которое показывает, какая из строк больше или меньше. Если результат сравнения равен 0, это значит, что строки равны. Например:

```java
String str1 = "Hello";
String str2 = "World";

int result = str1.compareTo(str2);

if (result == 0) {
    System.out.println("Строки равны");
} else if (result < 0) {
    System.out.println("Строка str1 меньше строки str2");
} else {
    System.out.println("Строка str1 больше строки str2");
}
```
Результат выполнения программы: Строка str1 меньше строки str2

Для сортировки массива строк в Java можно использовать метод Arrays.sort(). Например:

```java
String[] arr = {"apple", "banana", "orange", "pear"};
Arrays.sort(arr); // сортировка в алфавитном порядке

for (String s : arr) {
    System.out.println(s);
}
```
Результат выполнения программы:
```
apple
banana
orange
pear
```
Обратите внимание, что метод sort() сортирует массив строк в алфавитном порядке по умолчанию. Если нужна другая сортировка, например, по длине строк, можно использовать свой компаратор и передать его как дополнительный аргумент методу sort().


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 73. `Предложите алгоритм преобразования строки в символ. Напишите соответствующий код.`


Для преобразования строки в символ можно использовать метод charAt() класса String.

Алгоритм:

+ Создать строку str.
+ Получить длину строки length.
+ Если length равен 0, вернуть null.
+ Если length больше 1, вывести сообщение об ошибке и вернуть null.
+ Получить символ из строки с помощью метода charAt().
+ Вернуть полученный символ.


Пример кода на Java:

```java
public static Character stringToChar(String str) {
    int length = str.length();
    if (length == 0) {
        return null;
    }
    if (length > 1) {
        System.out.println("Ошибка: в строке должен быть только один символ.");
        return null;
    }
    return str.charAt(0);
}
```
Пример использования:

```java
String str = "H";
Character ch = stringToChar(str);
if (ch != null) {
    System.out.println("Символ: " + ch);
} else {
    System.out.println("Ошибка!");
}
```
Результат выполнения программы: Символ: H

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 74. `Как превратить строку в массив байтов и обратно? Напишите соответствующий код.`

В Java для преобразования строки в массив байтов можно использовать метод getBytes() из класса String. Для обратного преобразования массива байтов в строку можно использовать конструктор String(byte[]). Вот пример кода:

```java
// преобразование строки в массив байтов
String myString = "Hello, world!";
byte[] myBytes = myString.getBytes();
System.out.println(Arrays.toString(myBytes));

// обратное преобразование массива байтов в строку
String myStringBack = new String(myBytes);
System.out.println(myStringBack);
```
В этом примере мы создаем строку "Hello, world!", затем преобразуем ее в массив байтов с помощью метода getBytes(). Мы выводим этот массив байтов на экран, чтобы убедиться, что он был создан правильно.

Затем мы обратно преобразуем массив байтов в строку с помощью конструктора String(byte[]), и выводим эту строку на экран, чтобы убедиться, что она равна исходной строке.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 75. `Что такое пул строк и для чего он нужен?`

В Java пул строк (String Pool) - это механизм, который используется для управления объектами типа String. Этот пул представляет собой специальный область в памяти, где хранятся все уникальные строки, созданные в приложении. При создании новой строки Java автоматически проверяет наличие уже созданной строки с таким же содержимым в пуле строк, и если она там уже есть, то возвращается ссылка на существующий объект String, а не создается новый.

Использование пула строк имеет следующие преимущества:

+ `Экономия памят`и: благодаря использованию пула строк, несколько строк с одинаковым значением будут использовать только один и тот же объект в памяти.
+ `Быстродействие`: поиск в пуле строк занимает меньше времени, чем создание нового объекта, что может быть полезно в приложениях с большой нагрузкой.
+ `Гарантированное поведение`: строковые литералы, которые объявлены в программе, всегда будут использовать пул строк и будут сравниваться между собой по значению, а не по ссылке.

Однако, следует помнить, что пул строк может привести к утечке памяти, когда строки попадают в пул, но не удаляются из него, даже если на них нет ссылок. Поэтому, при работе с большим количеством строк, следует обращать внимание на использование пула строк и правильно управлять памятью вашего приложения.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 76. `Какие GOF-шаблоны используются в пуле строк?`

В Java используется шаблон проектирования "Пул объектов" (Object Pool), который позволяет повторно использовать уже созданные объекты, вместо того чтобы создавать новые. В случае пула строк в Java, при создании новой строки происходит проверка на наличие такой же строки в пуле строк, и если она там уже существует, то возвращается ссылка на существующий объект строки из пула, что позволяет избежать необходимости создания нового объекта строки и уменьшает нагрузку на сборщик мусора.

Шаблон проектирования "Пул объектов" не является частью GOF-шаблонов, однако он может быть реализован при помощи некоторых других шаблонов, таких как "Одиночка" (Singleton) и "Фабрика" (Factory).

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 77. `Как разделить строку на две части? Напишите соответствующий код.`

Для разделения строки на две части можно использовать метод substring() класса String. Метод substring() возвращает подстроку, начинающуюся с указанного индекса и заканчивающуюся перед указанным конечным индексом.

Алгоритм:

+ Создать строку str.
+ Получить длину строки length.
+ Вычислить индекс середины строки (если длина нечетная, то округлить до целого).
+ Получить первую половину строки с помощью метода substring().
+ Получить вторую половину строки с помощью метода substring().
+ Вернуть полученные строки.

Пример кода на Java:

```java
public static String[] splitString(String str) {
    int length = str.length();
    int middleIndex = length / 2;
    String firstHalf = str.substring(0, middleIndex);
    String secondHalf = str.substring(middleIndex);
    return new String[] {firstHalf, secondHalf};
}
```
Пример использования:

```java
String str = "Hello, world!";
String[] halves = splitString(str);
System.out.println("Первая половина: " + halves[0]);
System.out.println("Вторая половина: " + halves[1]);
```
Результат выполнения программы:
```
Первая половина: Hello,
Вторая половина:  world!
```
Обратите внимание, что если длина строки нечетная, то первая половина будет содержать один символ больше, чем вторая половина.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 78. `Почему массив символов лучше строки для хранения пароля?`

Массив символов может быть предпочтительнее для хранения пароля в сравнении со строкой по нескольким причинам:

+ `Безопасность`: Содержимое массива символов может быть очищено после использования, делая его более безопасным в случае злоумышленного доступа к памяти. При работе со строками, они могут быть сохранены в системе за пределами контроля программы, что может привести к риску компрометации безопасности приложения.
+ `Неизменяемость данных`: В отличие от строк, которые являются изменяемыми объектами, массивы символов не могут быть изменены после создания, что обеспечивает дополнительный уровень безопасности.
+ `Способность к удалению`: Массив символов можно очистить после использования, чтобы гарантировать, что пароль не будет доступен после завершения работы с ним. В некоторых языках программирования такой подход не работает с типом данных строк.
+ `Производительность`: Работа с массивом символов может быть быстрее, чем со строками, особенно если имеется большой объем данных. Размер массива символов известен и фиксирован, что позволяет избежать дополнительных расходов на выделение дополнительной памяти.

Однако, стоит отметить, что массив символов не может быть использован везде, где используются строки. Также необходимо учитывать, что использование массива символов для хранения паролей не является панацеей и не обеспечивает полной безопасности. Безопасность приложения зависит от многих факторов, таких как криптографические методы шифрования, защита данных при передаче, хранение паролей в безопасном виде и другие меры защиты.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 79. `Какая разница между String, StringBuffer и StringBuilder?`

 Java имеется три класса, позволяющих работать со строками: String, StringBuffer и StringBuilder.

Основное отличие между этими классами заключается в том, что String является неизменяемым классом, то есть каждая операция над объектом String приводит к созданию нового объекта. В свою очередь, классы StringBuffer и StringBuilder используются для работы с изменяемыми символьными последовательностями.

Класс StringBuffer был создан для того, чтобы решить проблему производительности при работе с изменяемыми строками. Он обеспечивает потокобезопасность, что позволяет использовать его в многопоточных приложениях. Однако, этот класс является менее эффективным по сравнению с StringBuilder.

Класс StringBuilder был добавлен в Java 5 как альтернатива StringBuffer. Он также обеспечивает возможность работы с изменяемыми строками, однако не является потокобезопасным. Зато он более эффективен по скорости выполнения операций.

Вот основные различия между классами String, StringBuffer и StringBuilder:

+ `String - неизменяемый класс`, предназначенный для работы со строками. Каждый раз, когда выполняется операция над объектом String, создается новый объект, что может привести к ухудшению производительности.

+ `StringBuffer - изменяемый класс для работы со строками`. Он обеспечивает потокобезопасность и более медленный, чем StringBuilder.

+ `StringBuilder - также изменяемый класс для работы со строками`. Он не обеспечивает потокобезопасность, но при этом более быстрый по сравнению с StringBuffer.

Использование того или иного класса зависит от конкретной задачи. Если нужно работать со строками в многопоточном окружении, то лучше использовать StringBuffer. Если же нет необходимости в потокобезопасности, то для повышения производительности рекомендуется использовать StringBuilder. Наконец, если нужно работать с неизменяемой строкой, то используйте String.


Перечисление


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 80. `Дайте краткую характеристику Enum в Java.`

Enum в Java - это перечислимый тип данных, который представляет собой набор именованных констант. Каждая константа представляет определенное значение из заданного списка значений. С помощью Enum можно создавать коллекции констант, которые могут использоваться в качестве аргументов для методов или свойств объектов. Кроме того, Enum обеспечивает безопасность типов, что означает, что используя константы Enum, можно избежать ошибок ввода-вывода и других ошибок, связанных с типами данных.

Пример кода создания Enum в Java:
```java
public enum DayOfWeek {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY;
}
```
Здесь мы создаем Enum с именем "DayOfWeek", который содержит 7 констант: "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY" и "SUNDAY". Константы перечислены через запятую, заключенные в скобки { }.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 81. `Может ли Enum реализовывать (implement) интерфейс?`

Да, в Java Enum может реализовывать (implement) интерфейс. Это означает, что каждая константа Enum будет иметь реализацию методов этого интерфейса.

Рассмотрим следующий пример кода:
```java
public interface MyInterface {
   void myMethod();
}

public enum MyEnum implements MyInterface {
   CONSTANT1 {
      @Override
      public void myMethod() {
         System.out.println("Constant 1 implementation");
      }
   },
   CONSTANT2 {
      @Override
      public void myMethod() {
         System.out.println("Constant 2 implementation");
      }
   };

   // общие методы для всех констант
   public void someMethod() {
      System.out.println("Some method implementation");
   }
}
```
Здесь мы создаем интерфейс "MyInterface", который содержит метод "myMethod()". Далее мы создаем Enum "MyEnum", который реализует этот интерфейс. Внутри Enum мы создаем две константы - "CONSTANT1" и "CONSTANT2", которые обе реализуют метод "myMethod()" интерфейса "MyInterface".

Также в Enum мы можем определять свои собственные методы, которые будут доступны для всех констант.

В данном примере при вызове метода "myMethod()" для константы "CONSTANT1" будет выведено сообщение "Constant 1 implementation", а для "CONSTANT2" - "Constant 2 implementation". Вызов метода "someMethod()" для любой из констант Enum выведет сообщение "Some method implementation".

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 82. `Может ли Enum расширить (extends) класс?`

В Java Enum не может расширять (extends) классы, так как Enum уже является конечной реализацией класса. В Java каждый Enum наследуется от класса java.lang.Enum, который уже содержит реализацию методов, свойств и функциональности, необходимых для работы перечислений.

Также если мы попытаемся объявить перечисление, которое наследует другой класс, то компилятор выдаст ошибку. Например:
```java
public class MyClass {
  // some code
}

public enum MyEnum extends MyClass { // ОШИБКА КОМПИЛЯЦИИ!
  // some code
}
```
Компилятор сообщит об ошибке при объявлении Enum, наследующего MyClass, так как это не допустимо в Java.

Однако, класс может реализовать интерфейс, который уже реализован в Enum, чтобы добавить дополнительный функционал к Enum, но это будет реализация интерфейса, а не расширение класса.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 83. `Можно ли создать Enum без экземпляров объектов?`

Да, в Java можно создать перечисление (enum) без экземпляров объектов. Для этого нужно создать пустой список аргументов в определении перечисления, например:
```java
public enum MyEnum {
  INSTANCE;
  // остальной код
}
```
Но у этого перечисления всё равно будет один экземпляр, INSTANCE. Этот подход используется часто при реализации паттерна Singleton.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 84. `Можем ли мы переопределить метод toString() для Enum?`

Да, вы можете переопределить метод toString() для Enum в Java. По умолчанию вызов toString() для экземпляра Enum возвращает значение его поля имени. Однако вы можете определить собственный метод toString() для класса Enum, чтобы возвращать другое строковое представление экземпляра. Вот пример:
```java
public enum Day {
  MONDAY("Monday"), TUESDAY("Tuesday"), WEDNESDAY("Wednesday"), 
  THURSDAY("Thursday"), FRIDAY("Friday"), SATURDAY("Saturday"), SUNDAY("Sunday");

  private String displayName;

  private Day(String displayName) {
    this.displayName = displayName;
  }

  @Override
  public String toString() {
    return displayName;
  }
}
```
В этом примере перечисление Day имеет настраиваемое поле displayName и конструктор, который задает это поле для каждой константы перечисления. Затем метод toString() переопределяется, чтобы возвращать значение displayName вместо имени. Теперь вызов toString() для любого экземпляра Day вернет соответствующее отображаемое имя вместо постоянного имени.

Имейте в виду, что классы enum неизменяемы, а это означает, что вы не можете изменить существующий экземпляр или создать новые экземпляры во время выполнения. Таким образом, когда вы переопределяете метод toString() или любой другой метод, вы должны определить его в исходном определении класса перечисления, а не в подклассе или экземпляре класса перечисления.


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 85. `Что будет, если не будем переопределять метод toString() для Enum?`

Если не переопределить метод toString() для Enum, то при вызове этого метода будет возвращаться строковое представление элемента Enum по умолчанию. По умолчанию toString() возвращает имя элемента Enum, которое задается в объявлении константы.

Например, для следующего объявления Enum:
```java
enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
}
```
При вызове метода toString() для элемента Day.MONDAY будет возвращаться строка "MONDAY".

Однако, если поведение метода toString() для элементов Enum не соответствует требованиям вашей программы, то вы можете переопределить его и задать нужное поведение. Например, вы можете определить, что для каждого элемента Enum должно возвращаться уникальное значение или что метод toString() должен возвращать более информативную строку.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 86. `Можем ли мы указать конструктор внутри Enum?`

Да, в Java вы можете указывать конструкторы внутри перечислений (Enum). Конструкторы в Enum используются для инициализации значений элементов перечисления.

Конструктор Enum вызывается автоматически при создании каждого элемента перечисления. При определении конструктора следует учесть, что конструктор Enum всегда приватный (private) и не может быть объявлен как public или protected. Это означает, что конструктор Enum не может быть вызван снаружи класса перечисления.

Вот пример использования консруктора внутри Enum:
```java
enum Day {
    MONDAY("Monday"), 
    TUESDAY("Tuesday"), 
    WEDNESDAY("Wednesday"), 
    THURSDAY("Thursday"), 
    FRIDAY("Friday"), 
    SATURDAY("Saturday"), 
    SUNDAY("Sunday");

    private String displayName;

    private Day(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }
}
```
В этом примере мы определяем перечисление Day, которое имеет поле displayName и конструктор, который инициализирует это поле. Мы также определяем метод getDisplayName(), который позволяет получить значение поля displayName.

Теперь, при создании каждого элемента перечисления Day, нам нужно указывать значение поля displayName. Например, чтобы создать элемент MONDAY со значением Monday, мы можем использовать следующий код:
```java
Day monday = Day.MONDAY;
System.out.println(monday.getDisplayName()); // выведет "Monday"
```
<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 87. `В чем разница между == и equals()?`

 Java == и equals() - это два разных оператора.

Оператор == сравнивает ссылки на объекты, то есть проверяет, указывают ли две переменные на один и тот же объект в памяти. Если две переменные указывают на один и тот же объект, то оператор == вернет true. В противном случае, если две переменные указывают на разные объекты, то оператор == вернет false.

Например:
```java
String s1 = "hello";
String s2 = "hello";
String s3 = new String("hello");
System.out.println(s1 == s2); // true
System.out.println(s1 == s3); // false
```
В этом примере две переменные s1 и s2 указывают на один и тот же объект в пуле строк, поэтому оператор == возвращает true. А переменная s3 указывает на новый объект, созданный с помощью ключевого слова new, поэтому оператор == возвращает false.

Метод equals(), с другой стороны, сравнивает содержимое объектов, а не ссылки на них. Реализация метода equals() может быть переопределена для классов, чтобы определить, как должно быть выполнено сравнение содержимого.

Например:
```java
String s1 = "hello";
String s2 = "hello";
String s3 = new String("hello");
System.out.println(s1.equals(s2)); // true
System.out.println(s1.equals(s3)); // true (как только переопределено для String)
```
Здесь вызов метода equals() вернет true, так как содержимое всех трех строк одинаково, несмотря на то, что две переменные (s1 и s2) указывают на один и тот же объект в пуле строк, а переменная s3 указывает на новый объект.

Таким образом, если вам нужно сравнить ссылки на объекты, используйте оператор ==. Если вам нужно сравнить содержимое объектов, используйте метод equals().

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 88. `Что делает метод ordinal() в Enum?`

`Метод ordinal()` в Enum возвращает порядковый номер константы перечисления (enum), начиная с 0. Порядковый номер - это позиция элемента перечисления в списке значений этого перечисления.

Например, если у вас есть перечисление Season со значениями WINTER, SPRING, SUMMER и FALL, то вызов метода WINTER.ordinal() вернет 0, метода SPRING.ordinal() вернет 1, метода SUMMER.ordinal() вернет 2 и метода FALL.ordinal() вернет 3.

Заметьте, что порядковый номер элемента может измениться, если новые элементы добавляются или удалены из перечисления. Поэтому порядковый номер не должен использоваться в качестве постоянных идентификаторов для элементов перечисления.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 89. `Можно ли использовать Enum из TreeSet или TreeMap в Java?`

Да, Enum можно использовать как ключи (keys) в TreeMap и как элементы (elements) в TreeSet в Java. Это возможно, потому что Enum реализует java.lang.Comparable интерфейс. Одним из преимуществ использования Enum в качестве ключей в TreeMap является то, что Enum константы определены и упорядочены по порядку определения, что обеспечивает естественный порядок сортировки элементов в TreeMap. Например:
```java
enum Color {
    RED, GREEN, BLUE
}

Map<Color, String> colorCodes = new TreeMap<>();
colorCodes.put(Color.RED, "FF0000");
colorCodes.put(Color.GREEN, "00FF00");
colorCodes.put(Color.BLUE, "0000FF");

System.out.println(colorCodes);
```
Результат будет выводиться в отсортированном порядке, как: {BLUE=0000FF, GREEN=00FF00, RED=FF0000}.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 90. `Как связаны методы ordinal() и compareTo() в Enum?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 91. `Напишите пример Enum.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 92. `Можно ли использовать Enum в switch case?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 93. `Как получить все имеющиеся значения в экземпляре Enum?`

Потоковое API


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 94. `Что такое Stream в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 95. `Назовите главные характеристики транзакций.98. Каковы уровни изоляции транзакций?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 96. `Какая разница между Statement и PreparedStatement?`

Коллекции


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 97. `Расскажите об итераторах и их применении.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 98. `Какова иерархия коллекций Java Collection Framework?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 99. `Каково внутреннее строение ArrayList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 100. `Каково внутреннее строение LinkedList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 101. `Каково внутреннее устройство HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 102. `Чем отличается ArrayList от LinkedList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 103. `Чем отличается ArrayList от HashSet?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 104. `Зачем в Java такое разнообразие имплементации динамического массива?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 105. `Зачем в Java такое разнообразие имплементации key-value storage?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 106. `Как сортировать коллекцию элементов? Объект класса. Равно и HashCode`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 107. `Дайте краткую характеристику class object в Java.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 108. `Для чего используют Equals and HashCode в Java? Расскажите о контракте между Equals and HashCode в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 109. `Какие условия выдвигаются по поводу переопределения сделки при переопределении Equals?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 110. `Что будет, если не переопределить Equals and HashCode?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 111. `Какие значения мы получим, если у нас не перераспределены Equals and HashCode?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 112. `Почему симметричность выполняется только если x.equals(y) возвращает значение true?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 113. `Что такое коллизия в HashCode? Как с ней бороться?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 114. `Что будет, если элемент, участвующий в контракте с HashCode, изменяет значение?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 115. `Напишите методы Equals and HashCode для класса Student, состоящего из полей String name и int age.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 116. `В чем разница применения if(obj instanceof Student) и if(getClass() == obj.getClass())?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 117. `Дайте краткую характеристику метода clone().`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 118. `В чем состоит особенность работы метода clone() с полями объекта типа-ссылки?`

Исключения


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 119. `Дайте определение понятию exception (исключительная ситуация).`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 120. `Какие особенности использования оператора try...catch знаете?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 121. `В чем разница между error и exception?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 122. `Какая разница между checked и unchecked, exception, throw, throws.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 123. `Какова иерархия исключений?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 124. `Что такое checked и unchecked exception?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 125. `Нужно ли проверять checked exception?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 126. `О чем говорит и как использовать ключевое слово throws?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 127. `Какие возможные способы обработки исключений вы знаете?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 128. `Напишите пример перехвата и обработки исключения в блоке метода try-catch.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 129. `Напишите пример перехвата и обработки исключения в секции throws-метода и передачи вызывающего метода.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 130. `Приведите пример перехвата и обработки исключения с использованием собственных исключений.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 131. `Каковы правила проверки исключений во время подражания?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 132. `Могли бы вы написать код, если блок finally не будет выполнен?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 133. `Напишите пример обработки нескольких исключений в одном блоке catch.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 133. `Какой оператор позволяет принудительно выбросить исключение? Напишите пример.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 134. `Может ли метод main выбросить throws-исключение? Если да – куда передаст?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 135. `Приведите пример try with resources.`

Многопоточность


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 136. `Какие средства для работы с многопоточностью знаете?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 137. `Что такое процесс и поток? Чем отличается процесс от потока?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 138. `Расскажите о синхронизации между потоками. Для чего используют методы wait(), notify() – notifyAll(), join()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 139. `Как остановить поток?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 140. `Как между потоками обмениваться данными?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 141. `В чем отличие класса Thread от интерфейса Runnable?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 142. `Есть потоки Т1, Т2 и Т3. Как реализовать их последовательное исполнение?`

Практические задачи


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 143. `Matrix Diagonal Sum (задача из Leetcode).`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 144. `Move Zeroes (задача из Leetcode).`

Дан целочисленный массив nums. Необходимо переместить все нулевые элементы в конец массива, сохраняя относительный порядок элементов, не являющихся нулем. Решение должно производиться на месте, без использования дополнительного массива, а также должно иметь минимальную сложность по времени и пространству.

Пример:
```
Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
```

```java
public void moveZeroes(int[] nums) {
    int index = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != 0) {
            nums[index++] = nums[i];
        }
    }
    while (index < nums.length) {
        nums[index++] = 0;
    }
}
```
Описание алгоритма:
Мы будем использовать два указателя: i и index. Сначала мы будем проходить по массиву nums с помощью указателя i и каждый раз, когда мы найдем ненулевой элемент, мы будем переносить его на место индекса index и увеличивать значение index. Затем мы заполняем оставшиеся позиции нулями. В результате все нули будут перемещены в конец массива, а все ненулевые элементы будут находиться в начале массива в том же порядке, что и в исходном массиве.

Данный алгоритм работает за линейное время O(n), где n - это длина массива nums.

<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 145. `Given List<String> names . Удалите первую букву из каждого имени и поверните отсортированный список.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 146. `Перевернуть массив.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 147. `Проверить, является ли строка палиндромом.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 148. `Написать простой алгоритм сортировки (Bubble, Selection или Shuttle). Как его можно улучшить?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 149. `Напишите алгоритм (последовательность действий) составления литерала типа int и литерала типа byte. Объясните, что происходит с памятью.`



Middle
Общие


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 150. `В чем преимущества и недостатки ООП, если сравнивать с процедурным/функциональным программированием?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 151. `Чем отличается агрегация от композиции?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 152. `Какие паттерны GoF вы использовали на практике? Приведите примеры.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 153. `Что такое прокси-объект? Приведите примеры.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 154. `Какие нововведения анонсированы в Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 155. `Что такое High Cohesion и Low Coupling? Приведите примеры.`

ООП


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 156. `Как можно реализовать множественное подражание в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 157. `Какая разница между методами final, finally и finalize()?`

Core Java


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 158. `В чем разница между статическим и динамическим связыванием Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 159. `Можно ли использовать private или protected переменные в interface?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 160. `Что такое Classloader и зачем используется?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 161. `Что такое Run-Time Data Areas?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 162. `Что такое immutable object?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 163. `В чем особенность класса String?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 164. `Что такое ковариантность типов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 165. `Какие методы в классе Object?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 166. `Приведите примеры успешного и неудачного использования Optional.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 167. `Можно ли объявлять main method как final?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 168. `Можно ли импортировать те же package/class дважды? Какие последствия?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 169. `Что такое Casting? Когда мы можем получить исключение ClassCastException?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 170. `Почему современные фреймворки используют в основном только unchecked exceptions?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 171. `Что такое static import?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 172. `Какова связь между методами hashCode() и equals()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 173. `Когда используют классы BufferedInputStream и BufferedOutputStream?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 174. `Какая разница между классами java.util.Collection и java.util.Collections?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 175. `Какая разница между Enumeration и Iterator?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 176. `В чем разница между итераторами fail-fast и fail-safe?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 177. `Зачем нужен модификатор transient?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 178. `Как влияют на сериализацию модификаторы static и final?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 179. `Каковы особенности использования интерфейса Cloneable?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 180. `Каковы особенности использования интерфейса AutoCloseable?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 181. `Что такое FunctionInterface и чем он отличается от обычного интерфейса?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 182. `Что такое и для чего нужны Atomic types?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 183. `Что такое Happens-before? Каковы особенности использования ключевого слова volatile?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 184. `Расскажите о Heap и Stack памяти в Java. В чем разница между ними? Где хранятся примитивы?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 185. `Чем отличается stack от heap памяти? Когда и какая область памяти резервируется? Зачем такое разделение нужно?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 186. `Каков принцип работы и области памяти Garbage Collector?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 187. `Как работает Garbage Collector? Расскажите о Reference counting и Tracing.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 188. `Расскажите о механизме работы autoboxing в Java. `


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 189. `Как реализована сериализация в Java? Где мы можем ее увидеть?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 190. `Расскажите, в чем разница между WeakReference и SoftReference?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 191. `Что такое generics? Зачем они нужны? Какую проблему решают?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 192. `Что такое PECS и как используется? Приведите примеры.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 193. `Для чего на практике могут понадобиться immutable объекты?`

Библиотеки и инструменты


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 189. `Чем полезны инструменты Maven, Ant, Gradle?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 190. `Что такое Unit Tests? Чем класс JUnit.Assert отличается от ключевого слова assert?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 191. `Что такое и для чего нужен Spring core? Раскройте понятия Inversion of Control и Dependency Injection.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 192. `Как «под капотом» работает @Transactional?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 193. `Как "под капотом" работает Spring?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 194. `Что такое и зачем нужен Hibernate? Раскройте понятие ORM.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 195. `Что такое и когда возникает LazyLoadingException?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 196. `Как "под капотом" работает Hibernate? Как бы вы написали свой Hibernate?`

Многопоточность


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 197. `Расскажите о четырех способах работы со многими потоками и чем отличается wait...notify...notifyAll от synchronized? От Future?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 198. `Каковы преимущества и недостатки использования многопоточности?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 199. `Что такое и зачем нужен ThreadLocal?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 200. `В чем разница между Thread.sleep() и Thread.yield()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 201. `Как работает Thread.join()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 202. `Что такое deadlock?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 203. `Что такое race condition?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 204. `Для чего использовать volatile, synchronized, transient, native?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 205. `Расскажите о приоритетах потоков.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 206. `Что такое и зачем устанавливать потоки-демоны?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 207. `Почему не желательно использовать Thread.stop()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 208. `Как реализовать пул потоков?`

Коллекции


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 209. `В чем разница между HashSet, LinkedHashSet и TreeSet?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 210. `Чем отличается List от Set?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 211. `Какова внутренняя структура HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 212. `Какое время поиск элемента в ArrayList, HashSet?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 213. `Как реализовать свой Stack?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 214. `Как работает метод put в HashMap? Почему нам нужно высчитывать позицию бакета? В чем преимущества такой операции?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 215. `В чем разница между HashMap и TreeMap? Когда и где их нужно использовать?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 216. `Каково внутреннее строение TreeMap? Рассказать о RBT.`

Потоковое API


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 217. `Какие методы в интерфейсе Stream?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 218. `Чем отличается метод map от flatMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 219. `Какой функциональный интерфейс употребляет способ filter?`

Базы данных


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 220. `В чем разница между реляционными и нереляционными базами данных?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 221. `Как сохраняются соотношения one-to-one, one-to-many и many-to-many в виде таблиц?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 222. `Что такое нормализация базы данных? Приведите примеры реального проекта.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 223. `Какие виды индексов в БД?`

Практические задачи


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 224. `Valid parentheses (задача из LeetCode).`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 225. `Reverse Linked List (задача из LeetCode).`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 226. `Даны String s, найти длину максимального substring без повтора символов.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 227. `Определить, является ли односвязный LinkedList палиндромом.`

Senior
Общие


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 227. `Когда лучше использовать подражание, а не агрегацию`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 228. `Расскажите о принципах работы Kubernetes.`

Core Java


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 229. `В чем разница между Java NIO и Java IO?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 230. `Чем отличается Lambda от анонимного класса?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 231. `Расскажите о Java Memory Model.6. Какие типы памяти у JVM?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 232. `Опишите жизненный цикл Java-объекта. Как объект переходит из одной области памяти Garbage Collector в другую? Что является триггером такого перехода?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 233. `Как можно заставить JVM запустить Garbage Collector?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 234. `Какие существуют Garbage Collectors в JVM и зачем их столько?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 235. `Какие разновидности Garbage Collector есть в HotSpot? Как работают?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 236. `Что будет с Garbage Collector, если finalize() будет долго выполняться или в процессе выполнения получим исключение?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 237. `Чем отличается ForkJoinPool от ScheduledThreadPoolExecutor и ThreadPoolExcutor?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 238. `Какая разница между HashMap, WeakHashMap, Hashtable, IdentityHashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 239. `Что такое LinkedHashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 240. `Что такое EnumSet? Зачем использовать? Как реализовать?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 241. `Расскажите об особенностях сериализации в Java. Зачем serialVersionUID и InvalidClassException?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 242. `В чем проблема сериализации Singleton?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 243. `Какие алгоритмы обхода деревьев бывают и почему они разные?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 244. `Что такое deadlock? Какие типы есть? Нарисуйте схематически, как это может произойти.`

Базы данных


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 244. `Что такое ACID?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 245. `Что означает CAP-теорема?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 246. `Каковы уровни изоляции транзакций?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 247. `Есть ли смысл отказываться от использования ORM?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 248. `Что такое n+1 проблема?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 249. `Что такое cartesian product проблема?`

Библиотеки и инструменты


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 250. `Как построить monitoring в Java? Расскажите об особенностях использования Java micrometrics или DropWizard или Prometheus frameworks.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 251. `Опишите механизм работы ORM.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 252. `Какие способы выборки данных в Hibernate вы знаете?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 253. `Какие изоляции транзакций есть в Hibernate?`

Spring


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 254. `Что такое IoC и DI?


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 255. `Каков жизненный цикл объектов, создаваемых Spring?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 256. `Какие виды контекстов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 257. `Как создать и поднять контекст для тестирования приложения?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 258. `Какие возможности Spring предоставляет для коммуникации с базой данных?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 259. `Каковы признаки того, что класс Java Bean? Чем POJO отличается от Java Bean?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 260. `Опишите механизм инъекции зависимости в Spring.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 261. `Почему все зависимости Spring есть Java Beans? Возможно ли использовать Spring для управления зависимостями между не Java Beans классами?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 262. `Чем Spring singleton отличается от prototype?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 263. `Есть ли смысл отказываться от использования Dependency Injection?`

Многопоточность


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 264. `Что такое race-condition?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 265. `Какие элементы содержатся в java.util.concurrent пакете?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 266. `Что такое optimistic и pessimistic locking?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 267. `Каковы особенности многопоточности в Java EE и Spring?`

Потоковое API


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 268. `Каковы основные принципы Stream API?`

Практические задачи


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 269. `Реализовать сервис, который на вход принимает url и возвращает краткую версию (вроде bit.ly/86gfr3 ).`


# 2 Блок вопросов



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 270. `Каковы основные особенности Java?`
+ `Объектно-ориентированный`: Java — это объектно-ориентированный язык, в котором все делается с учетом объектов (данных).

+ `Простота`: Java очень легко изучить и использовать. Его синтаксис очень прост. Любой программист, имеющий некоторые базовые знания о любых объектно-ориентированных языках, таких как C++, может легко освоить Java.

+ `Независимая от платформы`: Java — это язык для написания один раз, запускаемый везде. Это означает, что Java-программа, написанная на одной платформе, может быть запущена на любых других платформах без особых трудностей.

+ `Защищенный`: Java — это язык с высокой степенью защиты, с помощью которого вы можете разрабатывать безвирусные и высокозащищенные приложения.

+ `Надежность`: Java является надежной благодаря автоматической сборке мусора, улучшенному механизму обработки исключений и ошибок, отсутствию явного использования указателей и улучшенной системе управления памятью.

+ `Портативный`: Java является переносимым, потому что вы можете запускать байт-код Java на любом оборудовании, имеющем совместимую JVM, которая преобразует байт-код в соответствии с этим конкретным оборудованием.

+ `Многопоточность`: Java поддерживает многопоточное программирование, при котором несколько потоков выполняют свою задачу одновременно.

+ `Распределенной`: Java является распределенным, потому что вы можете разрабатывать распределенные большие приложения, используя такие концепции Java, как RMI и EJB.

+ `Динамический`: Java является динамическим языком, поскольку он поддерживает загрузку классов по запросу.

+ `Расширяемость`: вы можете разрабатывать новые классы, используя существующие интерфейсы, вы можете объявлять новые методы для существующих классов или вы можете разрабатывать новые подклассы для существующих классов. Это все из-за расширяемой природы Java.

+ `Программирование в функциональном стиле`: с введением лямбда-выражений, функциональных интерфейсов и Stream API в Java 8 вы также можете писать функциональный стиль программирования на Java.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 271. `Какая последняя версия Java?`

Java 17 или JDK 17 — это последняя версия Java, выпущенная 14 сентября 2021 г.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 272. `Каковы основные принципы объектно-ориентированного программирования?`

+ Наследование

+ Абстракция

+ полиморфизм

+ Инкапсуляция



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 273. `Что вы подразумеваете под наследованием в Java?`

Наследование является одним из ключевых принципов объектно-ориентированного программирования. Через наследование один класс может наследовать свойства другого класса. Класс, от которого наследуются свойства, называется суперклассом, а класс, от которого наследуются свойства, называется подклассом.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 274. `Какие существуют типы наследования?`
Существует 5 типов наследования.

а) Одиночное наследование: один класс расширяется только одним классом.

б) Многоуровневое наследование: один класс расширяется классом, а этот класс, в свою очередь, расширяется другим классом, образуя таким образом цепочку наследования.

в) Иерархическое наследование: один класс расширяется многими классами.

г) Гибридное наследование: это комбинация вышеуказанных типов наследования.

e) Множественное наследование: один класс расширяет несколько классов. (Java не поддерживает множественное наследование)




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 275. `Поддерживает ли Java множественное наследование? Если нет, то почему?`
Чтобы избежать двусмысленности, сложности и путаницы, Java не поддерживает множественное наследование. т.е. класс в Java не может расширять более одного класса. Например, если класс C расширяет класс A и класс B, которые имеют метод с одинаковым именем, то класс C будет иметь два метода с одинаковыми именами. Это вызывает двусмысленность и путаницу в отношении того, какой метод использовать. Чтобы избежать этого, Java не поддерживает множественное наследование.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 276. `Если Java не поддерживает множественное наследование, то как реализовать множественное наследование в Java?`

Через интерфейсы мы можем реализовать множественное наследование в Java. Класс в Java не может расширять более одного класса, но класс может реализовывать более одного интерфейса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 277. `Что является родительским классом для всех классов в Java?`

java.lang.Object



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 278. `Вы знаете, что все классы в Java унаследованы от класса java.lang.Object. Унаследованы ли интерфейсы от класса java.lang.Object?`

Нет, только классы в Java наследуются от класса java.lang.Object. Интерфейсы в Java не наследуются от класса java.lang.Object. Но классы, реализующие интерфейсы, наследуются от класса java.lang.Object.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 279. `Как вы ограничиваете член класса от наследования его подклассов?`

Объявив этот член как частный. Потому что частные члены не наследуются подклассами.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 280. `Может ли класс расширяться?`

Нет, класс не может расширяться.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 281. `Конструкторы и инициализаторы также наследуются подклассами?`

Нет, конструкторы и инициализаторы (статические инициализаторы и инициализаторы экземпляров) не наследуются подклассами. Но они выполняются при создании экземпляра подкласса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 282. `Что произойдет, если оба, суперкласс и подкласс, имеют поле с одинаковым именем?`

Поле суперкласса будет скрыто в подклассе. Вы можете получить доступ к скрытому полю суперкласса в подклассе, используя ключевое слово super.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 283. `Наследуются ли статические члены подклассам?`

Да, статические члены класса также наследуются подклассами.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 284. `В чем разница между super() и this()?`


super() и this() - это вызовы конструкторов. 

super() вызывает конструктор суперкласса, а this() вызывает другой конструктор того же класса. Обычно super() используется для выполнения общих инициализаций, определенных в суперклассе, в то время как this() используется для вызова других конструкторов текущего класса, обеспечивая возможность перегрузки конструкторов в классе. Если в классе нет явного конструктора, то Java автоматически создаст конструктор без параметров, в котором будет вызван конструктор суперкласса по умолчанию используя super(). Если в классе есть явный конструктор, то Java не создаст конструктор без параметров, и если такой конструктор вызывает super(), то это будет приводить к ошибке компиляции.

super() : это оператор вызова конструктора суперкласса.

this() : это оператор вызова конструктора того же класса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 285. `В чем разница между статическими инициализаторами и инициализаторами экземпляра?`

Статические инициализаторы Инициализаторы экземпляра
Статические инициализаторы выполняются, когда класс загружается в память. Инициализаторы экземпляра выполняются каждый раз, когда создается новый объект класса.
Статические инициализаторы в основном используются для инициализации статических членов или членов класса класса. Инициализаторы экземпляров используются для инициализации нестатических членов или членов экземпляров класса.
Читайте также: Викторина по наследованию Java



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 286. `Как вы создаете экземпляр класса, используя ссылки на методы Java 8?`
```
ClassName::new
```
Вы можете использовать ссылки на конструкторы для создания экземпляра класса в Java 8. Вот несколько примеров:

+ Ссылка на конструктор по умолчанию:
```java
Supplier<MyClass> supplier = MyClass::new;
MyClass instance = supplier.get();
```
+ Ссылка на конструктор с одним параметром:
```java
Function<String, MyClass> function = MyClass::new;
MyClass instance = function.apply("param value");
```
+ Ссылка на конструктор с несколькими параметрами:
```java
BiFunction<String, Integer, MyClass> biFunction = MyClass::new;
MyClass instance = biFunction.apply("param value", 123);
```
Здесь MyClass - это имя вашего класса, и new - это ключевое слово для создания нового экземпляра объекта. Обратите внимание, что вам нужно указать типы параметров конструктора, если их больше, чем один.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 287. `Можно ли создать объект без использования оператора new в Java?`

Да, в Java существует несколько способов создания объектов без использования оператора new:

+ С помощью метода Class.forName(String className).newInstance():
```java
MyClass obj = (MyClass) Class.forName("MyClass").newInstance();
```
+ Использование метода newInstance(). С помощью метода Constructor.newInstance(Object... initargs):
```java
Constructor<MyClass> constructor = MyClass.class.getConstructor();
MyClass obj = constructor.newInstance();
```
+ Использование метода clone(). С помощью метода clone(), если класс реализует интерфейс Cloneable:
```java
MyClass obj1 = new MyClass();
MyClass obj2 = (MyClass) obj1.clone();
```
+ С помощью рефлексии и метода sun.misc.Unsafe.allocateInstance(Class<?> cls), который является не рекомендованным к использованию:
```java
MyClass obj = (MyClass) sun.misc.Unsafe.getUnsafe().allocateInstance(MyClass.class);
```


+ Использование десериализации объекта
```java
ObjectInputStream inStream = new ObjectInputStream(anInputStream );
MyClass object = (MyClass) inStream.readObject();
```

+ Создание строковых и массивных объектов

```java
String s = "string object";
  
int[] a = {1, 2, 3, 4};
```

Есть и другие способы создания объектов, кроме использования оператора new. Но 95% создания объектов в Java выполняется только с помощью нового оператора.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 288.  `Что такое цепочка конструкторов?`

Цепочка конструкторов - это механизм, который позволяет вызывать один конструктор из другого конструктора того же класса при создании объекта. Это позволяет избежать дублирования кода при создании нескольких конструкторов, которые делают похожую работу. Цепочка конструкторов достигается с помощью ключевого слова this.

В примере ниже мы имеем два конструктора с разным количеством аргументов:
```java
public class MyClass {
   private String name;
   private int age;
    
   public MyClass() {
       this("John", 30);
   }
    
   public MyClass(String name, int age) {
       this.name = name;
       this.age = age;
   }
}
```
В этом примере, если мы создаем новый объект MyClass без аргументов, то будет вызван конструктор без аргументов, который использует this("John", 30) для вызова конструктора с аргументами. Это позволяет нам использовать общую логику для обоих конструкторов без повторения кода.

Обратите внимание, что вызов this() должен быть первым оператором в конструкторе. Если этого не сделать, то компилятор выдаст ошибку.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 289. `Можем ли мы вызвать конструктор подкласса из конструктора суперкласса?`

Нет. В Java нет способа вызвать конструктор подкласса из конструктора суперкласса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 290. `Имеют ли конструкторы возвращаемый тип? Если нет, что произойдет, если вы сохраните возвращаемый тип для конструктора?`

Конструкторы возвращаемого типа не имеют. Если вы явно определите возвращаемый тип для конструктора, компилятор не будет считывать это как возвращаемое значение, а вместо этого рассматривает его как обычную функцию, что может привести к ошибкам компиляции.

Поэтому не следует явно указывать возвращаемый тип для конструктора. Конструктор выполняет инициализацию объекта с помощью установки значений полей. Обычно конструкторы не возвращают какие-либо значения, а создают новый объект и модифицируют его поля, чтобы соответствовать заданным значениям параметров конструктора.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 291. `Что такое конструктор без аргументов?`

Конструктор без аргументов - это специальный метод в классе, который не принимает аргументы при создании экземпляра (объекта) этого класса. Он может быть определен явно при написании класса, но если он не определен, то класс по умолчанию имеет конструктор без аргументов.
Конструктор по умолчанию в Java всегда является конструктором без аргументов.

Конструктор без аргументов часто используется для инициализации полей класса со значениями по умолчанию. Например, если у нас есть класс "Человек" (Person) с полями "Имя" (name) и "Возраст" (age), то мы можем использовать конструктор без аргументов для создания объекта "Человек" со значениями по умолчанию:
```java
class Person {
  constructor() {
    this.name = "John Doe";
    this.age = 30;
  }
}

// создаем объект person с помощью конструктора без аргументов
let person = new Person();
```
Это создаст объект "person" типа "Person" с именем "John Doe" и возрастом 30. Если мы хотим создать объект с другими значениями, мы можем использовать конструктор с аргументами, который мы определяем явно в классе, или изменить значения полей объекта после его создания. 

Конструктор по умолчанию в Java всегда является конструктором без аргументов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 292.  `Какая польза от частных конструкторов?`

Частные конструкторы в Java используются для запрета создания объектов класса извне этого класса. Они могут быть полезны, например, когда есть необходимость в том, чтобы объекты класса могли быть созданы только внутри этого класса или его наследников (например, при использовании паттерна проектирования Singleton). 

Также использование частных конструкторов может обеспечить более строгую контрольную точку создания объектов конкретного класса, что позволяет избежать нарушения инкапсуляции и несанкционированного создания объектов. Однако следует учитывать, что объекты класса всегда можно создать изнутри класса, даже если у класса есть частные конструкторы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 293. `Можем ли мы использовать this() и super() в методе?`

Нет, мы не можем использовать this() и super() в методе.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 294. `В чем разница между переменными класса и переменными экземпляра?`

Переменные класса Переменные экземпляра
Переменные класса объявляются с ключевым словом static. Переменные экземпляра объявляются без ключевого слова static.
Переменные класса являются общими для всех экземпляров класса. Эти переменные являются общими для объектов класса. Переменные экземпляра не являются общими для объектов класса. Каждый экземпляр будет иметь свою собственную копию переменных экземпляра.
Поскольку переменные класса являются общими для всех объектов класса, изменения, внесенные в эти переменные в одном объекте, отразятся в другом. Поскольку каждый объект будет иметь свою собственную копию переменных экземпляра, изменения, внесенные в эти переменные через один объект, не будут отражаться в другом объекте.
Доступ к переменным класса можно получить, используя либо имя класса, либо ссылку на объект. Доступ к переменным экземпляра возможен только через ссылку на объект.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 295. `Что перегружает конструктор? Какая польза от перегрузки конструктора?`

Перегрузка конструктора используется для создания нескольких конструкторов в одном классе, каждый из которых может принимать различные наборы параметров. Различные конструкторы могут использоваться для создания объектов класса с разными начальными значениями, в зависимости от потребностей в приложении

Класс может иметь любое количество конструкторов. 

Эти конструкторы будут иметь другой список аргументов. Это называется перегрузкой конструктора. Перегрузка конструктора предоставляет различные способы создания экземпляра класса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 296. `В чем разница между конструктором и методом?`

Конструктор — это специальный член класса, который используется для создания объектов класса. Он особенный, потому что он будет иметь то же имя, что и класс. У него не будет возвращаемого типа.

Метод — это обычный член класса, который используется для реализации некоторого поведения класса. У него будет собственное имя и тип возвращаемого значения.

Основное различие между конструктором и методом в Java заключается в том, что конструкторы всегда имеют тот же самый идентификатор, что и класс, в то время как идентификаторы методов могут быть произвольными. Конструкторы также никогда не возвращают значения, даже типа void, в то время как методы всегда должны возвращать значение или иметь тип void. Пример конструктора и метода в Java:
```java
public class MyClass {
    private int myNumber;

    // Конструктор
    public MyClass(int number) {
        this.myNumber = number;
    }

    // Метод
    public void setNumber(int number) {
        this.myNumber = number;
    }
}
```
Конструктор MyClass принимает один параметр number и устанавливает его в качестве значения поля myNumber. Метод setNumber также устанавливает значение поля myNumber, но может быть вызван в любое время после создания объекта класса при необходимости изменения значения.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 297. `В чем разница между статическими и нестатическими методами?`

Статический метод является общим для всех экземпляров класса. Статические методы хранятся в памяти класса. Где нестатические методы хранятся в памяти объекта. Каждый экземпляр класса будет иметь собственную копию нестатических методов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 298.  `Можем ли мы перегрузить метод main()?`

Да, мы можем перегрузить метод main(). Класс Java может иметь любое количество методов main(). Но для запуска класса Java класс должен иметь метод main() с сигнатурой public static void main(String[] args). Если вы внесете какие-либо изменения в эту сигнатуру, компиляция пройдет успешно. Но вы не можете запустить программу Java. Вы получите ошибку времени выполнения, так как основной метод не найден.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 299. `Можем ли мы объявить метод main() закрытым?`

Нет, метод main() должен быть общедоступным. Вы не можете определить метод main() как частный или защищенный или без модификатора доступа. Это необходимо для того, чтобы сделать метод main() доступным для JVM.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 300. `Можем ли мы объявить метод main() нестатическим?`

Нет, метод main() должен быть объявлен как статический, чтобы JVM могла вызывать метод main() без создания экземпляра своего класса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 301.  `Почему метод main() должен быть статическим?`

Предположим, если main() разрешено быть нестатическим, то при вызове основного метода JVM должна создать экземпляр своего класса. При создании экземпляра он должен вызывать конструктор этого класса. Будет двусмысленность, если конструктор этого класса принимает аргумент, который должен передать JVM аргумента при создании экземпляра класса, содержащего метод main().



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 302.  `Можем ли мы изменить возвращаемый тип метода main()?`

Нет, возвращаемый тип метода main() должен быть только void.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 303.  `Сколько типов модификаторов существует в Java?`

В Java есть два типа модификаторов. Они есть,

Модификаторы доступа
Модификаторы отсутствия доступа

304. `Что такое модификаторы доступа в Java?`

Это модификаторы, которые используются для ограничения видимости класса, поля, метода или конструктора. Java поддерживает 4 модификатора доступа.

а) private: частные поля, методы или конструкторы видны внутри класса, в котором они определены.

б) защищенный: защищенные члены класса видны внутри пакета, но они могут быть унаследованы подклассами за пределами пакета.

c) public : публичные члены видны везде.

d) модификаторы по умолчанию или модификаторы отсутствия доступа: члены класса, которые определены без модификаторов доступа, видны в пакете, в котором они определены.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 305. `Что такое модификаторы отсутствия доступа в Java?`

Это модификаторы, которые используются для достижения функций, отличных от доступности. Например,

a) static : этот модификатор используется для указания того, является ли член членом класса или членом экземпляра.

б) final: используется для ограничения дальнейшей модификации класса, метода или поля. (для получения дополнительной информации о финале, нажмите здесь).

c) abstract : абстрактный класс или абстрактный метод должны быть дополнительно усовершенствованы или изменены. (Чтобы узнать больше об аннотации, нажмите здесь).

г) синхронизированный: используется для обеспечения безопасности потоков. Только один поток может выполнять метод или блок, которые объявлены как синхронизированные в любой момент времени. (для получения дополнительной информации о синхронизации нажмите здесь.)




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 306. `Может ли метод или класс быть окончательными и абстрактными одновременно?`

Нет, это невозможно. Класс или метод не могут быть финальными и абстрактными одновременно. конечное и абстрактное совершенно противоположны по своей природе. окончательный класс или окончательный метод не должны быть изменены дальше, тогда как абстрактный класс или абстрактный метод должны быть изменены дальше.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 307. `Можем ли мы объявить класс закрытым?`

Мы не можем объявить внешний класс как частный. Но мы можем объявить внутренний класс (класс как член другого класса) как частный.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 308. `Можем ли мы объявить абстрактный метод закрытым?`

Нет, абстрактные методы не могут быть приватными. Они должны быть общедоступными, защищенными или заданными по умолчанию, чтобы их можно было изменить в дальнейшем.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 309. `Можем ли мы использовать synchronized ключевое слово с классом?`

Ключевое слово synchronized можно использовать как с методом, так и с блоком.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 310. `Класс не может быть объявлен с ключевым словом synchronized. Тогда почему мы называем такие классы, как Vector, StringBuffer, синхронизированными классами?`

Любые классы, которые имеют только синхронизированные методы и блоки, рассматриваются как синхронизированные классы. Такие классы, как Vector, StringBuffer, имеют только синхронизированные методы. Вот почему они называются синхронизированными классами.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 311. `Что такое приведение типов?`

Когда данные преобразуются из одного типа данных в другой тип данных, это называется преобразованием типов. Приведение типов — это не что иное, как изменение типа данных. Используя приведение типов, изменяется только тип данных, но не сами данные.

(Нажмите здесь для получения дополнительной информации о приведении типов в Java)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 312. `Сколько типов приведения существует в Java?`

Существует два типа:

а) Примитивное приведение: когда данные приводятся из одного примитивного типа (например, int, float, double и т. д.) в другой примитивный тип, это называется примитивным приведением.

б) производное приведение: когда данные преобразуются из одного производного типа в другой производный тип, это называется производным приведением.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 313.  `Что такое автоматическое расширение и явное сужение?`

Данные неявно преобразуются из примитивного типа малого размера в примитивный тип большого размера. Это называется автоматическим расширением. т.е. данные автоматически преобразуются из byte в тип short, из short в int, из int в long, из long в float и из float в double..

Вы должны явно преобразовать данные из примитивного типа большого размера в примитивный тип малого размера. т.е. вы должны явно преобразовать данные из double в float, float в long, long в int, int в short и short в byte. Это называется явным сужением.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 314. `Что такое автоматическое приведение вверх и явное приведение вниз?`

Объект типа подкласса может быть автоматически приведен к типу суперкласса. Это называется автоматическим приведением вверх. Объект типа суперкласса должен быть явно приведен к типу подкласса. Это называется явным приведением вниз.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 315. `Может ли примитивный тип данных int неявно приводиться к производному типу Double?`

Да, сначала int автоматически расширяется до double, а затем double автоматически упаковывается в Double.

double d = 10; //автоматическое расширение от int до double
  
double D = d; //автоматическая упаковка от double до Double



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 316. `Что такое ClassCastException?`

ClassCastException — это исключение, возникающее во время выполнения, когда объект одного типа не может быть приведен к другому типу. (Нажмите здесь, чтобы узнать больше о ClassCastException)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 317. `Что такое бокс и распаковка?`

Упаковка примитивного содержимого в соответствующий объект класса-оболочки называется упаковкой. Развертывание объекта класса-оболочки в соответствующий примитивный контент называется распаковкой.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 318. `В чем разница между авто-расширением, авто-апкастом и авто-боксом?`

Автоматическое расширение происходит, когда примитивный тип небольшого размера преобразуется в примитивный тип большого размера. Автоматическое повышение класса происходит, когда тип подкласса приводится к типу суперкласса. Автоупаковка происходит, когда примитивный тип приводится к соответствующему классу-оболочке.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 319. `Что такое полиморфизм в Java?`

Полиморфизм относится к любому объекту, будь то метод, конструктор или оператор, который принимает множество форм или может использоваться для нескольких задач.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 320.  `Что такое перегрузка методов в Java?`

Когда класс имеет более одного метода с одинаковым именем, но разными параметрами, мы называем эти методы перегруженными. Перегруженные методы будут иметь одно и то же имя, но разное количество аргументов или разные типы аргументов.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 321. `Что такое сигнатура метода? Из каких предметов он состоит?`

Сигнатура метода используется компилятором для различения методов. Подпись метода состоит из трех вещей.

Имя метода
Количество аргументов
Типы аргументов



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 322. `Как компилятор отличает перегруженные методы от повторяющихся?`

Компилятор использует сигнатуру метода, чтобы проверить, является ли метод перегруженным или дублированным. Повторяющиеся методы будут иметь одинаковые сигнатуры методов, т. е. одно и то же имя, одинаковое количество аргументов и одинаковые типы аргументов. Перегруженные методы также будут иметь одно и то же имя, но отличаться количеством аргументов или типами аргументов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 323. `Можем ли мы объявить один перегруженный метод статическим, а другой — нестатическим?`

Да. Перегруженные методы могут быть как статическими, так и нестатическими.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 324. `Возможно ли иметь два метода в классе с одинаковой сигнатурой метода, но разными типами возвращаемого значения?`

Нет, компилятор выдаст ошибку повторяющегося метода. Компилятор проверяет только сигнатуру метода на дублирование, а не возвращаемые типы. Если два метода имеют одинаковую сигнатуру метода, сразу возникает ошибка времени компиляции.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 325. `В MyClass есть метод myMethod с четырьмя различными перегруженными формами. Все четыре разные формы имеют разную видимость — частная, защищенная, общедоступная и стандартная. Правильно ли перегружен myMethod?`

Да. Компилятор проверяет только сигнатуру метода для перегрузки методов, а не видимость методов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 326. `Можно ли синхронизировать перегруженные методы?`

Да. Перегруженные методы можно синхронизировать.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 327. `Можем ли мы объявить перегруженные методы окончательными?`

Да, перегруженные методы могут быть окончательными.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 328. `В приведенном ниже классе перегружен конструктор или перегружен метод?`




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 329. `Перегрузка — лучший пример динамического связывания. Правда или ложь?`

ЛОЖЬ. Перегрузка — лучший пример статического связывания. (Нажмите здесь, чтобы узнать, что такое статическая привязка и что такое динамическая привязка)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 330. `Можно ли переопределить перегруженный метод?`

Да, мы можем переопределить метод, который перегружен в суперклассе.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 331. `Что такое переопределение методов в Java?`

Переопределение методов (method overriding) в Java - это механизм, позволяющий изменять поведение методов в подклассах, которые наследуют методы от своих суперклассов. При переопределении метода в подклассе он должен иметь тот же самый тип возвращаемого значения, список аргументов и модификатор доступа, что и метод в суперклассе.

В подклассе можно использовать ключевое слово @Override для указания того, что метод переопределяет метод суперкласса. Это позволяет компилятору Java проверить, что метод действительно переопределяет метод суперкласса, и выдать ошибку, если это не так.

Например, предположим, у нас есть суперкласс Animal с методом makeSound(), который выводит строку "Animal is making a sound". Мы можем создать подкласс Cat, который наследует метод makeSound() от суперкласса, но переопределяет его, чтобы выводилась строка "Meow!". Вот как это может выглядеть в коде:
```java
class Animal {
  public void makeSound() {
    System.out.println("Animal is making a sound");
  }
}

class Cat extends Animal {
  @Override
  public void makeSound() {
    System.out.println("Meow!");
  }
}
```
Теперь, если мы создадим объект класса Cat и вызовем его метод makeSound(), мы увидим вывод "Meow!" вместо "Animal is making a sound".



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 332. `Какие правила следует соблюдать при переопределении метода?`

Есть 5 основных правил, которые вы должны помнить при переопределении метода. Они есть,

а) Имя метода должно совпадать с именем метода суперкласса.

b) Тип возвращаемого значения переопределяемого метода должен быть совместим с переопределяемым методом. т.е. если метод имеет примитивный тип в качестве типа возвращаемого значения, то он должен быть переопределен только примитивным типом, а если метод имеет производный тип в качестве возвращаемого типа, то он должен быть переопределен тем же типом или типами его подкласса.

c) Вы не должны уменьшать видимость метода при переопределении.

г) Вы не должны изменять список параметров метода при переопределении.

e) Вы не можете увеличить область исключений при переопределении метода с предложением throws.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 333. `Можем ли мы переопределить статические методы?`

Нет, статические методы нельзя переопределить. Если мы попытаемся переопределить их, они будут скрыты в подклассе.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 334. `Что произойдет, если мы изменим аргументы переопределяющего метода?`

Если мы изменим аргументы переопределяющего метода, то этот метод будет рассматриваться как перегруженный, а не переопределенный.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 335. `Можем ли мы переопределить защищенный метод суперкласса как общедоступный метод в подклассе?`

Да. Вы можете увеличить видимость переопределяющих методов, но не можете уменьшить ее.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 336. `Можем ли мы изменить тип возвращаемого значения переопределяющего метода с числового на целочисленный?`

Да. Вы можете изменить, поскольку Integer является подклассом типа Number.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 337. `Можем ли мы переопределить метод суперкласса без предложения throws как метод с предложением throws в подклассе?`

Да, но только с непроверенным типом исключений.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 338. `Можем ли мы изменить исключение метода с предложением throws с SQLException на NumberFormatException при его переопределении?`

Да. Переопределенный метод может генерировать SQLException или исключение его подкласса или любой непроверенный тип исключений.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 339. `Можем ли мы изменить исключение метода с предложением throws с непроверенного на проверенное при его переопределении?`

Нет. Мы не можем изменить исключение метода с предложением throws с непроверенного на проверенное.

(Нажмите здесь, чтобы узнать больше о переопределении методов с помощью предложения throws)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 340. `Как вы ссылаетесь на версию переопределенного метода суперкласса в подклассе?`

Используя ключевое слово super, мы можем ссылаться на версию переопределенного метода суперкласса в подклассе.

341. `Можем ли мы переопределить частные методы?`

Нет вопроса переопределения частных методов. Они вовсе не унаследованы от подкласса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 342. Можем ли мы удалить предложение throws метода при его переопределении?

Да. Вы можете удалить предложение throws метода при его переопределении.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 343.` Можно ли переопределить нестатические методы как статические?`

Нет. Вы не можете переопределить нестатические методы как статические.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 344. `Можем ли мы изменить исключение метода с предложением throws с проверенного на непроверенное при его переопределении?`

Да. Мы можем изменить исключение с проверенного на непроверенное, но обратное невозможно.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 345. `Можем ли мы изменить количество исключений, создаваемых методом с предложением throws, переопределяя его?`

Да, мы можем измениться. Но исключения должны быть совместимы с предложением throws в методе суперкласса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 346. `В чем разница между перегрузкой метода и переопределением метода?`




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 347. `Что такое статическая и динамическая привязка в Java?`





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 348. `Абстрактный класс должен иметь только абстрактные методы. Правда или ложь?`

ЛОЖЬ. Абстрактные методы также могут иметь конкретные методы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 349. `Обязательно ли для класса, который объявлен как абстрактный, иметь хотя бы один абстрактный метод?`

Не обязательно. Абстрактный класс может иметь или не иметь абстрактные методы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 350. `Можем ли мы использовать ключевое слово abstract с конструкторами?`

Нет. Конструктор, статический блок инициализации, блок инициализации экземпляра и переменные не могут быть абстрактными.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 351.` Почему нельзя использовать одновременно final и abstract?`

Потому что конечное и абстрактное совершенно противоположны по своей природе. Окончательный класс или метод не могут быть изменены дальше, тогда как абстрактный класс или метод должны быть изменены дальше. ключевое слово final используется для обозначения того, что класс или метод не нуждается в дальнейших улучшениях. ключевое слово abstract используется для обозначения того, что класс или метод нуждается в дальнейших улучшениях.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 352. `Можем ли мы создать экземпляр класса, который не имеет ни одного абстрактного метода, но объявлен как абстрактный?`

Нет, мы не можем создать экземпляр класса после того, как он объявлен как абстрактный, даже если у него нет абстрактных методов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 353. `Можем ли мы объявить абстрактные методы закрытыми? Обосновать ответ?`

Нет. Абстрактные методы не могут быть приватными. Если абстрактным методам разрешено быть закрытыми, они не будут унаследованы подклассом и не будут улучшены.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 354. `Мы не можем создать экземпляр абстрактного класса. Тогда почему конструкторы разрешены в абстрактном классе?`

Это потому, что мы не можем создавать объекты для абстрактных классов, но мы можем создавать объекты для их подклассов. Из конструктора подкласса будет неявный вызов конструктора суперкласса. Вот почему абстрактные классы должны иметь конструкторы. Даже если вы не напишете конструктор для своего абстрактного класса, компилятор сохранит конструктор по умолчанию.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 355. `Можем ли мы объявить абстрактные методы статическими?`

Нет, абстрактные методы не могут быть статическими.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 356. `Может ли класс содержать абстрактный класс в качестве члена?`

Да, класс может иметь абстрактный класс в качестве члена.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 357. `Абстрактные классы могут быть вложенными. Правда или ложь?`

Истинный. Абстрактные классы могут быть вложенными, т.е. абстрактный класс может иметь в качестве своего члена другой абстрактный класс.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 358. `Можем ли мы объявить абстрактные методы синхронизированными?`

Нет, абстрактные методы нельзя объявлять синхронизированными. Но методы, которые переопределяют абстрактные методы, могут быть объявлены как синхронизированные.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 359. `Можем ли мы объявить локальный внутренний класс абстрактным?`

Да. Локальный внутренний класс может быть абстрактным.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 360. `Может ли объявление абстрактного метода включать предложение throws?`

Да. Абстрактные методы могут быть объявлены с предложением throws.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 361. ` Могут ли абстрактные классы иметь в себе интерфейсы?`

Да, абстрактные классы могут иметь интерфейсы в качестве члена.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 362. `Могут ли интерфейсы иметь конструкторы, статические инициализаторы и инициализаторы экземпляров?`

Нет. Интерфейсы не могут иметь конструкторов, статических инициализаторов и инициализаторов экземпляров.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 363. `Можем ли мы переназначить значение поля интерфейсов?`

Нет. Поля интерфейсов по умолчанию являются статическими и окончательными. Они как константы. Вы не можете изменить их значение после их получения.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 365. `Можем ли мы объявить интерфейс с ключевым словом abstract?`

Да, мы можем объявить интерфейс с помощью ключевого слова abstract. Но не надо так писать. Все интерфейсы в Java по умолчанию абстрактны.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 366. `Для каждого интерфейса в java файл .class будет сгенерирован после компиляции. Правда или ложь?`

Истинный. Файл .class будет сгенерирован для каждого интерфейса после компиляции.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 367. `Можем ли мы переопределить метод интерфейса с видимостью, отличной от общедоступной?`

Нет. При переопределении любых методов интерфейса мы должны использовать только общедоступные. Потому что все методы интерфейса по умолчанию общедоступны, и вы не должны уменьшать видимость при их переопределении.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 368. `Могут ли интерфейсы стать локальными членами методов?`

Нет. Вы не можете определять интерфейсы как локальные члены методов, таких как локальные внутренние классы. Они могут быть частью класса верхнего уровня или интерфейса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 369. `Может ли интерфейс расширять класс?`

Нет, интерфейс не может расширять класс. Но он может расширить другой интерфейс.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 370. `Как и классы, интерфейсы также расширяют класс java.lang.Object по умолчанию?`

Нет. Интерфейсы не расширяют класс Object. (Нажмите здесь, чтобы узнать больше)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 371. `Могут ли интерфейсы иметь статические методы?`

Да, начиная с Java 8 интерфейсы также могут иметь статические методы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 372. `Может ли интерфейс иметь в качестве членов класс или другой интерфейс?`

Да. Интерфейсы могут иметь классы или интерфейсы в качестве членов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 373. `Что такое маркерные интерфейсы? Для чего используются маркерные интерфейсы?`

Щелкните здесь, чтобы узнать об интерфейсах маркеров в Java.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 374. `Какие изменения внесены в интерфейсы по сравнению с Java 8?`




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 375. `Сколько типов вложенных классов существует в Java?`

Java поддерживает 2 типа вложенных классов. Они есть,

а) Статические вложенные классы

б) Нестатические вложенные классы ИЛИ внутренние классы

Нестатические вложенные классы могут быть трех типов,

а) Внутренние классы-члены

б) Локальные внутренние классы

в) Анонимные внутренние классы



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 377. `Можем ли мы получить доступ к нестатическим членам внешнего класса внутри статического вложенного класса?`

Нет, мы не можем получить доступ к нестатическим членам внешнего класса внутри статического вложенного класса. Мы можем получить доступ только к статическим членам внешнего класса внутри статического вложенного класса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 378. `Что такое внутренние классы-члены в Java?`

Внутренние классы-члены — это классы, объявленные как нестатические члены другого класса. Доступ к внутренним классам-членам можно получить только путем создания экземпляра внешнего класса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 379. `Могут ли внутренние классы-члены иметь статические члены?`

Нет, внутренние классы-члены не могут иметь в себе статические члены. Они могут иметь только нестатические члены. Но исключением является статическое и конечное поле. т.е. внутренний класс-член может иметь статическое и конечное поле, но он должен быть инициализирован только во время объявления.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 380. `Можем ли мы получить доступ ко всем членам внешнего класса внутри внутреннего класса?`

Да, мы можем получить доступ ко всем членам, как статическим, так и нестатическим, внешнего класса внутри внутреннего класса-члена.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 381. `Можем ли мы объявить локальные внутренние классы статическими?`

Нет. Локальные внутренние классы не могут быть статическими.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 382. `Можем ли мы использовать локальные внутренние классы вне метода или блока, в котором они определены?`

Нет. Локальные внутренние классы являются локальными для метода или блока, в котором они определены. Мы не можем использовать их вне метода или блока, в котором они определены.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 383. `Можем ли мы объявить локальные внутренние классы как частные, защищенные или общедоступные?`

Нет. Локальные внутренние классы не могут быть объявлены с модификаторами доступа. Они не могут быть частными, защищенными или общедоступными.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 384. `Каково условие использования локальных переменных внутри локального внутреннего класса?`

Условие состоит в том, что локальные переменные должны быть окончательными. Мы не можем использовать неконечные локальные переменные внутри локального внутреннего класса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 385. `Что такое анонимные внутренние классы в Java?`

Анонимные внутренние классы — это внутренние классы без имени. Вы можете создать экземпляр анонимного внутреннего класса только один раз. Щелкните здесь для получения дополнительной информации об анонимных внутренних классах.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 386. `В чем основное различие между статическими и нестатическими вложенными классами?`

Основное различие между статическими и нестатическими вложенными классами заключается в том, что вам не нужно создавать экземпляр внешнего класса для доступа к статическим вложенным классам. Но для доступа к нестатическим вложенным классам необходимо создать экземпляр внешнего класса.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 387. `Для чего используется ключевое слово final в Java?`

Ключевое слово final в Java используется, чтобы сделать любой класс, метод или поле неизменяемым. Вы не можете расширить конечный класс, вы не можете переопределить конечный метод и вы не можете изменить значение конечного поля. ключевое слово final используется для достижения высокого уровня безопасности при кодировании.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 388. `Что такое пустое финальное поле?`

Неинициализированное конечное поле называется пустым конечным полем.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 389. `Можем ли мы изменить состояние объекта, на который указывает конечная ссылочная переменная?`

Да, мы можем изменить состояние объекта, на который указывает конечная ссылочная переменная, но мы не можем переназначить новый объект этой конечной ссылочной переменной.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 390. `В чем основное различие между абстрактными методами и конечными методами?`

Абстрактные методы должны быть переопределены в подклассах, а окончательные методы вообще не подлежат переопределению.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 391. `Какая польза от финального класса?`

Последний класс очень полезен, когда вам нужен высокий уровень безопасности в вашем приложении. Если вы не хотите наследовать определенный класс из соображений безопасности, вы можете объявить этот класс окончательным.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 392. `Можем ли мы изменить значение поля интерфейса? Если нет, то почему?`

Нет, мы не можем изменить значение поля интерфейса. Потому что поля интерфейса по умолчанию финальные и статические. Они остаются постоянными на протяжении всего выполнения программы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 393. `Где вообще мы можем инициализировать final нестатическую глобальную переменную, если она не инициализирована в момент объявления?`

Во всех конструкторах или в любом из блоков инициализации экземпляра.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 394. `Что такое конечный класс, конечный метод и конечная переменная?`

конечный класс -> не может быть расширен.

окончательный метод -> не может быть переопределен в подклассе.

конечная переменная -> не может изменить свое значение после инициализации.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 395. `Где вообще мы можем инициализировать финальную статическую глобальную переменную, если она не инициализирована в момент объявления?`

В любом из статических блоков инициализации.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 396. `Можем ли мы объявить конструкторы окончательными?`

Нет, конструкторы не могут быть окончательными.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 397. `Что такое ArrayStoreException в Java? Когда вы получите это исключение?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 398. `Можно ли передать отрицательное число в качестве размера массива?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 399. `Можно ли изменить размер массива после его определения? ИЛИ Можно ли вставлять или удалять элементы после создания массива?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 400. `Что такое анонимный массив? Приведите пример?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 401. `В чем разница между int[] a и int a[]?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 402. `Есть два объекта массива типа int. один содержит 100 элементов, а другой содержит 10 элементов. Можете ли вы присвоить массив из 100 элементов массиву из 10 элементов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 403. `«int a[] = new int[ 3 ]{1, 2, 3}» — это законный способ определения массивов в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 404. `В чем разница между Array и ArrayList в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 405. `Какие существуют способы копирования массива в другой массив?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 406. `Что такое зубчатые массивы в Java? Приведите пример?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 407. `Как вы проверяете равенство двух массивов в java? ИЛИ Как вы сравниваете два массива в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 408. `Что такое ArrayIndexOutOfBoundsException в Java? Когда это происходит?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 409. `Как вы сортируете элементы массива?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 410. `Как найти пересечение двух массивов в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 411. `Какие существуют способы объявления многомерных массивов в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 412. `Можно ли при создании многомерных массивов указывать измерение массива после пустого измерения?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 413. `Как вы ищете в массиве определенный элемент?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 414. `Какое значение получают элементы массива, если они не инициализированы?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 415. `Как найти повторяющиеся элементы в массиве?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 416. `Какие существуют способы перебора массива в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 417. `Как найти второй по величине элемент в массиве целых чисел?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 418. `Как найти в массиве все пары элементов, сумма которых равна заданному числу?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 419. `Как отделить нули от ненулевых в массиве целых чисел?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 420. `Как найти непрерывный подмассив, сумма которого равна заданному числу?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 421. `Каковы недостатки массивов в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 422. `Является ли String ключевым словом в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 423. `Является ли String примитивным типом или производным типом?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 424. `Сколькими способами можно создавать строковые объекты в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 425. `Что такое пул строковых констант?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 426. `Что особенного в строковых объектах по сравнению с объектами других производных типов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 427. `Что вы подразумеваете под изменяемыми и неизменяемыми объектами?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 428. `Какой последний класс в этих трех классах — String, StringBuffer и StringBuilder?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 429. `В чем разница между String, StringBuffer и StringBuilder?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 430. `Зачем в Java вводятся классы StringBuffer и StringBuilder, когда уже существует класс String для представления набора символов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 431. `Сколько объектов будет создано в следующем коде и где они будут храниться в памяти?`
```java
Строка s1 = "abc";
  
Строка s2 = "abc";
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 432. `Как вы создаете изменяемые строковые объекты?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 433. `Какой из методов «==» и equals() вы предпочтете для сравнения двух строковых объектов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 434. `Какой класс из классов String, StringBuffer и StringBuilder вы рекомендуете, если мне нужны изменяемые и потокобезопасные объекты?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 435. `Как преобразовать заданную строку в массив символов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 436. `Сколько объектов будет создано в следующем коде и где они будут храниться?`
```java
Строка s1 = новая строка ("abc");
  
Строка s2 = "abc";
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 437. `Где именно в памяти находится пул строковых констант?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 438. `Я выполняю множество конкатенаций и модификаций строк в своем коде. какой класс среди строк, StringBuffer и StringBuilder улучшает производительность моего кода. Помните, мне также нужен многопоточный код?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 439. `Что такое строковый стажер?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 440. `В чем основное различие между строками Java и строками C, C++?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 441. `Сколько объектов будет создано в следующем коде и где они будут храниться?`
```java
Строка s1 = новая строка ("abc");
  
Строка s2 = новая строка ("abc");
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 442. `Можем ли мы вызывать методы класса String, используя строковые литералы?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 443. `Вы хоть представляете, почему в Java строки стали неизменяемыми?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 444. `Что вы думаете о пуле строковых констант? Почему они предоставили этот пул, поскольку мы можем хранить строковые объекты в самой памяти кучи?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 445. `В чем сходство и различие между классом String и StringBuffer?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 446. `В чем сходство и различие между классами StringBuffer и StringBuilder?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 447. `Как подсчитать количество вхождений каждого символа в строку?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 448. `Как удалить все пробелы из строки в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 449. `Как найти повторяющиеся символы в строке?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 450. `Написать программу на Java, чтобы перевернуть строку?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 451. `Напишите программу на Java, чтобы проверить, являются ли две строки анаграммой или нет?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 452. `Напишите программу на Java, чтобы перевернуть заданную строку с сохранением положения пробелов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 453. `Как вы конвертируете строку в целое число и целое число в строку в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 454. `Написать код, чтобы доказать, что строки неизменяемы в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 455. `Напишите код для проверки того, является ли одна строка вращением другой?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 456. `Написать Java-программу, переворачивающую каждое слово заданной строки?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 457. `Распечатать все подстроки строки в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 458. `Вывести общие символы между двумя строками в алфавитном порядке в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 459. `Как найти максимальное количество символов в строке в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 460. `В чем разница между Java 8 StringJoiner, String.join() и Collectors.joining()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 461. `Как перевернуть предложение слово за словом в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 462. `Что такое многопоточное программирование? Поддерживает ли Java многопоточное программирование? Объясните на примере?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 463. `Сколькими способами можно создавать потоки в Java? Что это? Объясните на примерах?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 464. `Сколько типов потоков существует в Java? Объяснять?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 465. `Каков статус демона потока по умолчанию? Как вы это проверяете?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 466. `Можете ли вы преобразовать пользовательский поток в поток демона и наоборот? Объяснить на примере?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 467. `Можно ли дать имя нити? Если да, то как вы это делаете? Каким будет имя потока по умолчанию, если вы не назовете поток?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 468. `Можем ли мы изменить название основного потока? Если да, то как?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 469. `Могут ли два потока иметь одно и то же имя? Если да, то как определить потоки с одинаковыми именами?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 470. `Что такое MIN_PRIORITY, NORM_PRIORITY и MAX_PRIORITY?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 471. `Каков приоритет потока по умолчанию? Можем ли мы изменить это? Если да, то как?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 472. `Каков приоритет основного потока? Можем ли мы изменить это?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 473. `Какова цель метода Thread.sleep()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 474. `Можете ли вы сказать, какой поток перейдет в спящий режим после вызова myThread.sleep(5000) в приведенной ниже программе? это основной поток или myThread?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 475. `Освобождает ли поток удерживаемую им блокировку, когда он уходит в спящий режим?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 476. `Какова цель метода join()? Объясните на примере?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 477. `Что вы подразумеваете под синхронизацией? Объясните на примере?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 478. `Что такое блокировка объекта или монитор?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 479. `Я хочу, чтобы синхронизировалась только часть метода, а не весь метод? Как этого добиться?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 480. `Какая польза от синхронизированных блоков?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 481. `Что такое мьютекс?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 482. `Можно ли сделать конструкторы синхронизированными?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 483. `Можем ли мы использовать ключевое слово synchronized с переменными?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 484. `Как вы знаете, синхронизированные статические методы требуют блокировки на уровне класса, а синхронизированные нестатические методы требуют блокировки на уровне объекта. Можно ли запустить эти два метода одновременно?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 485. `Если конкретный поток пойман с исключениями при выполнении синхронизированного метода, освобождает ли выполняющийся поток блокировку или нет?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 486. `Синхронизированные методы или синхронизированные блоки — что вы предпочитаете?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 487. `Что такое взаимоблокировка в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 488. `Как вы программно обнаруживаете заблокированные потоки в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 489. `Что вы знаете о порядке блокировки и времени ожидания блокировки?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 490. `Как избежать тупика? Подскажите пару советов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 491. `Как потоки взаимодействуют друг с другом в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 492. `В чем разница между методами wait() и sleep() в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 493. `В чем разница между notify() и notifyAll() в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 494. `Хотя они используются для связи между потоками, почему методы wait(), notify() и notifyAll() включены в класс java.lang.Object, а не в класс java.lang.Thread?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 495. `Что вы знаете о методе interrupt()? Почему он используется?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 496. `Как проверить, прерван ли поток?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 497. `В чем разница между методами isInterrupted() и interrupted()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 498. `Может ли поток прервать сам себя? Разрешено ли это в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 499. `Объясните жизненный цикл потока? ИЛИ Объяснить состояния потоков в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 500. `В каком состоянии будут заблокированные потоки?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 501. `В чем разница между состояниями ЗАБЛОКИРОВАНО и ОЖИДАНИЕ?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 502. `В чем разница между состояниями WAITING и TIMED_WAITING?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 503. `Можем ли мы вызвать метод start() дважды?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 504. `В чем разница между вызовом метода start() и вызовом метода run() напрямую, так как в любом случае метод start() внутренне вызывает метод run()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 505. `Как остановить нить?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 506. `Предположим, что есть два потока T1 и T2, выполняющие свою задачу одновременно. Если в T1 возникнет исключение, повлияет ли оно на выполнение T2 или оно будет выполняться нормально?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 507. `Какой из способов лучше реализовать потоки в Java? Использует ли он класс Thread или интерфейс Runnable?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 508. `В чем разница между программой, процессом и потоком?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 509. `В чем разница между потоками пользователя и потоками демона?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 510. `Какая польза от групп потоков в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 511. `Что такое группа потоков основного потока?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 512. `Что делают методы activeCount() и activeGroupCount()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 513. `Что вы думаете о Java после Java 8? Это все еще объектно-ориентированный язык или он превратился в язык функционального программирования?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 514. `Каковы три основные особенности Java 8, которые делают Java функциональным языком программирования?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 515. `Что такое лямбда-выражения? Как эта функция изменила способ написания кода на Java? Объясните с некоторыми примерами до Java 8 и после Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 516. `Как определяется сигнатура лямбда-выражений?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 517. `Как компилятор определяет возвращаемый тип лямбда-выражения?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 518. `Можем ли мы использовать неконечные локальные переменные внутри лямбда-выражения?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 519. `Каковы преимущества лямбда-выражений?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 520. `Какие функциональные интерфейсы? Существуют ли они до Java 8 или это совершенно новые функции, представленные в Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 521. `Какие новые функциональные интерфейсы появились в Java 8? В какой упаковке они хранились?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 522. `В чем разница между Predicate и BiPredicate?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 523. `В чем разница между функцией и бифункцией?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 524. `Какой функциональный интерфейс вы используете, если хотите выполнить какие-то операции над объектом и ничего не вернуть?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 525. `Какой функциональный интерфейс лучше всего подходит для операции создания новых объектов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 526. `Когда вы используете интерфейсы UnaryOperator и BinaryOperator?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 527. `Наряду с функциональными интерфейсами, поддерживающими типы объектов, в Java 8 представлены функциональные интерфейсы, поддерживающие примитивные типы. Например, Consumer для объектных типов и intConsumer, LongConsumer, DoubleConsumer для примитивных типов. Как вы считаете, нужно ли вводить отдельные интерфейсы для примитивных типов и объектных типов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 528. `Как взаимосвязаны функциональные интерфейсы и лямбда-выражения?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 529. `Что такое ссылки на методы? Какая от них польза?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 530. `Каков другой синтаксис ссылок на методы Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 531. `Какие основные изменения произошли в интерфейсах по сравнению с Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 532. `Каковы методы интерфейса по умолчанию? Почему они вводятся?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 533. `Поскольку интерфейсы также могут иметь конкретные методы из Java 8, как вы решаете проблему алмаза, то есть конфликт классов, наследующих несколько методов с одной и той же сигнатурой?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 534. `Почему статические методы вводятся в интерфейсы из Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 535. `Что такое потоки? Почему они вводятся?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 536. `Можем ли мы рассматривать потоки как еще один тип структуры данных в Java? Обосновать ответ?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 537. `Что такое промежуточные и конечные операции?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 538. `Что вы подразумеваете под конвейером операций? Какая от этого польза?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 539. `«Потоковые операции выполняют итерацию неявно» что это значит?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 540. `Какой тип загрузки ресурсов поддерживают потоки Java 8? Ленивая загрузка ИЛИ нетерпеливая загрузка?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 541. `Что такое операции короткого замыкания?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 542. `Какие операции выбора доступны в Java 8 Stream API?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 543. `Какие операции сортировки доступны в потоках Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 544. `Что такое редуцирующие операции? Назовите операции сокращения, доступные в потоках Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 545. `Какие операции сопоставления доступны в потоках Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 546. `Какие операции поиска/нахождения доступны в потоках Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 547. `Назовите операции отображения, доступные в потоках Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 548. `В чем разница между map() и flatMap()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 549. `В чем разница между limit() и skip()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 550. `В чем разница между findFirst() и findAny()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 551. `Знакомы ли вы с методом Stream.collect(), интерфейсом Collector и классом Collectors? Какова связь между ними?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 552. `Назовите любые 5 методов класса Collectors и их использование?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 553. `В чем разница между коллекциями и потоками?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 554. `Какова цель необязательного класса Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 555. `В чем разница между Spliterator Java 8 и итераторами, доступными до Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 556. `В чем разница между Java 8 StringJoiner, String.join() и Collectors.joining()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 557. `Назовите три важных класса API даты и времени Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 558. `Как получить текущую дату и время с помощью функций Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 559. `Имея список студентов, напишите код Java 8, чтобы разделить студентов, набравших более 60%, от тех, кто этого не сделал?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 560. `Имея список студентов, напишите код Java 8, чтобы получить имена трех лучших студентов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 561. `Имея список учеников, как узнать имя и процент каждого ученика?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 562. `Учитывая список студентов, как вы получаете предметы, предлагаемые в колледже?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 563. `Учитывая список студентов, напишите код Java 8, чтобы получить самый высокий, самый низкий и средний процент студентов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 564. `Как получить общее количество студентов из заданного списка студентов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 565. `Как из заданного списка студентов сгруппировать студентов по предметам?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 566. `Учитывая список сотрудников, напишите код Java 8 для подсчета количества сотрудников в каждом отделе?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 567. `Учитывая список служащих, найдите среднюю заработную плату служащих мужского и женского пола?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 568. `Напишите код Java 8, чтобы получить данные о самом высокооплачиваемом сотруднике в организации из заданного списка сотрудников?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 569. `Написать код Java 8, чтобы получить средний возраст каждого отдела в организации?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 570. `Учитывая список сотрудников, как узнать, кто является самым старшим сотрудником в организации?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 571. `Учитывая список сотрудников, получить данные о самом молодом сотруднике в организации?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 572. `Как получить количество сотрудников в каждом отделе, если вы дали список сотрудников?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 573. `Учитывая список сотрудников, узнать количество сотрудников мужского и женского пола в организации?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 574. `Что такое исключение?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 575. `Как обрабатываются исключения в Java? ИЛИ Объяснить механизм обработки исключений в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 576. `В чем разница между ошибкой и исключением в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 577. `Можем ли мы оставить другие операторы между блоками try, catch и finally?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 578. `Можем ли мы написать только блоки try без блоков catch и finally?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 579. `В блоке try есть три оператора — оператор1, оператор2 и оператор3. После этого есть блок catch для перехвата исключений, возникших в блоке try. Предположим, что исключение произошло в операторе2. Выполняется ли оператор 3 или нет?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 580. `Что такое недостижимая ошибка блока catch?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 581. `Объясните иерархию исключений в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 582. `Что такое исключения во время выполнения в Java. Приведите пример?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 583. `Что такое OutOfMemoryError в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 584. `что такое проверяемые и непроверяемые исключения в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 585. `В чем разница между ClassNotFoundException и NoClassDefFoundError в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 586. `Можем ли мы сохранить операторы после блока finally, если управление возвращается из самого блока finally?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 587. `Выполняется ли блок finally, если блоки try или catch возвращают управление?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 588. `Можем ли мы создать исключение вручную? Если да, то как?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 589. `Что такое повторное создание исключения в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 590. `Для чего используется ключевое слово throws в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 591. `Почему всегда рекомендуется, чтобы операции очистки, такие как закрытие ресурсов БД, оставались внутри блока finally?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 592. `В чем разница между final, finally и finalize в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 593. `Как вы создаете настраиваемые исключения в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 594. `Что такое ClassCastException в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 595. `В чем разница между throw, throws и throwable в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 596. `Что такое StackOverflowError в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 597. `Можем ли мы переопределить метод суперкласса, который генерирует непроверенное исключение с проверенным исключением в подклассе?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 598. `Что такое связанные исключения в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 599. `Какой класс является суперклассом для всех типов ошибок и исключений в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 600. `Каковы допустимые комбинации блоков try, catch и finally?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 601. `Какая польза от метода printStackTrace()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 602. `Приведите несколько примеров проверенных исключений?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 603. `Приведите несколько примеров непроверенных исключений?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 604. `Знаете ли вы блоки try-with-resources? Почему мы их используем? Когда они вводятся?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 605. `Каковы преимущества попытки использования ресурсов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 606. `Какие изменения внесены в обработку исключений по сравнению с Java 7?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 607. `Какие улучшения внесены в попытку с ресурсами в Java 9?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 608. `Что такое Java Collection Framework? Почему вводится?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 609. `Что такое интерфейс корневого уровня в структуре сбора Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 610. `Каковы четыре основных интерфейса платформы сбора данных Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 611. `Объясните иерархию классов в структуре сбора Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 612. `Почему карта не наследуется от интерфейса коллекции, хотя она является частью структуры коллекции Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 613. `Что такое итерируемый интерфейс?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 614. `Каковы характеристики Листа?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 615. `Каковы основные реализации интерфейса списка?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 616. `Каковы характеристики ArrayList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 617. `Какие три интерфейса маркеров реализованы в ArrayList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 618. `Какова начальная емкость ArrayList по умолчанию?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 619. `В чем главный недостаток ArrayList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 620. `В чем разница между массивом и ArrayList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 621. `Чем Vector отличается от ArrayList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 622. `Почему не рекомендуется использовать класс Vector в вашем коде?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 623. `В чем разница между ArrayList и Vector?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 624. `Каковы характеристики очереди?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 625. `Упомяните важные методы Queue?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 626. `Чем Очередь отличается от Списка?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 627. `Какой популярный тип коллекции реализует и список, и очередь?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 628. `Каковы характеристики LinkedList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 629. `В чем разница между ArrayList и LinkedList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 630. `Что такое PriorityQueue?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 631. `Что такое Deque и ArrayDeque? Когда они представлены в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 632. `Каковы характеристики наборов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 633. `Каковы основные реализации интерфейса Set?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 634. `В чем разница между списком и набором?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 635. `Каковы характеристики HashSet?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 636. `Как HashSet работает внутри Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 637. `Каковы характеристики LinkedHashSet?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 638. `Когда вы предпочитаете LinkedHashSet вместо HashSet?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 639. `Как LinkedHashSet работает внутри Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 640. `Что такое SortedSet? Приведите пример?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 641. `Что такое NavigableSet? Приведите один пример?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 642. `Каковы характеристики TreeSet?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 643. `Чем HashSet, LinkedHashSet и TreeSet отличаются друг от друга?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 644. `В чем разница между Iterator и ListIterator?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 645. `Чем интерфейс Map отличается от других трех основных интерфейсов среды сбора Java — List, Set и Queue?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 646. `Каковы популярные реализации интерфейса Map?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 647. `Каковы характеристики HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 648. `Как HashMap работает внутри Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 649. `Что такое хеширование?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 650. `Какова начальная емкость HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 651. `Каков коэффициент загрузки HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 652. `Каков порог HashMap? Как он рассчитывается?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 653. `Что такое перефразирование?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 654. `Как начальная емкость и коэффициент загрузки влияют на производительность HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 655. `В чем разница между HashSet и HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 656. `В чем разница между HashMap и HashTable?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 657. `Как удалить повторяющиеся элементы из ArrayList в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 658. `Какой тип коллекции вы мне предложите, если я хочу отсортированную коллекцию объектов без дубликатов?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 659. `В чем разница между Fail-Fast Iterators и Fail-Safe Iterators?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 660. `Как вы конвертируете массив в ArrayList и ArrayList в массив?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 661. `В чем разница между Сбором и Сбором?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 662. `Чем коллекции отличаются от потоков Java 8?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 663. `Как вы конвертируете HashMap в ArrayList в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 664. `Что делают методы keySet(), values() и entrySet()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 665. `В чем разница между Iterator и Java 8 Spliterator?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 666. `Как сортировать ArrayList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 667. `В чем разница между HashMap и ConcurrentHashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 668. `Как вы делаете коллекции доступными только для чтения или немодифицируемыми?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 669. `Как вы обращаете ArrayList в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 670. `В чем разница между синхронизированными HashMap, HashTable и ConcurrentHashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 671. `Как вы сортируете HashMap по ключам?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 672. `Как вы сортируете HashMap по значениям?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 673. `Как объединить две карты с одинаковыми ключами?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 674. `Что вы знаете о неизменяемых коллекциях Java 9? Чем они отличаются от неизменяемых коллекций, возвращаемых методами оболочки коллекций?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 675. `Что вы знаете о методах Java 10 List.copyOf(), Set.copyOf() и Map.copyOf()? Почему они вводятся?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 676. `В чем разница между перечислением и итератором?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 677. `Что относится к типу RandomAccess — ArrayList, LinkedList, HashSet и HashMap?.`


# 3 Блок вопросов
Содержание:

1. Типы данных, переменные, операторы, циклы, массивы
2. ООП
3. Исключения
4. Коллекции
5. Строки
6. Потоки ввода/вывода
7. Потоки выполнения/многопоточность



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1. Типы данных, переменные, операторы, циклы, массивы (перейти в раздел)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 678. `Сколько ключевых слов зарезервировано языком, что это за слова, какие из них не используются?`
В языке Java зарезервировано 50 ключевых слов, которые не могут быть использованы как имена переменных, методов и т. д. Вот список этих слов:

abstract, assert, boolean, break, byte, case, catch, char, class, const (unused), continue, default, do, double, else, enum, extends, false, final, finally, float, for, goto (unused), if, implements, import, instanceof, int, interface, long, native, new, null, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, true, try, void, volatile, while

Слова const и goto зарезервированы, но не используются в настоящее время в языке Java.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 679. `Из каких символов может состоять имя переменной (корректный идентификатор)?`

Имя переменной в Java может состоять из букв любого регистра (a-z, A-Z), цифр (0-9), символа подчёркивания (_) и знака доллара ($). Однако, имя переменной не должно начинаться с цифры и не должно совпадать с ключевым словом языка Java. Кроме того, в Java принято использовать camelCase для именования переменных (например, myVariableName), чтобы переменные были легко читаемыми и понятными.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 680. `Что значит слово “инициализация”?`

Инициализация - это процесс присвоения начального значения переменной при объявлении или до первого использования переменной. Присваивание начального значения переменной при объявлении называется "полями класса инициализации", а присваивание начального значения локальной переменной перед ее первым использованием называется "инициализацией переменной".
Поля класса могут инициализироваться явно, как например:
```java
public class MyClass {
    int x = 5;
}
```
Или могут быть инициализированы в блоке инициализации:
```java
public class MyClass {
    int x;
    {
        x = 5;
    }
}
```
Локальные переменные должны быть инициализированы перед использованием, например:
```java
public class MyClass {
    public void myMethod() {
        int x = 5; // переменная x должна быть инициализирована перед использованием
        System.out.println(x);
    }
}
```
Иначе компилятор Java выдаст ошибку компиляции.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 681. `На какие основные группы можно поделить типы данных?`
В Java типы данных можно поделить на примитивные (primitive data types) и ссылочные (reference data types). К примитивным типам данных относятся:

+ byte
+ short
+ int
+ long
+ float
+ double
+ boolean
+ char

Эти типы данных хранятся в стеке и могут быть использованы для простого хранения целых, вещественных и логических значений.

Кроме того, существуют также ссылочные типы данных, такие как классы, массивы и перечисления. Эти типы данных хранятся в куче и представляют более сложные структуры данных, состоящие из различных примитивных типов данных и ссылок на другие объекты.

В целом, основным критерием разделения типов данных в Java является то, где они хранятся в памяти и как они могут быть использованы в программах.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 682. `Какие примитивные типы вы знаете?`
В Java есть 8 примитивных типов данных: byte, short, int, long, float, double, char, boolean.

+ `byte` - 8-битное целое число со знаком в диапазоне от -128 до 127
+ `short` - 16-битное целое число со знаком в диапазоне от -32768 до 32767
+ `int` - 32-битное целое число со знаком в диапазоне от -2147483648 до 2147483647
+ `long` - 64-битное целое число со знаком в диапазоне от -9223372036854775808 до 9223372036854775807
+ `float` - 32-битное число с плавающей точкой
+ `double` - 64-битное число с плавающей точкой
+ `char` - 16-битный Unicode символ
+ `boolean` - логический тип данных, который может принимать значение true или false

Примеры объявления переменных с примитивными типами данных в Java:
```java 
byte b = 10;
short s = 20;
int i = 100;
long l = 1000000L;
float f = 1.5f;
double d = 3.14159;
char c = 'A';
boolean bool = true;
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 683. `Что вы знаете о преобразовании примитивных типов данных, есть ли потеря данных, можно ли преобразовать логический тип?`

В языке Java есть возможность преобразования примитивных типов данных из одного типа в другой. Это может потребоваться, например, для выполнения арифметических операций, когда операнды имеют разные типы данных.

При преобразовании типов данных может происходить потеря данных, если значение, которое мы пытаемся преобразовать, выходит за пределы допустимого диапазона целевого типа. Например, при преобразовании числа типа int в тип byte могут потеряться старшие биты числа, что приведет к изменению его значения.

В языке Java также есть возможность преобразования логического типа данных boolean в другие типы данных и наоборот. При этом значение true преобразуется в число 1, а значение false в число 0.

Вот примеры преобразований между типами данных в Java:
```java
int i = 42;
long l = i; // автоматическое преобразование типов данных

double d = 3.14;
int j = (int) d; // явное преобразование типов данных

boolean b = true;
int k = b ? 1 : 0; // преобразование логического типа данных в число
```

При преобразовании типов данных может потребоваться явное преобразование или приведение типов, чтобы избежать потери данных.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 684. `Какими значениями инициализируются переменные по умолчанию?`

В Java, переменные по умолчанию инициализируются следующим образом:

Числовые типы (byte, short, int, long, float, double) и тип char инициализируются нулевым значением (0 или 0.0).

Логический тип (boolean) инициализируется значением false.

Типы-объекты (Object) инициализируются значением null.

Локальные переменные (включая параметры методов) не инициализируются автоматически по умолчанию, поэтому они должны быть явно проинициализированы перед использованием в коде.

Пример:
```java
public class MyClass {
  int myInt;
  double myDouble;
  boolean myBoolean;
  Object myObject;
  
  public static void main(String[] args) {
    MyClass example = new MyClass();
    
    System.out.println(example.myInt); // 0
    System.out.println(example.myDouble); // 0.0
    System.out.println(example.myBoolean); // false
    System.out.println(example.myObject); // null
  }
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 685. `Как передается значение переменной (по ссылке/значению)?`

В Java все передается по значению, даже объекты передаются по значению ссылки на них. Это значит, что когда вы передаете переменную в метод, то передается ее значение, которое можно изменять внутри метода, но наружу метода это не влияет. Однако, если переменная ссылается на объект, то передается копия ссылки на объект, который находится в хипе, а не сам объект. Таким образом, если вы изменяете объект в методе, то эти изменения будут видны наружу метода, потому что ссылки снаружи и внутри метода указывают на один и тот же объект в хипе.

Например, рассмотрим класс Person:
```java
class Person {
   private String name;
   
   public void setName(String name) {
      this.name = name;
   }
   
   public String getName() {
      return name;
   }
}
```
Теперь вызовем метод, который изменяет значение поля name переданного объекта:
```java
public static void changeName(Person p) {
   p.setName("John");
}
```
Используя этот метод можно изменить имя объекта p, который был передан в метод:
```java
Person p = new Person();
p.setName("Tom");
System.out.println(p.getName());  // output: Tom
changeName(p);
System.out.println(p.getName());  // output: John
```
Как видно, имя объекта p было изменено в методе changeName, но эти изменения были видны и при обращении к объекту p снаружи метода.

Любые примитивные типы передаются по значению, если вы попытаетесь изменить их значение в методе, то это никак не отразится на оригинальном значении.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 686. `Что вы знаете о функции main, какие обязательные условия ее определения?`

Функция main в языке Java является точкой входа в программу, которая выполняется при запуске приложения. Она обязательно должна иметь следующую сигнатуру:
```java
public static void main(String[] args)
```
где public означает , что функция доступна для вызова из любой части программы, static означает, что функция является статической и может вызываться без создания экземпляра класса, void указывает на то, что функция не возвращает значение, а String[] args представляет массив аргументов командной строки.

Таким образом, функция main должна быть обязательно определена в классе, который является точкой входа в программу. Этот класс должен быть публичным и содержать статический метод main. Аргументы командной строки, передаваемые в функцию main, можно использовать для конфигурирования приложения или передачи данных при запуске программы.

Например:
```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
```
Этот код определяет класс Main с публичным, статическим методом main , который выводит сообщение "Hello World!" в консоль при запуске программы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 687. `Какие логические операции и операторы вы знаете?`

В Java есть три логических оператора: && для логического "и" (and), || для логического "или" (or) и ! для логического отрицания (not). Операторы && и || выполняются по правилу "ленивого вычисления" (short-circuiting), то есть если результат выражения может быть определен на основе первого операнда, то второй операнд не вычисляется. Кроме того, в Java есть битовые операторы & (and), | (or) и ^ (xor), которые могут быть применены к целочисленным типам и перечилям (enum).

Примеры использования логических операторов:
```java
int x = 10, y = 5;

if (x > 5 && y < 10) {
    // выполняется, если x > 5 И y < 10
}

if (x > 5 || y < 2) {
    // выполняется, если x > 5 ИЛИ y < 2
}

if (!(x > 5)) {
    // выполняется, если x НЕ больше 5
}
```
Примеры использования битовых операторов:
```java
int x = 5, y = 3;
int z = x & y;  // результат: 1 (бинарное 01 & 11 = 01)
z = x | y;      // результат: 7 (бинарное 01 | 11 = 11)
z = x ^ y;      // результат: 6 (бинарное 01 ^ 11 = 10)
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 688.  `В чем разница краткой и полной схемы записи логических операторов?`

В Java есть два способа записи логических операторов: краткая форма (&& и ||) и полная форма (& и |).

Краткая форма используется для выполнения логических операций над булевыми операндами и имеет более высокий приоритет. Кроме того, в краткой форме операнды вычисляются лениво, то есть второй операнд не вычисляется, если первый операнд уже дает конечный результат.

Полная форма используется для выполнения логических операций над целочисленными значениями и не ленивая. Оба операнда всегда вычисляются.

Вот пример кода, который иллюстрирует разницу между этими двумя формами записи:
```java
boolean a = true;
boolean b = false;
boolean c = true;
boolean d = false;
boolean result;

// Краткая форма, дает true, так как a и b оба являются false; операнда b не вычисляется, т.к. первый операнд уже даёт конечный результат
result = a && b;
System.out.println(result);  // Вывод: false

// Полная форма, результат такой же, но оба операнда вычисляются
result = a & b;
System.out.println(result);  // Вывод: false

// Краткая форма, дает true, так как хотя бы один из операндов (c) является true; операция вычисляется лениво
result = c || d;
System.out.println(result);  // Вывод: true

// Полная форма, результат такой же, но оба операнда вычисляются
result = c | d;
System.out.println(result);  // Вывод: true
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 689. `Что такое таблица истинности?`
Таблица истинности - это таблица, которая отображает значения логических выражений в зависимости от значений их компонентов (входов). В контексте программирования на Java, это может быть полезным для понимания логических операций, таких как операторы И (&&), ИЛИ (||) и НЕ (!).

Таблица истинности в Java показывает все возможные комбинации значений исходных данных и вычисленные результаты. 
|   A   	|   B   	| A \| B 	| A & B 	| A ^ B 	|   !A  	|
|:-----:	|:-----:	|:------:	|:-----:	|:-----:	|:-----:	|
| false 	| false 	| false  	| false 	| false 	| true  	|
| true  	| false 	| true   	| false 	| true  	| false 	|
| false 	| true  	| true   	| false 	| true  	| true  	|
| true  	| true  	| true   	| true  	| false 	| false 	|

Таблица истинности может быть полезной для проверки правильности логических выражений и операторов в Java. Вы можете использовать таблицу истинности, чтобы определить, какие значения будут возвращены при заданных исходных данных, или для проверки, будет ли выражение возвращать ожидаемый результат.

Например, если учитывать таблицу истинности оператора &&, то true && true вернет true, тогда как false && true или true && false вернут false.

В целом, таблица истинности полезна для проверки логических операторов и выражений в Java, и может помочь избежать ошибок в программировании.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 690.  `Что такое тернарный оператор выбора?`

Тернарный оператор выбора - это сокращенная форма записи условного оператора if-else в Java. Он позволяет сократить код и улучшить его читаемость, особенно если необходимо присвоить переменной значение в зависимости от некоторого условия.

Синтаксис тернарного оператора выбора:
```java
условие ? выражение1 : выражение2
```
Если условие верно, тогда возвращается выражение1, иначе возвращается выражение2.

Например,
```java
int x = 10;
int y = 20;
int max = (x > y) ? x : y;
```
В этом примере, если значение переменной x больше значения переменной y, то переменной max присваивается значение x, иначе переменной max присваивается значение y.

Тернарный оператор выбора можно использовать в любом месте кода, где необходимо выбрать одно из двух значений в зависимости от условия. Он также может использоваться в качестве аргумента в методах и возвращать значение.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 691. `Какие унарные и бинарные арифметические операции вы знаете?`
Для целочисленных типов данных в Java доступны следующие унарные и бинарные арифметические операции:

Унарные операции:

+ `унарный плюс (+)` - не меняет знак числа
+ `унарный минус (-)` - меняет знак числа на противоположный
+ `инкремент (++)` - увеличивает значение переменной на 1
+ `декремент (--)` - уменьшает значение переменной на 1

Бинарные операции:

+ `сложение (+)`
+ `вычитание (-)`
+ `умножение (*)`
+ `деление (/)`
+ `остаток от деления (%)`
+ `побитовое И (&)`
+ `побитовое ИЛИ (|)`
+ `побитовое исключающее ИЛИ (^)`
+ `побитовый сдвиг влево (<<)`
+ `побитовый сдвиг вправо с заполнением нулями (>>)`
+ `побитовый сдвиг вправо с заполнением знаковым битом (>>>)`

В Java также доступны операции сравнения (==, !=, >, >=, <, <=), логические операторы (&&, ||, !) и тернарный оператор (условие ? значение_если_истина : значение_если_ложь).

Некоторые из этих операций также доступны для вещественных типов данных (float и double), однако при работе с вещественными числами наличие округлений может привести к неточным результатам.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 692. `Какие побитовые операции вы знаете?`

В Java есть несколько побитовых операций, которые могут быть полезны при работе с битами двоичных чисел. Некоторые из них перечислены ниже:

+ `& (логическое И)`: возвращает бит 1 только в том случае, если оба операнда имеют значение 1, в противном случае возвращает 0.

+ `| (логическое ИЛИ)`: возвращает бит 1 только в том случае, если хотя бы один из операндов имеет значение 1, в противном случае возвращает 0.

+ `^ (исключающее ИЛИ)`: возвращает бит 1 только в том случае, если только один из операндов имеет значение 1, в противном случае возвращает 0.

+ `~ (унарный оператор НЕ)`: инвертирует значения всех битов операнда.

+ `<< (левый сдвиг)`: сдвигает биты операнда влево на заданное количество позиций.

+ `>> (правый сдвиг с сохранением знака)`: сдвигает биты операнда вправо на заданное количество позиций, при этом знак операнда сохраняется.

+ `>>> (беззнаковый правый сдвиг)`: сдвигает биты операнда вправо на заданное количество позиций, при этом знак операнда не сохраняется.


Примеры:

Побитовый AND (&) - возвращает бит, который установлен в обоих операндах.
```java
int a = 5;
int b = 3;
int c = a & b; // c будет равно 1
```
Побитовый OR (|) - возвращает бит, который установлен хотя бы в одном из операндов. Например:
```java
int a = 5;
int b = 3;
int c = a | b; // c будет равно 7
```
Побитовый XOR (^) - возвращает бит, который установлен только в одном из операндов. Например:
```java
int a = 5;
int b = 3;
int c = a ^ b; // c будет равно 6
```
Побитовый NOT (~) - инвертирует все биты операнда. Например:
```java
int a = 5;
int b = ~a; // b будет равно -6
```
Сдвиг вправо (>>) - сдвигает биты операнда вправо на указанное число позиций. Например:
```java
int a = 10;
int b = a >> 2; // b будет равно 2
```
Сдвиг влево (<<) - сдвигает биты операнда влево на указанное число позиций. Например:
```java
int a = 10;
int b = a << 2; // b будет равно 40
```
Сдвиг вправо с заполнением нулями (>>>) - сдвигает биты операнда вправо на указанное число позиций, при этом заполняет освободившиеся позиции нулями. Например:
```java
int a = -10;
int b = a >>> 2;
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 693. `Какова роль и правила написания оператора выбора (switch)?`

В Java оператор выбора switch используется для проверки значения выражения и выполнения соответствующего блока кода в зависимости от значения этого выражения. Оператор switch следует за ключевым словом switch, которое за ним следует выражение, которое нужно проверить. Затем внутри блока кода switch можно объявить несколько блоков case, каждый из которых содержит значение, с которым нужно сравнить выражение, после которого следует блок кода, который нужно выполнить, если значение выражения соответствует значению case.

Вот пример использования оператора выбора switch в Java:
```java
int day = 3;
String dayName;

switch (day) {
    case 1:
        dayName = "Monday";
        break;
    case 2:
        dayName = "Tuesday";
        break;
    case 3:
        dayName = "Wednesday";
        break;
    case 4:
        dayName = "Thursday";
        break;
    case 5:
        dayName = "Friday";
        break;
    case 6:
        dayName = "Saturday";
        break;
    case 7:
        dayName = "Sunday";
        break;
    default:
        dayName = "Invalid day";
        break;
}

System.out.println(dayName);
```
В этом примере оператор switch проверяет значение переменной day, после чего выполняет соответствующий блок кода. В данном случае переменная day имеет значение 3, поэтому переменная dayName будет установлена на "Wednesday". Если значение day не соответствует ни одному из значений case, выполнится блок кода по умолчанию (default).

Один из важных моментов при использовании оператора switch - не забывать про ключевое слово break для окончания блока case.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 694.  `Какие циклы вы знаете, в чем их отличия?`
В Java существует несколько типов циклов:

+ `Цикл for` - используется, когда необходимо выполнить некоторый код заданное количество раз. For имеет три выражения, разделенных точками с запятой: инициализация, условие и инкремент.

+ `Цикл while` - используется, когда количество итераций неизвестно заранее. Цикл выполняется, пока условие остается истинным.

+ `Цикл do-while` - выполняется до тех пор, пока условие, заданное в while, остается истинным. Этот цикл гарантирует, что код внутри цикла будет выполнен хотя бы один раз.

Вот простой пример каждого:
```java
for (int i = 0; i < 10; i++) {
  System.out.println(i);
}

int i = 0;
while (i < 10) {
  System.out.println(i);
  i++;
}

int j = 0;
do {
  System.out.println(j);
  j++;
} while (j < 10);
```
В этом примере for выполняет код внутри тела цикла 10 раз, пока переменная i не достигнет 10.

While продолжает выполнение, пока переменная i меньше 10.

Do-while также продолжает выполнение, пока переменная j меньше 10, но гарантирует, что код внутри блока do выполнится, как минимум, один раз.

Это основные типы циклов в Java с их основными отличиями.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 695. `Что такое “итерация цикла”?`

"Итерация цикла" в Java означает один проход цикла через тело цикла. Например, в цикле for, каждая итерация выполняет блок кода между открывающей и закрывающей фигурными скобками. Затем проверяется условие цикла и, если оно истинно, выполняется еще одна итерация. Этот процесс продолжается до тех пор, пока условие не станет ложным.

В цикле while и do-while, итерация будет происходить до тех пор, пока условие остается истинным. В случае цикла do-while тело цикла выполнится хотя бы один раз, независимо от того, выполнится ли условие цикла впоследствии.

В циклах for-each каждая итерация перебирает элементы массива или коллекции, к которым она применяется.

Итерация цикла - это основной механизм управления поведением повторяющихся блоков кода в Java и других языках программирования.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 696. `Какие параметры имеет цикл for, можно ли их не задать?`

Цикл for в Java имеет три параметра, разделенных точкой с запятой (;):

+ `Инициализация переменной`. В этом параметре обычно создают переменную и присваивают ей начальное значение.

+ `Условие продолжения цикла`. Это булевское выражение, которое определяет, должен ли продолжаться цикл в текущей итерации или нет. Если условие истинно, то цикл продолжается, если ложно, то цикл завершается.

+ `Выражение обновления`. Это выражение выполняется после каждой итерации цикла перед проверкой условия продолжения. Обычно это выражение используется для изменения значения переменной, созданной в первом параметре.
  
Примеры:

В Java цикл for используется для повторения блока кода заданное количество раз или для прохождения через элементы коллекции или массива. Параметры цикла включают в себя инициализацию счетчика, условие продолжения цикла и выражение обновления счетчика. Вот как выглядит общий синтаксис цикла for в Java:
```java
for (initialization; condition; update) {
    // блок кода для повторения
}
```
Инициализация устанавливает начальное значение для счетчика, например int i = 0. Условие продолжения цикла проверяется на каждой итерации цикла, и если оно истинно, цикл продолжается. Выражение обновления обновляет счетчик на каждой итерации, например i++.

В цикле for можно не задавать все три параметра. Если вам нужно только повторять блок кода определенное количество раз, вы можете опустить условие продолжения. Например, следующий цикл выполнится точно десять раз:
```java
for (int i = 0; i < 10; i++) {
    // блок кода для повторения
}
```
Если вам нужно бесконечно повторять блок кода, вы можете опустить все три параметра:
```java
for (;;) {
    // блок кода для повторения бесконечного количества раз
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 697.  `Какой оператор используется для немедленной остановки цикла?`

В Java для немедленной остановки цикла можно использовать оператор break. Он позволяет выйти из цикла на любой итерации и продолжить выполнение кода после цикла. Пример:
```java
for (int i = 0; i < 10; i++) {
  if (i == 5) {
    break; // выходим из цикла при i=5
  }
  System.out.println(i);
}
```
Этот код выведет числа от 0 до 4 включительно.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 698. `Какой оператор используется для перехода к следующей итерации цикла?`

В Java оператор continue используется для перехода к следующей итерации цикла. Когда continue вызывается в цикле, текущая итерация цикла прерывается, и выполнение переходит к следующей итерации. Пример использования оператора continue в цикле for:
```java
for (int i = 0; i < 10; i++) {
  if (i == 5) {
    continue; // пропустить итерацию i=5
  }
  System.out.println(i);
}
```
В этом примере в цикле for вызывается оператор continue, когда i равно 5. В результате этой итерация цикла пропускается, и выполнение продолжается со следующей итерации.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 699. `Что такое массив?`

Массив (array) в Java это объект, который хранит фиксированное количество значений одного типа. Длина массива устанавливается при его создании, и после этого изменить длину массива уже нельзя. Каждое значение в массиве имеет свой индекс, начиная с 0. Индексы в Java массивах могут быть целочисленного типа. Массивы могут содержать как примитивные типы данных (например, int, double, char), так и объекты (например, строки, другие массивы и т.д.).

Пример создания и инициализации одномерного массива целых чисел:
```java
int[] numbers = {1, 2, 3, 4, 5};
```
Пример создания двумерного массива целых чисел:
```java
int[][] matrix = {{1, 2}, {3, 4}, {5, 6}};
```
Для доступа к элементам массива используется индексация:
```java
int firstNumber = numbers[0]; // первый элемент массива numbers
int secondNumber = numbers[1]; // второй элемент массива numbers
int element = matrix[1][0]; // элемент матрицы matrix во второй строке и первом столбце
```
Для получения длины массива используется свойство length:
```java
int length = numbers.length; // длина массива numbers (равна 5)
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 700. `Какие виды массивов вы знаете?`
Вы можете использовать обычный одномерный массив, многомерные массивы, динамические массивы, массивы объектов и массивы списков.

Вот примеры объявления каждого из них:

+ Одномерный массив:
```java
int[] arr = new int[10];
```
Многомерный массив:
```java
int[][] multiArr = new int[10][5];
```
+ Динамический массив:
```java
ArrayList<Integer> arrList = new ArrayList<Integer>();
```
+ Массив объектов:
```java
MyObject[] objArr = new MyObject[10];
```
+ Массив списков:
```java
List<Integer>[] listArr = new List[10];
for(int i = 0; i < 10; i++) {
    listArr[i] = new ArrayList<Integer>();
}
```
В каждом из этих случаев мы можем обращаться к элементам массива по индексу и выполнять различные операции с массивами, такие как добавление, удаление или изменение элементов.

Однако, убедитесь, что используете соответствующий тип массива для конкретной задачи, чтобы добиться наилучшей производительности и оптимизировать свой код.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 701. `Что вы знаете о классах оболочках?`

Классы оболочки (Wrapper classes) - это классы в Java, которые инкапсулируют типы данных примитивов и предоставляют методы и конструкторы для работы с этими типами данных в объектно-ориентированном стиле. Классы оболочки могут быть полезны при работе с коллекциями, фреймворками и другими библиотеками, которые требуют объектных типов данных.

В Java существует 8 классов оболочек: Byte, Short, Integer, Long, Float, Double, Character, Boolean.

Каждый из этих классов имеет конструкторы для создания объектов, методы для преобразования между примитивными значениями и объектными значениями, методы для сравнения значений, а также набор статических методов для работы с соответствующими типами данных, например, метод parseInt() у класса Integer для парсинга целочисленных строк.

Пример создания объекта класса Integer:
```java
Integer myInt = new Integer(42);
```
Пример использования метода parseInt() класса Integer:
```java
int myInt = Integer.parseInt("42");
```
Кроме того, для каждого класса оболочки есть статические поля для представления минимального и максимального значений этого типа данных.

Например, для класса Integer минимальное и максимальное значение можно получить следующим образом:
```java
int minValue = Integer.MIN_VALUE;
int maxValue = Integer.MAX_VALUE;
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 702. `Что такое автоупаковка (boxing/unboxing)?`
Автоупаковка (autoboxing) и автораспаковка (unboxing) в Java - это механизмы, которые автоматически преобразуют примитивные типы данных в их соответствующие классы-оболочки и наоборот.

Например, вы можете объявить переменную Integer и присвоить ей значение типа int, как показано ниже:
```java
Integer myInteger = 10;
```
Это возможно благодаря автоупаковке, которая автоматически преобразует примитивный тип данных int в Integer. Автораспаковка работает в обратном направлении - она автоматически преобразует объект Integer в примитивный тип данных int.

Вот пример:
```java
Integer myInteger = 10;
int myInt = myInteger;
```
В этом примере автораспаковка автоматически преобразует объект Integer в примитивный тип данных int.

Автоупаковка и автораспаковка упрощают код и делают его более читаемым, но могут привести к некоторым проблемам производительности, особенно если они используются в больших или часто вызываемых методах.


к оглавлению


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 2. ООП (перейти в раздел)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 703. `Назовите принципы ООП и расскажите о каждом.`
ООП (объектно-ориентированное программирование) - это методология программирования, в которой программа организована вокруг объектов, которые могут содержать данные (поля) и функциональность (методы). ООП позволяет создавать гибкие, расширяемые и повторно используемые программы.

Классы являются основными сущностями в Java, и они определяют состояние (поля) и поведение (методы) объектов.

Основными принципами объектно-ориентированного программирования (ООП) являются абстракция, инкапсуляция, наследование и полиморфизм.

+ `Абстракция` - это концепция, которая позволяет скрыть ненужные детали и подробности реализации объектов, фокусируясь на их важных характеристиках и свойствах. Абстракция позволяет создавать более понятный и легко поддерживаемый код.

+ `Инкапсуляция` - это механизм, который позволяет объединить данные и методы, которые работают с этими данными, в одном классе, скрыть внутреннюю реализацию объекта и обеспечить доступ к ним только через определенный интерфейс. Это делает код более организованным и уменьшает возможность ошибок взаимодействия компонентов.

+ `Наследование` - это способность класса наследовать свойства и методы от другого базового класса, что позволяет повторно использовать код, упрощает его сопровождение и расширение. В результате наследования, новый класс содержит все свойства и методы базового класса, а также может добавлять свои собственные свойства и методы.

+ `Полиморфизм` - это способность объектов одного и того же базового класса проявлять свои свойства и методы по-разному в зависимости от ситуации. Это позволяет программисту управлять поведением объекта в различных контекстах. Методы могут быть переопределены для предоставления новой реализации в производных классах.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 704. `Дайте определение понятию “класс”.`
Класс - это шаблон или определение для создания объектов, который описывает состояние и поведение объекта. Он является основной концепцией объектно-ориентированного программирования (ООП) в Java.

Класс в Java состоит из переменных класса, методов, конструкторов и вложенных классов или интерфейсов. Переменные класса хранят состояние объекта, методы определяют поведение объекта и конструкторы создают экземпляры объектов.

В Java каждый объект является экземпляром класса, а класс определяет атрибуты и методы, которые доступны для каждого экземпляра объекта. Классы также могут наследоваться друг от друга, что позволяет создавать иерархии классов и создавать более сложные системы объектов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 705. `Что такое поле/атрибут класса?`
Поле или атрибут класса в Java - это переменная, объявленная внутри класса, и которая содержит данные, относящиеся к этому классу. Она может быть статической или нестатической.

Статическое поле класса принадлежит классу, а не объекту, и используется общим для всех экземпляров этого класса. Статические поля могут использоваться без создания экземпляра класса.

Нестатическое поле или экземпляр переменной принадлежит объекту класса и каждый объект имеет свою собственную копию этой переменной. Нестатические поля не могут быть использованы, пока не создан экземпляр класса.

Пример объявления поля в Java:
```java
public class MyClass {
    int x; // нестатическое поле класса
    static int y; // статическое поле класса 
}
```
Код int x объявляет нестатическое поле класса, а static int y объявляет статическое поле класса.

Для доступа к нестатическому полю класса, нужно создать экземпляр класса и использовать точечный (" . ") оператор. Для доступа к статическому полю, можно использовать имя класса, за которым следует точечный (" . ") оператор.

Пример использования полей класса:
```java
MyClass obj = new MyClass();
obj.x = 5; // устанавливаем нестатическое поле для экземпляра obj
MyClass.y = 10; // устанавливаем статическое поле для класса MyClass
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 706. `Как правильно организовать доступ к полям класса?`
Для организации доступа к полям класса в Java используются методы-геттеры (get) и методы-сеттеры (set). Геттеры позволяют получать значение поля, а сеттеры - устанавливать его. Они возвращают и принимают соответственно значение поля.

Пример:
```java
public class MyClass {
    private int myField;

    public int getMyField() {
        return myField;
    }

    public void setMyField(int myField) {
        this.myField = myField;
    }
}
```
В этом примере myField - приватное поле класса. Метод getMyField() позволяет получить значение поля, а метод setMyField(int myField) устанавливать его.

Таким образом, чтобы получить доступ к приватным полям класса в Java, можно использовать соответствующие геттеры и сеттеры. Это позволяет контролировать доступ к полям класса и изменять их значение только в том случае, когда это необходимо.


Также можно использовать модификаторы доступа для ограничения доступа к полям и методам класса. Например, чтобы разрешить доступ только из класса и его подклассов, можно использовать модификатор protected.
```java
public class MyClass {
    protected int myField;
 
    public int getMyField() {
        return myField;
    }
 
    public void setMyField(int value) {
        myField = value;
    }
}
```
В этом примере myField является защищенным полем класса MyClass, что означает, что к нему можно обращаться из класса и его подклассов, но не из других классов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 707. `Дайте определение понятию “конструктор”.`
Конструктор в Java - это метод, который вызывается при создании нового объекта класса. Он используется для инициализации свойств объекта и выполнения других операций, которые должны быть выполнены при создании объекта. Конструктор имеет тот же самый имя, что и класс, в котором он определен, и может принимать аргументы, которые используются для инициализации свойств объекта.

Конструкторы могут быть перегружены, то есть класс может иметь несколько конструкторов с разным количеством и типом аргументов. При вызове конструктора Java автоматически резервирует память для объекта в памяти и вызывает конструктор для инициализации его свойств.

Пример определения конструктора в Java для класса Person:
```java
public class Person {
    private String name;
    private int age;
    
    // Конструктор с двумя аргументами
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // Конструктор без аргументов
    public Person() {
        this.name = "Unknown";
        this.age = 0;
    }
}
```
Здесь Person - это класс с двумя свойствами: name и age. У него есть два конструктора: один принимает два аргумента - имя и возраст - и используется для создания объекта Person с заданными значениями свойств, а другой не принимает аргументов и используется для создания объекта с значениями свойств по умолчанию - "Unknown" и 0.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 708. `Чем отличаются конструкторы по умолчанию, копирования и конструктор с параметрам?`
В Java конструктор по умолчанию создается автоматически, когда вы не создаете конструктор явно. Он не принимает аргументов и инициализирует все переменные-члены значениями по умолчанию.

Конструктор копирования в Java позволяет создать новый объект с такими же значениями переменных-членов, как у существующего объекта. Конструктор копирования принимает аргумент, который является другим объектом того же типа, что и создаваемый объект.

Конструктор с параметрами в Java позволяет передать значения для инициализации переменных-членов класса при создании объекта. Он принимает один или несколько аргументов, которые используются для инициализации переменных-членов класса.

Основное отличие между этими тремя типами конструкторов заключается в том, как они инициализируют переменные-члены объекта при его создании. Конструктор по умолчанию инициализирует переменные-члены значениями по умолчанию, конструктор с параметрами инициализирует их переданными значениями, а конструктор копирования копирует значения из другого объекта.

Примеры реализации конструкторов в Java:
```java
public class MyClass {
    int x;
    String s;

    // конструктор по умолчанию
    public MyClass() {
        x = 0;
        s = "";
    }

    // конструктор с параметрами
    public MyClass(int x, String s) {
        this.x = x;
        this.s = s;
    }

    // конструктор копирования
    public MyClass(MyClass other) {
        this.x = other.x;
        this.s = other.s;
    }
}
```
Здесь this используется для обращения к переменным-членам класса внутри конструкторов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 709. `Какие модификации уровня доступа вы знаете, расскажите про каждый из них.`
В языке Java существуют четыре модификатора уровня доступа:

+ `public` - доступен из любого места в программе, а также из других программ.

+ `protected` - доступен внутри пакета и в наследниках класса.

+ `default (или package-private)` - доступен только внутри пакета.

+ `private` - доступен только внутри класса, где он был объявлен.

Ключевое слово public используется тогда, когда требуется, чтобы методы, переменные или классы были доступны из любой части программы. Модификатор protected используется для того, чтобы сделать члены класса доступными только для классов, наследующих данный класс, или для всех классов внутри того же пакета. Default является модификатором по умолчанию и допускает доступ только из тех классов и пакетов, которые находятся в том же пакете, что и класс с модификатором по умолчанию. Private используется для ограничения доступа к члену класса только для внутреннего использования в этом классе.

Примеры:
```java
// public modifier
public class Example {
  public int num = 10;
  public void method() {
    System.out.println("This is a public method");
  }
}

// protected modifier
public class Example {
  protected int num = 10;
  protected void method() {
    System.out.println("This is a protected method");
  }
}

// default (package-private) modifier
class Example {
  int num = 10;
  void method() {
    System.out.println("This is a default method");
  }
}

// private modifier
public class Example {
  private int num = 10;
  private void method() {
    System.out.println("This is a private method");
  }
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 710. `Расскажите об особенностях класса с единственным закрытым (private) конструктором.`

Класс с единственным закрытым (private) конструктором - это класс, который не может быть создан вне своего собственного класса. Это означает, что объекты этого класса могут быть созданы только внутри самого класса. Этот подход называется Singleton Pattern.

Конструктор становится закрытым (private) для того, чтобы предотвратить создание новых объектов с помощью ключевого слова new. Вместо этого, для создания объекта используется статический метод или переменная класса, которые также обычно имеют модификатор доступа private.

Этот подход широко используется в приложениях для управления ресурсами, например, для создания одного экземпляра класса, который будет обслуживать все запросы на сетевое соединение, базу данных или файловую систему.

Вот пример класса с единственным закрытым (private) конструктором на языке Java:
```java
public class Singleton {
   private static Singleton instance = new Singleton();
   
   private Singleton() {}
   
   public static Singleton getInstance() {
      return instance;
   }
}
```
В данном классе мы создаем статический объект Singleton, и закрываем конструктор для создания новых объектов с помощью ключевого слова private. Вместо этого мы создаем публичный метод getInstance(), который возвращает единственный объект Singleton и который можно использовать в других частях программы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 711. `О чем говорят ключевые слова “this”, “super”, где и как их можно использовать?`

Ключевое слово this в Java используется для обращения к текущему объекту. Оно используется, например, для доступа к полям и методам объекта. 

Ключевое слово super используется для обращения к родительскому классу (суперклассу) текущего объекта. Оно часто используется в случаях, когда требуется вызвать конструктор суперкласса или переопределить метод суперкласса.

this и super можно использовать в любом месте, где есть доступ к объекту или суперклассу. Например, их можно использовать в конструкторах классов или в методах экземпляра класса.

Пример использования this:
```java
public class MyClass {
    private int myField;
    
    public MyClass(int myField) {
        this.myField = myField; // Обращение к полю myField текущего объекта
    }
    
    public void doSomething() {
        System.out.println(this.myField); // Обращение к полю myField текущего объекта
    }
}
```
Пример использования super:
```java
public class MySubClass extends MySuperClass {
    public MySubClass(int myField) {
        super(myField); // Вызов конструктора суперкласса
    }
    
    @Override
    public void doSomething() {
        super.doSomething(); // Вызов метода doSomething() суперкласса
        // Дополнительный функционал
    }
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 712. `Дайте определение понятию “метод”.`

`Метод в Java` - это фрагмент кода, который выполняет определенную функцию или задачу, и который можно вызывать из других частей программы. Методы обычно используются для уменьшения дублирования кода и упрощения программы с помощью разбиения ее на более мелкие и управляемые куски. Методы могут принимать параметры и возвращать значения. Определение метода в Java включает имя метода, тип возвращаемого значения (если есть), список параметров и тело метода.

Например, вот пример определения метода greet(), который принимает аргумент name типа String и возвращает приветствие, содержащее это имя:
```java
public String greet(String name) {
    return "Hello, " + name + "!";
}
```
Этот метод может быть вызван из другой части программы следующим образом:
```java
String message = greet("John");
System.out.println(message); // выводит "Hello, John!"
```
Cуществует ряд встроенных методов, которые являются частью классов ядра Java и могут быть использованы в любой программе. Например, метод System.out.println() используется для вывода текста в консоль.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 713. `Что такое сигнатура метода?`

В Java `сигнатура метода` - это уникальное имя метода, которое содержит его имя, аргументы и тип возвращаемого значения. Сигнатура метода используется для определения перегруженных методов - методов с одинаковым именем, но разным числом или типом аргументов. В Java, перегруженные методы должны иметь разные сигнатуры методов, но могут иметь одно и то же имя. Например, возьмем следующий класс:
```java
public class MyClass {
    public int sum(int a, int b) {
        return a + b;
    }

    public double sum(double a, double b) {
        return a + b;
    }
}
```
У класса MyClass два перегруженных метода sum - один для суммирования двух целых чисел и один для суммирования двух дробных чисел. Эти методы имеют разные сигнатуры, так как они принимают аргументы разных типов, и компилятор Java может различить их и использовать подходящий метод в зависимости от типов аргументов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 714. `Какие методы называются перегруженными?`
В Java методы называются перегруженными, если у них одинаковое имя, но разные параметры (тип и/или количество). Это позволяет создавать несколько методов с одним именем, но разными параметрами, что делает код более читабельным и удобным в использовании. Например:
```java
public void print(int n) {
  System.out.println("Integer: " + n);
}

public void print(String s) {
  System.out.println("String: " + s);
}
```
Эти два метода называются перегруженными, так как имеют одно и то же имя print, но принимают разные типы параметров (целое число int и строку String соответственно).



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 715. `Могут ли нестатические методы перегрузить статические?`

Нет, нестатические методы не могут перегрузить статические методы в Java. Это связано с тем, что статические методы связаны с классом, в то время как нестатические методы связаны с экземпляром класса. При вызове метода Java использует сигнатуру метода, которая определяется именем метода и типами его параметров. Компилятор Java разрешает перегрузку методов на основе сигнатуры метода, и нестатический метод с той же сигнатурой, что и статический метод, будет рассматриваться как перегрузка, а не как переопределение.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 716. `Расскажите про переопределение методов.`
В Java переопределение методов позволяет определить реализацию метода в подклассе, которая может отличаться от реализации метода в суперклассе. Чтобы переопределить метод в подклассе, нужно использовать аннотацию @Override и написать реализацию метода с тем же именем и типами параметров. Например, если у нас есть класс Animal с методом move(), мы можем переопределить метод в классе Dog следующим образом:
```java
class Animal {
  public void move() {
    System.out.println("Moving...");
  }
}

class Dog extends Animal {
  @Override
  public void move() {
    System.out.println("Running...");
  }
}
```
В этом примере мы переопределили метод move() в классе Dog, чтобы он выводил "Running..." вместо "Moving...". При вызове метода move() для объекта класса Dog будет вызываться его переопределенная реализация.

Переопределение методов является важным механизмом объектно-ориентированного программирования, так как позволяет методам работать по-разному в разных классах, но сохраняет общий интерфейс для пользователей этих классов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 717. `Может ли метод принимать разное количество параметров (аргументы переменной длины)?`
Да, в Java метод может принимать разное количество параметров, используя аргументы переменной длины. В Java это достигается с помощью синтаксиса ... после типа параметра. Это означает, что метод может принимать любое количество аргументов указанного типа. Вот простой пример метода, который принимает аргументы переменной длины типа int:
```java
public void printNumbers(int... numbers) {
    for (int number : numbers) {
        System.out.println(number);
    }
}
```
Этот метод может быть вызван с любым количеством параметров типа int:
```java
printNumbers(1);
printNumbers(1, 2, 3);
printNumbers(new int[]{1, 2, 3});
```
Во всех трех случаях метод будет работать правильно, выводя переданные ему числа.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 718. `Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?`

Да, в Java можно сузить уровень доступа и тип возвращаемого значения при переопределении метода. Любой метод может быть сузен до уровня доступа, ниже чем у его базового метода. Кроме того, тип возвращаемого значения может быть сузен до любого подтипа типа возвращаемого значения базового метода.

Например, если есть класс Animal с методом makeSound возвращающим тип Object, и подкласс Cat переопределяет метод makeSound, то можно сузить тип возвращаемого значения до String, как показано в примере ниже:
```java
class Animal {
    public Object makeSound() {
        return "Some sound";
    }
}

class Cat extends Animal {
    @Override
    public String makeSound() {
        return "Meow";
    }
}
```
В этом примере переопределенный метод makeSound унаследован от Animal, но тип возвращаемого значения был изменен с Object до String. Теперь для объектов типа Cat метод makeSound возвращает строку "Meow", в то время как для объектов типа Animal, makeSound возвращает объект типа Object.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 719. `Как получить доступ к переопределенным методам родительского класса?`

Для доступа к переопределенным методам родительского класса в Java можно использовать ключевое слово super. super позволяет обратиться к методам и полям суперкласса из подкласса.

Например, если у нас есть класс-родитель ParentClass и класс-потомок ChildClass, который переопределяет метод someMethod() из класса-родителя, то можно вызвать версию метода из суперкласса следующим образом:
```java
public class ParentClass {
    public void someMethod() {
        System.out.println("Hello from ParentClass");
    }
}

public class ChildClass extends ParentClass {
    @Override
    public void someMethod() {
        super.someMethod(); // вызываем метод из суперкласса
        System.out.println("Hello from ChildClass");
    }
}

// вызываем метод из класса-потомка
ChildClass child = new ChildClass();
child.someMethod();
```
В данном примере при вызове метода someMethod() из объекта класса ChildClass будет сначала вызвана версия метода из суперкласса ParentClass, а затем из класса ChildClass.

Ключевое слово super также может использоваться для доступа к конструктору суперкласса из конструктора подкласса:
```java
public class ChildClass extends ParentClass {
    public ChildClass() {
        super(); // вызываем конструктор суперкласса
        // ...
    }
}

// создаем объект класса-потомка
ChildClass child = new ChildClass();
```
Этот код вызовет конструктор суперкласса ParentClass при создании объекта класса-потомка ChildClass.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 720. `Какие преобразования называются нисходящими и восходящими?`

Преобразование от потомка к предку называется восходящим, от предка к потомку — нисходящим. 

Нисходящее преобразование должно указываться явно с помощью указания нового типа в скобках.

Преобразование типов в Java может быть либо нисходящим (downcasting), либо восходящим (upcasting). 

`Нисходящее преобразование` происходит, когда объект класса преобразуется в объект класса-наследника. Например:
```java
Animal animal = new Cat(); // upcasting, преобразуем объект класса Cat в объект класса Animal
Cat cat = (Cat) animal; // downcasting, преобразуем объект класса Animal обратно в объект класса Cat
```
`Восходящее преобразование` происходит, когда объект класса-наследника преобразуется в объект класса-родителя. Например:
```java
Cat cat = new Cat(); // создаем объект класса Cat
Animal animal = cat; // upcasting, преобразуем объект класса Cat в объект класса Animal
```
Во время нисходящего преобразования необходимо явное приведение типа, т.к. объект класса-наследника содержит дополнительные методы и поля, которых нет в родительском классе. Поэтому перед использованием этих методов и полей необходимо преобразовать объект к типу класса-наследника.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 721. `Чем отличается переопределение от перегрузки?`

Переопределение (override) и перезагрузка (overloading) - это два понятия в объектно-ориентированном программировании, которые описывают способы использования методов в наследовании классов.

Переопределение (override) - это процесс изменения или замены реализации метода, унаследованного от базового класса, в производном классе. То есть, производный класс предоставляет свою собственную реализацию метода, который уже определен в базовом классе.

Например:
```java
class MyBaseClass {
  public void printMessage() {
    System.out.println("Hello, world!");
  }
}

class MyDerivedClass extends MyBaseClass {
  @Override
  public void printMessage() {
    System.out.println("Hi there!");
  }
}
```
Здесь метод printMessage() переопределяется в производном классе MyDerivedClass. Вызов этого метода на объекте MyDerivedClass приведет к выводу "Hi there!" вместо "Hello, world!", которые выводятся при вызове на объекте MyBaseClass.

Перегрузка (overloading) - это процесс создания нескольких методов с одним именем, но разными параметрами, внутри одного класса. В этом случае, каждая версия метода может иметь свою собственную реализацию.

Например:
```java
class MyMathClass {
  public int add(int a, int b) {
    return a + b;
  }

  public double add(double a, double b) {
    return a + b;
  }
}
```
Здесь класс MyMathClass имеет два метода с именем add(), но каждый принимает разные типы параметров. Это называется перегрузкой метода. Вызов метода add() на объекте класса MyMathClass с целочисленными аргументами



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 722. `Где можно инициализировать статические/нестатические поля?`





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 723. `Зачем нужен оператор instanceof?`

Оператор instanceof в Java используется для проверки, является ли объект экземпляром определенного класса, интерфейса или подкласса любого класса. Например, если у вас есть объект obj и вы хотите проверить, является ли он экземпляром класса MyClass, вы можете написать следующий код:
```java
if (obj instanceof MyClass) {
    // do something
}
```
Это можно использовать для проверки типов во время выполнения и для принятия решений на основе этой информации. Например, вы можете использовать instanceof для проверки типа объекта и затем вызывать определенный метод в зависимости от типа:
```java
if (obj instanceof MyClass) {
    ((MyClass)obj).myMethod();
} else if (obj instanceof MyOtherClass) {
    ((MyOtherClass)obj).myOtherMethod();
}
```
Это избавляет вас от необходимости использовать множественные условные операторы if и else или switch-case конструкции, особенно если у вас есть множество типов объектов, которые необходимо проверить на равенство.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 724. `Зачем нужны и какие бывают блоки инициализации?`

Блоки инициализации в Java - это блоки кода, которые выполняются при инициализации класса или экземпляра класса. Они используются для выполнения определенных задач, таких как инициализация переменных, установка соединения с базой данных и т.д.

В Java есть два типа блоков инициализации: Статический блок инициализации и блок инициализации экземпляра.

Статический блок инициализации выполняется при загрузке класса, а блок инициализации экземпляра выполняется при создании экземпляра класса.

Пример статического блока инициализации:
```java
public class MyClass {
    static {
        // код, который выполнится при загрузке класса
    }
}
```
Пример блока инициализации экземпляра:
```java
public class MyClass {
    {
        // код, который выполнится при создании экземпляра класса
    }
}
```
Блоки инициализации позволяют упростить инициализацию объектов и добавить дополнительную логику при их создании.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 725. `Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?`

В Java конструкторы и блоки инициализации вызываются в определенном порядке при создании объекта. Для класса-потомка порядок вызова конструкторов и блоков инициализации следующий:

+ Сначала вызывается статический блок инициализации класса-родителя (если он есть).

+ Затем вызывается конструктор класса-родителя.

+ Выполняются блоки инициализации экземпляра класса-родителя (обычный блок инициализации, блок инициализации инстанса и блок инициализации final-полей).

+ Вызывается статический блок инициализации класса-потомка (если он есть).

+ Затем вызывается конструктор класса-потомка.

+ Выполняются блоки инициализации экземпляра класса-потомка (обычный блок инициализации, блок инициализации инстанса и блок инициализации final-полей).

Например, если у вас есть класс-родитель Parent и класс-потомок Child, то порядок вызова конструкторов и блоков инициализации будет следующим:
```java
class Parent {
    static {
        System.out.println("Static init block in Parent");
    }

    {
        System.out.println("Instance init block in Parent");
    }

    public Parent() {
        System.out.println("Constructor in Parent");
    }
}

class Child extends Parent {
    static {
        System.out.println("Static init block in Child");
    }

    {
        System.out.println("Instance init block in Child");
    }

    public Child() {
        System.out.println("Constructor in Child");
    }
}

// Создаем объект класса Child
Child child = new Child();
```
Этот код выведет следующий результат в консоль:
```
Static init block in Parent
Constructor in Parent
Instance init block in Parent
Static init block in Child
Constructor in Child
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 726. `Где и для чего используется модификатор abstract?`

Модификатор abstract используется в Java, чтобы указать, что метод или класс не имеют реализации в данном классе и должны быть реализованы в подклассе.

Абстрактные классы используются, когда нужно создать класс, но необходимо, чтобы дочерние классы добавили свои уникальные свойства или методы. Абстрактные классы могут содержать абстрактные методы, которые не имеют реализации, и дочерние классы должны реализовать эти методы.

Абстрактные методы могут быть определены только в абстрактных классах, и они не имеют тела (реализации). Дочерние классы должны предоставить реализацию абстрактных методов, иначе они также должны быть определены как абстрактные классы.

Например, следующий код демонстрирует абстрактный класс Animal, который содержит абстрактный метод makeSound(). Класс Cow расширяет абстрактный класс Animal и предоставляет реализацию метода makeSound():
```java
abstract class Animal {
  public abstract void makeSound();
}

class Cow extends Animal {
  public void makeSound() {
    System.out.println("Moo");
  }
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 727. `Можно ли объявить метод абстрактным и статическим одновременно?`

Нет, в Java нельзя объявить метод одновременно абстрактным и статическим, потому что такое объявление будет некорректным. Метод, объявленный статическим, принадлежит классу и может быть вызван без создания экземпляра класса, в то время как абстрактный метод не имеет тела и должен быть реализован в подклассах. Из-за этой разницы в семантике объединение этих двух модификаторов невозможно.

Пример некорректного объявления метода:
```java
public abstract static void myMethod();
```
Этот код вызовет ошибку компиляции с сообщением "Illegal combination of modifiers: 'abstract' and 'static'".

Методы абстрактные, как правило, должны быть реализованы в подклассах, чтобы предоставить конкретную имплементацию, тогда как статические методы могут быть использованы для предоставления утилитарных функций, которые не зависят от состояния экземпляра.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 728. `Что означает ключевое слово static?`

В Java ключевое слово static используется для создания переменных и методов, которые общие для всех экземпляров класса, а не относятся к конкретному экземпляру. Иными словами, переменная или метод, объявленные как static, могут быть использованы без создания экземпляра класса и доступны в рамках всего класса.

Static переменные хранятся в общей памяти и инициализируются при загрузке класса, а static методы могут быть вызваны напрямую через класс, не требуя создания экземпляра класса.

Например, если у вас есть класс Car с переменной numberOfWheels, которая должна иметь одно и то же значение для всех экземпляров класса, можно объявить эту переменную как static:
```java
public class Car {
    public static int numberOfWheels = 4;
    // other class members here
}
```
Теперь значение переменной numberOfWheels будет общим для всех экземпляров класса Car.

Кроме того, вы можете объявлять static методы, которые будут доступны в рамках всего класса и не требуют создания экземпляра класса для вызова. Один из стандартных примеров - это метод main(), который используется для запуска Java-программ.
```java
public class MyClass {
    public static void main(String[] args) {
        //code to be executed
    }
}
```
Этот метод может быть вызван напрямую через класс MyClass, без необходимости создавать экземпляр этого класса.

В общем, static это механизм, позволяющий в Java создавать переменные и методы, которые общие для всего класса, а не для его экземпляров.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 729. `К каким конструкциям Java применим модификатор static?`
Модификатор static в Java может быть применен к методам, полям и вложенным классам. Когда метод или поле объявлены как static, они принадлежат классу, а не экземпляру класса. Это означает, что они могут быть вызваны или использованы без создания экземпляра класса. Когда вложенный класс объявлен как static, он связан со своим внешним классом, но не зависит от создания экземпляра внешнего класса.

Пример использования модификатора static для поля и метода:
```java
public class MyClass {
    static int myStaticField = 42;
    int myNonStaticField = 0;

    static void myStaticMethod() {
        System.out.println("This is a static method");
    }

    void myNonStaticMethod() {
        System.out.println("This is a non-static method");
    }
}

// Для доступа к статическому полю или методу, необходимо использовать имя класса
int val = MyClass.myStaticField;
MyClass.myStaticMethod();
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 730. `Что будет, если в static блоке кода возникнет исключительная ситуация?`

Если в блоке кода static возникнет исключительная ситуация, то при первом обращении к классу, в котором находится этот блок, JVM (среда выполнения Java) не будет выполнять блок кода static, и вместо этого выбросится исключение. Класс не будет инициализирован, и его статические переменные или методы не будут доступны до тех пор, пока блок кода static не будет выполнен успешно. Это может привести к проблемам, если статические переменные не инициализированы и используются в других частях кода, поэтому важно обрабатывать исключения в блоке static.

Например, в следующем примере при попытке инициализировать класс будет выброшено исключение NullPointerException:
```java
public class MyClass {
    static {
        String s = null;
        s.length(); // throws NullPointerException
    }
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 731. `Можно ли перегрузить static метод?`
Да, в Java можно перегружать статические методы так же, как и нестатические методы. Однако в отличие от нестатических методов, где динамический полиморфизм решает, какая версия метода будет вызвана во время выполнения, перегруженный статический метод, который будет вызываться, решается во время компиляции, основываясь на типах параметров метода, переданных в него. Например:
```java
public class MyClass {
    public static void myMethod(int x) {
        System.out.println("Method with int parameter: " + x);
    }
 
    public static void myMethod(String x) {
        System.out.println("Method with String parameter: " + x);
    }
}
```
Здесь мы определили два перегруженных статических метода myMethod, один с параметром типа int, а другой с параметром типа String.

Eще пример, представим класс с двумя перегруженными static методами:
```java
public class MyClass {
    public static void printMessage() {
        System.out.println("Hello, world!");
    }
    
    public static void printMessage(String message) {
        System.out.println(message);
    }
}
```
В этом примере мы создали два перегруженных static метода printMessage, один без аргументов и второй с одним аргументом типа String. Эти методы можно вызвать следующим образом:
```java
MyClass.printMessage();           // вызовет метод printMessage() без аргументов
MyClass.printMessage("Hi there"); // вызовет метод printMessage() с аргументом "Hi there"
```
Таким образом, перегрузка static методов предоставляет гибкость и удобство в программировании на Java, позволяя создавать методы с одним именем, но разными списками параметров.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 732. `Что такое статический класс, какие особенности его использования?`
Статический класс в Java - это вложенный класс, который имеет модификатор доступа static. Это означает, что экземпляры статического класса не создаются вместе с экземплярами внешнего класса, а независимы от него и могут быть созданы самостоятельно. К классу высшего уровня модификатор static неприменим.

Особенности использования статического класса:

+ Статический класс может содержать только статические методы, поля, и другие статические классы.

+ В статическом классе нельзя использовать поля или методы внешнего класса (только если они тоже являются статическими).

+ К статическим методам и полям статического класса можно обращаться без создания экземпляра класса.

Например, вот как определить статический класс в Java:
```java
public class OuterClass {
  static class StaticNestedClass {
    static int staticField;

    static void staticMethod() {
      // метод статического класса
    }
  }
}
```
К статическим полям и методам статического класса можно обращаться из других классов используя полный путь к классу, например:
```java
OuterClass.StaticNestedClass.staticField = 42;
OuterClass.StaticNestedClass.staticMethod();
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 733. `Какие особенности инициализации final static переменных?`
В Java, final static переменные обычно инициализируются либо непосредственно при объявлении, либо в блоке статической инициализации класса. Обе эти опции гарантируют, что переменная будет инициализирована только один раз во время выполнения программы.

Примеры инициализации final static переменных:

+ Непосредственная инициализация при объявлении:
```java
public class MyClass {
    public static final int MY_CONSTANT = 42;
}
```
+ Инициализация в блоке статической инициализации класса:
```java
public class MyClass {
    public static final int MY_CONSTANT;
    static {
        MY_CONSTANT = 42;
    }
}
```
+ Комбинация непосредственной инициализации и статического блока инициализации:
```java
public class MyClass {
    public static final int MY_CONSTANT = 42;
    static {
        System.out.println("Initializing MyClass");
    }
}
```
В любом случае, final static переменные должны быть инициализированы до того, как они будут использованы в программе. Кроме того, они не могут быть изменены после их инициализации.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 734. `Как влияет модификатор static на класс/метод/поле?`
Модификатор static в Java влияет на класс, метод или поле, делая их доступными без создания экземпляра класса.
Модификатор static в Java может быть применен к полям, методам и вложенным классам.

+ Когда применяется к полям, это означает, что это статическое поле относится к классу в целом, а не к конкретному экземпляру класса. Таким образом, все экземпляры класса будут иметь общее значение этого поля.

+ Когда применяется к методам, метод можно вызывать независимо от каких-либо экземпляров класса.

+ Когда применяется к вложенным классам, они могут быть созданы, даже если экземпляры внешнего класса не созданы.

Использование модификатора static позволяет существенно сократить использование памяти и повысить производительность вашей программы. Однако его следует использовать осторожно, так как это может затруднить тестирование и обнаружение ошибок.

+ Статический метод: метод является статическим, если он принадлежит классу, а не экземпляру класса. Статический метод можно вызвать без создания экземпляра класса. Пример:
```java
public class MyClass {
    public static void myStaticMethod() {
        System.out.println("Static method");
    }
    public void myPublicMethod() {
        System.out.println("Public method");
    }
}

MyClass.myStaticMethod(); // Call the static method
MyClass obj = new MyClass(); // Create an object of MyClass
obj.myPublicMethod(); // Call the public method
```
+ Статическое поле класса: статическое поле принадлежит классу, а не экземпляру класса, и доступно без создания экземпляра класса. Пример:
```java
public class MyClass {
    public static String myStaticField = "Static field";
    public String myPublicField = "Public field";
}

System.out.println(MyClass.myStaticField); // Output the static field
MyClass obj = new MyClass(); // Create an object of MyClass
System.out.println(obj.myPublicField); // Output the public field
```
+ Статический блок инициализации: статический блок инициализации выполняется при загрузке класса и используется для инициализации статических полей. Пример:
```java
public class MyClass {
    static {
        // Code to execute
    }
}
```
Статические методы и поля не могут обращаться к нестатическим методам и полям без создания экземпляра класса. Если статический метод или поле ссылается на нестатический метод или поле, то необходимо создать экземпляр класса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 735. `О чем говорит ключевое слово final?`

Ключевое слово "final" в Java используется для обозначения неизменяемости значения переменной, метода или класса.

+ Для переменных: если переменная объявлена с ключевым словом "final", это означает, что ее значение не может быть изменено после инициализации, то есть она становится константой. Например:
```java
final int x = 5;
```
+ Для методов: если метод объявлен с ключевым словом "final", его тело не может быть изменено в подклассах. Это может быть полезно в случае, если мы хотим, чтобы метод в подклассах оставался неизменным. Например:
```java
public class MyClass {
    final void myMethod() { /* тело метода */ }
}
```
+ Для классов: если класс объявлен с ключевым словом "final", его нельзя наследовать. Таким образом, это означает, что мы не можем создавать подклассы для данного класса. Например:
```java
final class MyClass { /* тело класса */ }
```
+ Значение локальных переменных, а так же параметров метода помеченных при помощи слова final не могут быть изменены после присвоения

Использование ключевого слова "final" может повысить производительность и обеспечить более безопасный код в некоторых ситуациях, когда мы хотим гарантировать неизменность значения или поведения переменной, метода или класса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 736. `Дайте определение понятию “интерфейс”.`
В Java интерфейс - это абстрактный класс, который содержит только абстрактные методы (методы без тела), и константы. Интерфейс позволяет определить конкретный комплект методов, которые должен реализовывать любой класс, который реализует этот интерфейс. Интерфейс может определять методы, аргументы для методов и возвращаемые значения, но он не предоставляет реализации для этих методов. Вместо этого реализация предоставляется классами, которые реализуют интерфейс.

Для объявления интерфейса в Java используется ключевое слово interface. Затем определяются методы, которые должны быть реализованы в классе, который реализует интерфейс. Класс может реализовать несколько интерфейсов, что позволяет ему наследовать поведение нескольких интерфейсов.


Пример интерфейса в Java:
```java
public interface MyInterface {
  public void doSomething();
  public int getNumber();
}
```
Класс, который реализует интерфейс, должен реализовать все его методы, например:
```java
public class MyClass implements MyInterface {
  public void doSomething() {
    System.out.println("Doing something");
  }
  public int getNumber() {
    return 42;
  }
}
```
Теперь объект класса MyClass можно использовать, где ожидается объект типа MyInterface.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 737. `Какие модификаторы по умолчанию имеют поля и методы интерфейсов?`
Поля и методы интерфейсов в Java по умолчанию имеют модификаторы public и abstract, соответственно. Если в интерфейсе определяется метод, но не указывается модификатор доступа, то он автоматически считается public и abstract.

Интерфейс может содержать поля, но они автоматически являются статическими (static) и неизменными (final). Все методы и переменные неявно объявляются как public.

Начиная с Java 8, интерфейсы могут также иметь методы по умолчанию (default methods), которые имеют реализации по умолчанию и могут быть переопределены в классах, реализующих интерфейс.

Нововведением Java 9 стало добавление приватных методов и приватных статических методов в интерфейсы, которые могут использоваться для того, чтобы скрыть детали реализации и облегчить повторное использование кода.

Например, интерфейс с одним методом может выглядеть так:
```java
public interface MyInterface {
    void myMethod();

    default void myDefaultMethod() {
        System.out.println("Default implementation of myDefaultMethod()");
    }

    private void myPrivateMethod() {
        System.out.println("Private implementation of myPrivateMethod()");
    }

    private static void myPrivateStaticMethod() {
        System.out.println("Private static implementation of myPrivateStaticMethod()");
    }
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 738. `Почему нельзя объявить метод интерфейса с модификатором final или static`

В Java нельзя объявить метод в интерфейсе с модификатором final или static, потому что все методы в интерфейсе считаются неявно абстрактными и public, и поэтому они не могут быть статическими или final, так как это нарушает их природу абстракции. Static методы могут быть только в статических классах, а final методы можно объявить только в классах и не имеет смысла в интерфейсе, где не реализуются методы. Вместо этого вы можете объявить константы в интерфейсе с модификаторами static и final:
```java
public interface MyInterface {
  int MY_CONSTANT = 100; // объявление константы
}
```
Но если вы хотите иметь какой-то общий функционал для всех реализующих интерфейс классов, вы можете использовать статический метод или метод по умолчанию, объявленный в интерфейсе:
```java
public interface MyInterface {
  static void myStaticMethod() {
    System.out.println("This is a static method in the interface.");
  }
  
  default void myDefaultMethod() {
    System.out.println("This is a default method in the interface.");
  }
}

class MyClass implements MyInterface {
  public static void main(String[] args) {
    MyInterface.myStaticMethod();
    MyClass obj = new MyClass();
    obj.myDefaultMethod();
  }
}
```
Это позволит вам вызывать методы в интерфейсе без создания экземпляра класса, а также предоставлять реализацию методов по умолчанию для всех реализующих интерфейс классов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 739. `Какие типы классов бывают в java (вложенные… и.т.д.)`
В Java есть несколько типов вложенных (nested) классов:

+ `Внутренние (Inner) классы`: это классы, которые объявлены внутри другого класса и имеют доступ к его полям и методам, даже к приватным. Внутренние классы могут быть объявлены как статическими или нестатическими.Есть возможность обращения к внутренним полям и методам класса обертки.
Не может иметь статических объявлений. Нельзя объявить таким образом интерфейс. А если его объявить без идентификатора static, то он автоматически будет добавлен.Внутри такого класса нельзя объявить перечисления.Если нужно явно получить this внешнего класса — OuterClass.this

+ `Вложенные (Nested) классы`: это классы, которые объявлены внутри другого класса, но не имеют доступа к его полям и методам. Вложенные классы могут быть объявлены как статическими или нестатическими.

+ `Локальные (Local) классы`: это классы, которые объявлены внутри метода или блока кода и имеют доступ к переменным и параметрам этого метода или блока кода.Видны только в пределах блока, в котором объявлены.
Не могут быть объявлены как private/public/protected или static (по этой причине интерфейсы нельзя объявить локально).
Не могут иметь внутри себя статических объявлений (полей, методов, классов).
Имеют доступ к полям и методам обрамляющего класса.
Можно обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final.

+ `Анонимные (Anonymous) классы`: это классы, которые не имеют имени и создаются "на лету" при создании объекта интерфейса или абстрактного класса. Они используются, когда требуется реализовать какой-то метод "на месте".

+ `Статические (Static) классы`: это вложенные классы, которые объявлены как статические и не имеют доступа к нестатическим полям и методам внешнего класса. Они обычно используются для группировки связанных сущностей в рамках одного пакета или модуля. Есть возможность обращения к внутренним статическим полям и методам класса обертки. Внутренние статические классы могут содержать только статические методы.
  
+ `Обычные классы (Top level classes)`
+ `Интерфейсы (Interfaces)`
+ `Перечисления (Enum)`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 740. `Какие особенности создания вложенных классов: простых и статических.`

В Java есть два основных типа вложенных классов: внутренние классы (inner classes) и статические вложенные классы (static nested classes).

`Внутренние классы` - это классы, объявленные внутри другого класса без использования модификатора static. Такие классы имеют доступ к членам внешнего класса, включая приватные поля и методы, и могут использоваться для создания более читаемого и логически законченного кода.

`Статические вложенные классы` - это классы, объявленные внутри другого класса с использованием модификатора static. Эти классы не имеют доступа к членам внешнего класса и используются для логической группировки классов и для создания пространства имен.

Пример создания статического вложенного класса:
```java
public class OuterClass {
  // Код внешнего класса
  public static class InnerStaticClass {
    // Код статического вложенного класса
  }
}
```
Пример создания внутреннего класса:
```java
public class OuterClass {
  // Код внешнего класса
  public class InnerClass {
    // Код внутреннего класса
  }
}
```
Обратите внимание, что внутренний класс может быть создан только в контексте экземпляра внешнего класса, тогда как статический вложенный класс может быть создан без создания экземпляра внешнего класса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 741. `Что вы знаете о вложенных классах, зачем они используются? Классификация, варианты использования, о нарушении инкапсуляции.`
В Java вложенные классы делятся на статические и внутренние (inner classes).

`Статические вложенные классы (static nested classes)` - это классы, которые являются членами внешнего класса, но при этом не имеют доступа к нестатическим членам внешнего класса. Они часто используются для логической группировки классов внутри другого класса.

`Внутренние классы (inner classes)` - это классы, которые объявлены внутри другого класса и имеют доступ к членам и методам внешнего класса, даже если они объявлены как private. Внутренние классы могут быть обычными (обычно объявляются как private) и анонимными (не имеют имени и используются для реализации интерфейсов или абстрактных классов).

Внутренние классы могут быть полезны для реализации определенных паттернов проектирования, таких как фабрики и стратегии. Они также позволяют улучшить читабельность кода и уменьшить объем повторяющегося кода.

Однако, использование внутренних классов может нарушать инкапсуляцию и затруднять чтение и понимание кода, поэтому их использование следует ограничивать только в тех случаях, где это действительно необходимо.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 742. `В чем разница вложенных и внутренних классов?`
В Java вложенные классы (nested classes) могут быть статическими или нестатическими. Статические вложенные классы используются, когда класс находится внутри другого класса, но не зависит от экземпляра внешнего класса. Нестатические вложенные классы (inner classes), также известные как внутренние классы, наоборот, зависят от экземпляра внешнего класса.

Объявление нестатического внутреннего класса происходит с использованием ключевого слова 'class' внутри тела внешнего класса. Вот пример:
```java
class OuterClass {
  private int x;

  class InnerClass {
    public int getX() {
      return x;
    }
  }
}
```
Объявление статического вложенного класса выглядит следующим образом:
```java
class OuterClass {
  static class NestedClass {
    // Код класса
  }
}
```
Различия между вложенными и внутренними классами заключаются в том, что внутренние классы имеют доступ к полям и методам экземпляра внешнего класса, в то время как вложенные классы не имеют такого доступа. Внутренние классы также могут быть созданы только в контексте экземпляра внешнего класса, в то время как статические вложенные классы могут быть созданы вне контекста экземпляра внешнего класса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 743. `Какие классы называются анонимными?`
Анонимный класс - это класс, который объявлен без имени внутри другого класса или метода, и который реализует либо наследует какой-то интерфейс. 

В Java классы, которые не имеют имени, называются анонимными классами. Они используются для создания одиночных объектов с определенным поведением, которые обычно не нуждаются в создании отдельного класса. Анонимный класс объявляется и создается в одной строке кода, обычно в качестве аргумента для метода или конструктора. Вот пример:
```java
interface MyInterface {
   void doSomething ();
}
MyInterface myObject = new MyInterface () {
   public void doSomething () {
      System.out.println ("I am doing something.");
   }
};
```
Здесь мы объявляем интерфейс MyInterface с единственным методом doSomething(), а затем создаем анонимный класс, который реализует этот метод и создает объект типа MyInterface. Этот объект присваивается переменной myObject. Когда myObject.doSomething() вызывается, на экране появляется "I am doing something."



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 744. `Каким образом из вложенного класса получить доступ к полю внешнего класса?`

Для получения доступа к полю внешнего класса из вложенного класса в Java можно использовать ключевое слово this с именем внешнего класса и оператором точки, например: OuterClass.this.outerField. Вот пример кода:
```java
public class OuterClass {
    private int outerField;

    public class InnerClass {
        public void accessOuterField() {
            int fieldValue = OuterClass.this.outerField;
            // do something with the fieldValue
        }
    }
}
```
Здесь InnerClass является вложенным классом в OuterClass, и метод accessOuterField() использует this.outerField для доступа к полю outerField внешнего класса OuterClass.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 745. `Каким образом можно обратиться к локальной переменной метода из анонимного класса, объявленного в теле этого метода? Есть ли какие-нибудь ограничения для такой переменной?`

Для доступа к локальной переменной метода из анонимного класса, объявленного в теле этого метода в Java, её следует сделать final. Это необходимо, чтобы гарантировать, что значение переменной не будет изменено после создания анонимного класса. Для получения доступа к переменной в анонимном классе, можно обратиться к ней по имени, как это делается в лямбда-выражениях. Например:
```java
public void someMethod() {
    final int localVar = 42;
    // Создание анонимного класса
    Runnable r = new Runnable() {
        public void run() {
            System.out.println(localVar); // Доступ к локальной переменной
        }
    };
    r.run();
}
```
Это позволит получить доступ к localVar внутри анонимного класса. Важно отметить, что локальные переменные, объявленные внутри статических методов, не могут быть делегированы анонимным классам, так как эти переменные не находятся на стеке вызовов.

Также стоит заметить, что начиная с Java 8, можно использовать локальные переменные метода в лямбда-выражениях без явного объявления как final.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 746. `Как связан любой пользовательский класс с классом Object?`

В Java все классы являются подклассами класса Object. Это означает, что любой пользовательский класс, который вы определяете в Java, автоматически наследуется от класса Object. Это также означает, что вы можете использовать методы класса Object, такие как toString(), equals(), hashCode(), и другие, для любого вашего пользовательского класса.

Например, если у вас есть класс Person, вот как можно переопределить метод toString() класса Object для этого класса:
```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // override the toString() method to print out the person's name and age
    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}
```
Благодаря наследованию, вы можете использовать этот код для создания объекта класса Person, вызова его метода toString() и присваивания этот результат переменной типа Object:
```java
Person p = new Person("John Doe", 30);
Object o = p;
System.out.println(o.toString()); // выводит: Person{name='John Doe', age=30}
```
Таким образом, любой пользовательский класс в Java неявно связан с классом Object посредством наследования.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 747. `Расскажите про каждый из методов класса Object.`

Класс Object является базовым классом для всех классов в Java. Он определяет ряд методов, которые наследуются всеми классами. Эти методы включаю (8):

+ `equals()` - определяет, равен ли данный объект другому объекту. Возвращает true если объекты равны, false если они не равны.

+ `hashCode()` - возвращает хеш-код объекта.

+ `toString()` - возвращает строковое представление объекта.

+ `getClass()` - возвращает класс объекта.

+ `wait()` - заставляет текущий поток ждать до тех пор, пока другой поток не выполнит определенное действие.

+ `notify()` - возобновляет выполнение потока, остановленного методом wait().

+ `notifyAll()` - возобновляет выполнение всех потоков, остановленных методом wait() на текущем объекте.

+ `finalize()` - вызывается сборщиком мусора при удалении объекта.

Данные методы могут быть переопределены в производных классах, но, как правило, это не рекомендуется, так как они выполняют важные функции и их неправильная реализация может привести к ошибкам в программе.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 748. `Что такое метод equals(). Чем он отличается от операции ==.`

В Java метод equals() используется для сравнения содержимого объектов, тогда как операция == сравнивает ссылки на объекты. Когда вы используете операцию == с объектами, она проверяет, указывает ли каждая ссылка на один и тот же объект в памяти, в то время как метод equals() сравнивает содержимое объектов, чтобы узнать, являются ли они эквивалентными. В большинстве случаев операция == используется для примитивных типов данных, таких как int, boolean, char, а метод equals() используется для объектов и ссылочных типов данных, таких как String, Date и других.

Вот пример использования метода equals() на объекте String:
```java
String str1 = "Hello";
String str2 = "Hello";
if(str1.equals(str2)) {
    System.out.println("Strings are equal");
} else {
    System.out.println("Strings are not equal");
}
```
В данном примере метод equals() сравнивает содержимое двух строк str1 и str2, и выводит сообщение "Strings are equal", потому что содержимое обеих строк эквивалентно. Если бы мы использовали операцию == вместо метода equals(), она бы вернула false, потому что ссылки обеих строк указывают на разные объекты в памяти.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 749. `Если вы хотите переопределить equals(), какие условия должны удовлетворяться для переопределенного метода?`

Если вы хотите переопределить метод equals() в Java, важно понимать, что этот метод используется для сравнения двух объектов на равенство. Для того, чтобы ваш переопределенный метод equals() работал должным образом, он должен удовлетворять определенным условиям:

+ `Рефлексивность`: Объект всегда должен быть равен самому себе. То есть, a.equals(a) должен всегда возвращать true.

+ `Симметричность`: Если объект a равен объекту b, то b также должен быть равен a. То есть, если a.equals(b) возвращает true, то b.equals(a) должен также возвращать true.

+ `Транзитивность`: Если объекты a, b и c равны между собой (a.equals(b) возвращает true, b.equals(c) возвращает true), то объект a также должен быть равен объекту c (a.equals(c) должен возвращать true).

+ `Непротиворечивость`: Если вы сравниваете два объекта в разное время, и их состояние не изменялось, результатом должно быть одно и то же. То есть, повторный вызов метода equals() для двух одинаковых объектов должен всегда возвращать true.

+ `Сравнение с null`: Метод equals() должен возвращать false, если объект, с которым сравнивается, равен null.

+ Рефлексивность: a.equals(a) должен возвращать true.

+ Симметричность: a.equals(b) должен возвращать true тогда и только тогда, когда b.equals(a) возвращает true.

+ Транзитивность: если a.equals(b) возвращает true и b.equals(c) возвращает true, то и a.equals(c) должен возвращать true.

+ Согласованность: если a и b не изменяются, то многократные вызовы a.equals(b) должны последовательно возвращать true или false.

+ Не равен null: a.equals(null) должен возвращать false.

Например, для класса "Person" переопределение метода может выглядеть так:
```java
class Person {
   private String name;
   private int age;

   // Конструктор и геттеры/сеттеры

   @Override
   public boolean equals(Object o) {
       if (o == this) return true;
       if (!(o instanceof Person)) {
           return false;
       }
       Person person = (Person) o;
       return age == person.age &&
               Objects.equals(name, person.name);
   }

   @Override
   public int hashCode() {
       return Objects.hash(name, age);
   }
}
```
Обратите внимание, что вместе с методом equals() нужно переопределить метод hashCode() для обеспечения согласованности и корректной работы хэш-коллекций.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 750. `Если equals() переопределен, есть ли какие-либо другие методы, которые следует переопределить?`

Если метод equals() переопределен в классе Java, то обычно также следует переопределить метод hashCode(). Это связано с тем, что hashCode() используется вместе с equals() при работе с хеш-таблицами и другими коллекциями, которые хранят элементы на основании их хеш-кодов. Если equals() переопределен, а hashCode() - нет, то могут возникнуть проблемы с поиском и удалением элементов в коллекциях.

Вот пример переопределения этих методов для класса Person:
```java
public class Person {
    private String name;
    private int age;
    
    // constructor, getter and setter methods...
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```
Здесь метод equals() сравнивает имя и возраст двух объектов класса Person, а метод hashCode() использует имя и возраст для вычисления их хеш-кода.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 751. `В чем особенность работы методов hashCode и equals?`
В Java метод equals используется для сравнения двух объектов на равенство, в то время как метод hashCode возвращает целочисленный хэш-код объекта.

hashCode используется во многих коллекциях Java (например, HashMap, HashSet и т.д.), чтобы определить расположение объекта в хранилище. Он должен быть реализован таким образом, чтобы каждый объект имел уникальный хэш-код, если это возможно.

equals должен быть переопределен в классе, если мы хотим сравнивать не ссылки на объекты, а их содержимое. При переопределении метода equals также должен быть переопределен метод hashCode таким образом, чтобы объекты, которые равны по содержимому, имели одинаковый хэш-код.

Кроме того, для корректной работы метода equals необходимо соблюдать ряд требований, таких как рефлексивность, транзитивность, симметричность и консистентность.

В целом, для правильной работы многих стандартных классов и интерфейсов Java, таких как коллекции, необходимо корректно реализовать методы hashCode и equals в своих классах.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 752. `Каким образом реализованы методы hashCode и equals в классе Object?`

В Java, класс Object является базовым классом для всех объектов и имеет два метода, hashCode() и equals().

Метод hashCode() возвращает целочисленный хеш-код объекта. Хеш-код обычно используется для уникальной идентификации объекта в коллекциях, таких как HashSet и HashMap. Этот метод должен быть реализован вместе с методом equals(), чтобы обеспечить согласованность между ними.

Метод equals() используется для сравнения объектов на равенство. Он возвращает булево значение true, если объекты равны, и false в противном случае. Этот метод также должен быть реализован вместе с методом hashCode(), чтобы обеспечить согласованность между ними.

Код equals() должен быть рефлексивным, симметричным, транзитивным и консистентным. Код hashCode() должен возвращать одинаковый хеш-код для равных объектов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 753. `Какие правила и соглашения существуют для реализации этих методов? Когда они применяются?`

В Java методы hashCode() и equals() используются для сравнения объектов и поиска элементов в коллекциях. Эти методы должны быть реализованы с определенным набором правил.

Правила hashCode():

+ Если метод equals() возвращает true для двух объектов, то hashCode() для этих объектов должен возвращать одно и то же значение.

+ Если метод equals() возвращает false для двух объектов, то hashCode() для этих объектов может возвращать одно и то же значение, но это не обязательно.

Правила equals():

+ Рефлексивность: Метод equals() должен возвращать true для объекта идентичного самому себе (a.equals(a)).

+ Cимметричность: Если a.equals(b) возвращает true, то b.equals(a) также должен возвращать true.

+ Транзитивность: Если a.equals(b) возвращает true и b.equals(c) возвращает true, то a.equals(c) также должен возвращать true.

+ Консистентность: Если объекты a и b не меняются, то результат a.equals(b) должен оставаться неизменным.

+ Неравенство: a.equals(null) должен возвращать false, а не вызывать исключение.

Эти правила делают возможным корректное сравнение объектов и применение их в различных структурах данных, таких как HashSet или HashMap.

При реализации hashCode() и equals() важно учитывать не только значения полей объекта, но и его реальную сущность и состояние. Также следует позаботиться о реализации hashCode() и equals() во всех классах, который будут использоваться в качестве ключей в HashMap или HashSet, так как это позволит корректно их использовать в Java.

Хеш-код — это число. Если более точно, то это битовая строка фиксированной длины, полученная из массива произвольной длины. В терминах Java, хеш-код — это целочисленный результат работы метода, которому в качестве входного параметра передан объект.

Этот метод реализован таким образом, что для одного и того же входного объекта, хеш-код всегда будет одинаковым. Следует понимать, что множество возможных хеш-кодов ограничено примитивным типом int, а множество объектов ограничено только нашей фантазией. Отсюда следует утверждение: “Множество объектов мощнее множества хеш-кодов”. Из-за этого ограничения, вполне возможна ситуация, что хеш-коды разных объектов могут совпасть.

Здесь главное понять, что:

+ Если хеш-коды разные, то и входные объекты гарантированно разные.
+ Если хеш-коды равны, то входные объекты не всегда равны.

`Ситуация, когда у разных объектов одинаковые хеш-коды называется — коллизией. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.`





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 754. `Какой метод возвращает строковое представление объекта?`

Метод toString() возвращает строковое представление объекта в Java. Каждый объект в Java имеет реализацию метода toString(), которая по умолчанию возвращает строку, содержащую имя класса и хэш-код объекта. Метод toString() может быть переопределен для любого класса, чтобы возвращать нужное строковое представление объекта, например, свойства объекта. 

Например, для получения текстового представления числа 42, нужно создать объект Integer и вызвать метод toString() следующим образом:
```java
Integer myInt = 42;
String intStr = myInt.toString();
System.out.println(intStr); // выводит "42" на консоль
```
Альтернативной короткой записью может быть:
```java
System.out.println(Integer.toString(42));
```
Некоторые классы в стандартной библиотеке Java переопределяют метод toString() для возврата более информативных описаний объекта. Например, toString() для класса Date возвращает дату и время в определенном формате.

Ниже пример с созданием объекта и его выводом в консоль:
```java
public class Person {
  private String name;
  private int age;

  public Person(String name, int age) {
    this.name = name;
    this.age = age;
  }

  @Override
  public String toString() {
    return "Person{name='" + name + "', age=" + age + "}";
  }
}

Person person = new Person("John", 30);
System.out.println(person.toString()); // выводит "Person{name='John', age=30}" 
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 755.  `Что будет, если переопределить equals не переопределяя hashCode? Какие могут возникнуть проблемы?`

В Java, если вы переопределяете метод equals(), вы также должны переопределить метод hashCode(). Это связано с тем, что объекты, реализующие метод equals(), могут использоваться в качестве ключей в хеш-таблицах. При этом вычисление индекса в хеш-таблице осуществляется с помощью метода hashCode(), и если hashCode() не переопределен, то объект может получить неправильный индекс в хеш-таблице или привести к коллизиям.

Таким образом, если переопределить equals() без переопределения hashCode(), то созданные объекты могут работать неправильно в хеш-таблицах и коллекциях, использующих хеш-коды, включая HashMap, HashSet и Hashtable. Поэтому, если вы переопределяете метод equals(), убедитесь, что переопределяете и метод hashCode().



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 756. `Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode?`


Метод hashCode() в Java используется для получения хэш-кода объекта. Хэш-код обычно представляет собой целочисленное значение, которое используется для идентификации объектов в хеш-таблице. Как правило, нет необходимости переопределять метод hashCode(), но если вы это сделаете, следуйте некоторым рекомендациям. 

Одна из рекомендаций состоит в том, что вы должны использовать те же поля для вычисления хэш-кода, которые вы используете для проверки на равенство в методе equals(). Это означает, что если два объекта равны согласно методу equals(), они должны иметь одинаковый хэш-код. Кроме того, обычно рекомендуется рассчитывать хэш-код только на основе значений неизменяемых полей, чтобы гарантировать, что хэш-код не изменится после создания объекта. 

Вот пример того, как вы можете переопределить метод hashCode() для простого класса Person с двумя полями, именем и возрастом:

```java
class Person {
    private final String name;
    private final int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }

    // ...
}

```
В этом примере мы используем метод Objects.hash(), представленный в Java 7, для вычисления хэш-кода на основе полей имени и возраста. Метод Objects.hash() принимает любое количество аргументов и возвращает хэш-код на основе их значений. 

Важно отметить, что даже если хэш-код рассчитан неправильно, код все равно скомпилируется и запустится, но хеш-таблица может работать неправильно, что приведет к ошибкам, которые трудно отлаживать.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 757. `Как вы думаете, будут ли какие-то проблемы, если у объекта, который используется в качестве ключа в hashMap изменится поле, которое участвует в определении hashCode?`

Да, могут возникнуть проблемы при изменении поля ключа объекта, который используется в HashMap. HashMap использует метод hashCode() ключа для определения индекса внутреннего массива, где хранятся значения. Если изменить поле ключа объекта, которое участвует в определении значения hashCode() метода, то это может привести к тому, что ключ не будет найден в HashMap, даже если он должен быть там находиться.

Чтобы избежать таких проблем, необходимо использовать неизменяемые ключи объектов в HashMap, например, String или примитивные типы данных. Если же вы используете свой класс в качестве ключа, то убедитесь, что вы правильно переопределили методы hashCode() и equals() для вашего класса, чтобы они работали корректно при изменении значений полей.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 758. `Чем отличается абстрактный класс от интерфейса, в каких случаях что вы будете использовать?`



Абстрактные классы и интерфейсы являются двумя различными механизмами для моделирования полиморфизма в Java.

`Абстрактные классы`:

+ Они могут содержать как абстрактные, так и конкретные методы.

+ Абстрактный класс может содержать переменные экземпляра.

+ Абстрактный класс может быть расширен подклассом, который может реализовать все абстрактные методы в нем.

+ Абстрактный класс не может быть инициализирован.

+ Абстрактный класс является чем-то похожим на класс-шаблон, который могут использовать подклассы.

`Интерфейсы`:

+ Они могут содержать только абстрактные методы и константы.

+ Интерфейсы не могут содержать переменные экземпляра.

+ Подкласс может реализовать один или несколько интерфейсов.

+ Интерфейсы могут быть множественно реализованы.

+ Интерфейс является спецификацией того, что должен делать класс, но не как это делать.

Использование одного или другого зависит от конкретной задачи, но в целом интерфейсы удобнее тем, что они не создают иерархию наследования классов и не связывают подклассы с реализацией конкретных методов. Если вы хотите определить только поведение, которое классы должны реализовать, лучше использовать интерфейсы. Если вы хотите определять общие свойства, используйте абстрактные классы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 759.  `Можно ли получить доступ к private переменным класса и если да, то каким образом?`

Да, это возможно, но только с помощью рефлексии. В Java рефлексия - это механизм, который позволяет получить доступ к информации о классах, методах, полях и конструкторах во время выполнения программы. Используя рефлексию, можно получить доступ к private полям класса. Ниже приведен пример получения доступа к private полю класса:
```java
import java.lang.reflect.Field;

public class MyClass {
    private String myPrivateField = "private";

    public static void main(String[] args) throws Exception {
        MyClass obj = new MyClass();

        // Получаем объект класса Class, представляющий MyClass
        Class cls = obj.getClass();

        // Получаем объект Field, представляющий поле myPrivateField
        Field field = cls.getDeclaredField("myPrivateField");

        // Разрешаем доступ к полю
        field.setAccessible(true);

        // Получаем значение поля
        String value = (String) field.get(obj);

        // Выводим значение поля
        System.out.println(value);
    }
}
```
В этом примере мы создаем экземпляр класса MyClass, заходим в метаданные класса и получаем доступ к private-полю myPrivateField, устанавливаем доступ к полю, берем значение этого поля и выводим его на экран.

Однако следует понимать, что нарушение инкапсуляции может привести к ошибкам в программе, поэтому использование данного подхода должно быть ограничено крайне необходимыми случаями.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 760. `Что такое volatile и transient? Для чего и в каких случаях можно было бы использовать default?`

В языке Java доступ к private переменным класса можно получить только внутри этого же класса. То есть, если вы пытаетесь обратиться к private переменной другого класса, то вы получите ошибку компиляции.

Однако, есть несколько способов обойти это ограничение. Один из них - использовать сеттеры и геттеры (setter и getter методы), которые позволяют получать и устанавливать значение private переменной через открытые методы. Другой способ - использовать рефлексию, но это не рекомендуется, так как нарушает инкапсуляцию и может привести к непредсказуемому поведению программы.

Вот пример использования сеттера и геттера для доступа к private переменной класса:
```java
public class MyClass {
    private String myPrivateVariable;

    public void setMyPrivateVariable(String value) {
        myPrivateVariable = value;
    }

    public String getMyPrivateVariable() {
        return myPrivateVariable;
    }
}
```
Использование:
```java
MyClass obj = new MyClass();
obj.setMyPrivateVariable("Hello");
String value = obj.getMyPrivateVariable(); // value равно "Hello"
```

В этом примере мы использовали публичные методы setMyPrivateVariable и getMyPrivateVariable для установки и получения значения private переменной myPrivateVariable.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 761. `Расширение модификаторов при наследовании, переопределении и сокрытии методов. Если у класса-родителя есть метод, объявленный как private, может ли наследник расширить его видимость? А если protected? А сузить видимость?`

При наследовании, по умолчанию, методы, объявленные как private, не наследуются и не могут быть доступны в наследнике. При переопределении метода в наследнике, уровень доступа в наследнике не может быть более ограничен, чем в родителе. То есть, если родитель объявил метод с модификатором protected, то метод переопределенный в наследнике может иметь только protected или public уровень доступа.

Таким образом, наследник не может увеличить уровень доступа метода, объявленного как private, но может изменить уровень доступа метода, объявленного как protected, на public при переопределении.

Насколько я понимаю, при сокрытии метода в наследнике, это не относится к уровням доступа, так как сокрытие - это создание нового метода с тем же именем в наследнике. Таким образом, уровень доступа зависит только от модификатора доступа, указанного в сокрываемом методе, и может быть любым, включая private.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 762. `Имеет ли смысл объявлять метод private final?`

Если метод в Java объявлен как private final, то это означает, что метод может быть вызван только из класса, в котором он был объявлен. Модификатор private обеспечивает доступ только внутри класса, а модификатор final гарантирует, что метод не будет переопределен в подклассах.

Если метод не вызывается из других мест в коде и не должен быть переопределен, то можно объявить его как private final. Однако это может привести к трудностям при тестировании, поскольку тестовые классы не смогут вызвать такой метод.

В целом, объявление метода как private final имеет смысл, если он используется только внутри класса и не должен быть переопределен в подклассах. Если метод должен вызываться из других классов или подклассов, то модификаторы доступа нужно сделать более открытыми, например, protected или public.

Например:
```java
public class MyClass {
    private final void doSomethingPrivateAndFinal() {
        // some code here
    }
}
```
В данном примере метод doSomethingPrivateAndFinal() будет доступен только внутри класса MyClass и не сможет быть переопределен.

Но не стоит злоупотреблять объявлением методов как private final, так как это может привести к трудностям переиспользования кода и модификации приложения в будущем.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 763. `Какие особенности инициализации final переменных?`

В Java переменные final могут быть инициализированы только один раз. Инициализация final переменных может происходить как при их объявлении, так и в конструкторе класса. Важно отметить, что не инициализированная final переменная является ошибкой во время компиляции. Если final переменная имеет ссылочный тип данных, то после ее инициализации вы можете изменять ее содержимое, но нельзя присвоить ей новое значение:
```java
public class Example {
    final int x = 1; // объявление и инициализация final переменной

    public Example () {
        final int y; // объявление final переменной без инициализации
        y = 2; // инициализация final переменной
    }

    public void modify(final int z) {
        // нельзя присваивать новое значение z, так как он помечен как final
        System.out.println("z = " + z);
    }
}
```
В данном примере мы можем изменять содержимое ссылочной final переменной s, но не можем присвоить ей новый объект:
```java
public class Example {
    final String s = "Hello"; // объявление и инициализация final переменной

    public void modify() {
        s = "World"; // ошибка компиляции! final переменную нельзя изменить
        System.out.println("String: " + s);
    }
}
```
При объявлении переменной final без ее инициализации компилятор выдаст ошибку. Инициализация может быть произведена при объявлении переменной, в блоках инициализации экземпляра и конструкторе.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 764. `Что будет, если единственный конструктор класса объявлен как final?`

В Java нельзя объявить конструктор как final, потому что модификатор final применяется к переменным, а не к методам или конструкторам. Конструкторы не могут быть переопределены, но их можно наследовать. Однако это может привести к проблемам в производных классах, если конструктор не может быть вызван из них.

Например, если только конструктор базового класса является final, производный класс не сможет его переопределить и может не иметь доступа к каким-то полям или методам базового класса.

Другими словами, объявление конструктора как final является неправильной практикой программирования и может сильно ограничить функциональность класса и его производных классов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 764. `Что такое finalize? Зачем он нужен? Что Вы можете рассказать о сборщике мусора и алгоритмах его работы.`

finalize() - это метод в Java, который позволяет объекту выполнить очистку ресурсов перед удалением сборщиком мусора. Он позволяет объекту выполнить действия перед тем, как он будет удален из памяти. Это может включать закрытие файлов, сетевых соединений или других ресурсов, которые были выделены для использования объектом.

Сборщик мусора в Java является автоматическим механизмом сборки мусора, который автоматически удаляет объекты, которые больше не нужны. Сборщик мусора может работать в различных режимах, например, различных алгоритмах, таких как "метка и очистка" или "копирование", чтобы максимизировать использование доступной памяти и минимизировать время простоя.

Когда объект больше не нужен и в нём больше нет ссылок на него, он будет собран сборщиком мусора, который вызовет метод finalize() перед освобождением памяти, занимаемой объектом. Это позволяет объекту выполнить операции по своей уборке, прежде чем он будет удален из памяти.

Важно заметить, что метод finalize() не гарантирует, что объект будет немедленно удален из памяти. Он может быть вызван сборщиком мусора только после того, как объект станет неотдостижимым для всех потоков исполнения.

Использование finalize() не рекомендуется в Java. Его использование может привести к непредсказуемому поведению, сложностям с производительностью и задержками в сборке мусора. Вместо этого лучше использовать блок try...finally, чтобы гарантировать освобождение ресурсов.

Пример использования finalize():
```java
public class MyClass {
   // переменные и методы класса MyClass
   
   // Переопределение метода finalize()
   protected void finalize() {
      // освобождение ресурсов
   }
}
```
Здесь finalize() в классе MyClass вызывается перед удалением объекта из памяти, т.е., когда сборщик мусора удаляет объект.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 765. `Почему метод clone объявлен как protected? Что необходимо для реализации клонирования?`

Метод clone() в Java объявлен как protected, потому что было решено, что это должен быть метод, доступный только для классов и их подклассов. Более того, для реализации клонирования необходимо реализовать интерфейс Cloneable. Этот интерфейс не имеет методов. Он нужен, чтобы указать, что класс поддерживает клонирование. Если класс не имплементирует Cloneable, то при попытке клонировать объект этого класса будет выброшено исключение CloneNotSupportedException.

Чтобы реализовать клонирование в своем классе, необходимо переопределить метод clone() и вернуть клонированный экземпляр класса, используя метод super.clone(). Затем этот метод должен быть вызван из подкласса в соответствии со своей реализацией клонирования.

Пример реализации клонирования в классе MyClass может выглядеть так:
```java
public class MyClass implements Cloneable {
    private int value;

    public MyClass(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```
Этот код объявляет класс MyClass как Cloneable , переопределяет метод clone() и вызывает super.clone(). Затем, чтобы склонировать экземпляр, можно сделать следующее:
```java
MyClass obj1 = new MyClass(10);
MyClass obj2 = (MyClass) obj1.clone();
```
Теперь obj2 является клоном obj1.



к оглавлению


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 3. Исключения (перейти в раздел)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 766. `Дайте определение понятию “исключение”`
Исключение ("Exception" в Java) - это объект, который представляет ошибку или необычную ситуацию, которая произошла во время выполнения программы. Когда происходит ошибка, Java-машина обычно выбрасывает исключение, чтобы сообщить о проблеме. Это может быть вызвано неверным вводом, попыткой доступа к недействительным данным, сетевыми проблемами и т.д. Обычно исключение можно обработать, используя блок try-catch, либо объявляя их в методах с помощью ключевых слов throws или throw. Обработка исключений в Java дает возможность более гибкого управления ошибками в приложении.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 767. `Какова иерархия исключений.`
![exceptionsInJavaHierarchy](images/java/exceptionsInJavaHierarchy.png)

Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable. Его потомками являются подклассы Exception и Error.

Исключения (Exceptions) являются результатом проблем в программе, которые в принципе решаемы и предсказуемы. Например, произошло деление на ноль в целых числах.

Ошибки (Errors) представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует пытаться обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память, доступная виртуальной машине. Программа дополнительную память всё равно не сможет обеспечить для JVM.


Исключения в Java делятся на два типа: проверяемые и непроверяемые (unchecked). Проверяемые исключения – это те, которые могут возникнуть при выполнении блока кода, и для их обработки требуется явно указывать блок try-catch или передавать их с помощью оператора throws. Непроверяемые исключения – это те, которые наследуются от RuntimeException, их можно не обрабатывать явно в блоке try-catch.

Контролируемые исключения представляют собой ошибки, которые можно и нужно обрабатывать в программе, к этому типу относятся все потомки класса Exception (но не RuntimeException).



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 768. `Можно/нужно ли обрабатывать ошибки jvm?`

JVM может автоматически обрабатывать некоторые ошибки, но часто необходимо написание кода для явной обработки этих ошибок.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 769. `Какие существуют способы обработки исключений?`

В Java есть несколько способов обработки исключений:

+ `Использование блока try-catch`: это позволяет обработать исключение, выброшенное внутри блока try, и выполнить код в блоке catch для обработки этого исключения. Пример:
```java
try {
  // код, который может вызвать исключение
} catch (Exception e) {
  // код для обработки исключения
}
```
+ `Использование блока try-finally`: это позволяет выполнить некоторый код, даже если возникает исключение. Пример:
```java
try {
  // код, который может вызвать исключение
} finally {
  // код, который будет выполнен всегда, даже если возникло исключение
}
```
+ `Использование блока try-catch-finally`: это сочетание двух предыдущих способов и позволяет обработать исключение и выполнить код, даже если оно возникло. Пример:
```java
try {
  // код, который может вызвать исключение
} catch (Exception e) {
  // код для обработки исключения
} finally {
  // код, который будет выполнен всегда, даже если возникло исключение
}
```
+ `Оператор throws`: это позволяет выбросить исключение из метода, чтобы обработать его в другом месте. Пример:
```java
public void someMethod() throws Exception {
  // код, который может вызвать исключение
}
```

+ `Использование оператора throw` для выброса исключения внутри кода. Например:
```java
if (a == 0) {
    throw new Exception("Деление на ноль");
}
```

+ `Создание собственных исключений`. Это позволяет создавать свои собственные классы исключений и генерировать их при необходимости. Например
```java
public class MyException extends Exception {
    public MyException() {}
    public MyException(String message) {
        super(message);
    }
}

// генерируем исключение
throw new MyException("Мое исключение");
```
Эти способы позволяют обрабатывать исключения в Java и делать код более безопасным и устойчивым к сбоям.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 770. `О чем говорит ключевое слово throws?`

Ключевое слово throws в Java используется в объявлении метода для указания списка исключений, которые могут возникнуть, когда метод вызывается. Это помогает вызывающей стороне лучше понимать, какие исключения может выбросить метод, и как нужно обрабатывать их. Если метод может выбросить исключения, то они должны быть обработаны с помощью try-catch или декларированы в блоке throws самого метода.

Например, в следующей сигнатуре метода calculateDivision объявлено ключевое слово throws для указания списка исключений, которые могут возникнуть:
```java
public double calculateDivision(int numerator, int denominator) throws ArithmeticException {
    if (denominator == 0) {
        throw new ArithmeticException("Division by zero");
    }
    return numerator / denominator;
}
```
Это означает, что при вызове метода calculateDivision могут возникнуть исключения типа ArithmeticException, и вызывающая сторона должна либо обработать их с помощью блока try-catch, либо декларировать блок throws в собственной сигнатуре метода.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 771. `В чем особенность блока finally? Всегда ли он исполняется?`
Блок finally в Java выполняется всегда, независимо от того, возникло ли исключение или нет. Это позволяет гарантировать, что определенные критические операции будут выполнены независимо от того, что произойдет в блоке try-catch. Например, если вы используете ресурс, например, открытый файл или соединение с базой данных, блок finally гарантирует, что ресурс будет правильно закрыт, даже если в блоке try произошло исключение.

Если вы используете блок try-catch без блока finally, то может возникнуть ситуация, когда ресурс не будет закрыт, поскольку код, находящийся после блока try-catch, не будет выполнен.

Но стоит отметить, что блок finally не выполняется только в тех случаях, когда программа "упала" или был прерван процесс выполнения посредством вызова метода System.exit().



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 772. `Может ли не быть ни одного блока catch при отлавливании исключений?`
В Java, при отлавливании исключений можно не использовать блок catch, но в этом случае необходимо использовать блок finally. Этот блок будет выполнен в любом случае, независимо от того, генерируется исключение или нет.

Например, следующий код отлавливает исключение IOException с помощью блока finally:
```java
try {
    // code that can throw an IOException
}
finally {
    // cleanup code that will run regardless of whether an exception is thrown or not
}
```
Блок finally может быть использован для освобождения ресурсов, например, закрытия потоков ввода/вывода или сетевых соединений.

Однако, в большинстве ситуаций, следует использовать блок catch для обработки исключений, чтобы обеспечить корректную обработку ошибок в вашем коде.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 773. `Могли бы вы придумать ситуацию, когда блок finally не будет выполнен?`

В Java блок finally всегда будет выполнен, за исключением следующих ситуаций:

+ Если процесс JVM прерывается или останавливается во время работы блока try или catch, или происходит сбой питания.

+ Если в блоке try или catch вызван System.exit(). Во всех остальных случаях блок finally будет выполнен.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 774. `Может ли один блок catch отлавливать несколько исключений (с одной и разных веток наследований)?`

Да, в Java блок catch может отлавливать несколько исключений. Для этого нужно перечислить типы исключений через символ |. Например:
```java
try {
    // выполнение кода, которое может привести к исключению
} catch (IOException | SQLException ex) {
    // обработка исключения типа IOException или SQLException
}
```
Здесь блок catch отлавливает исключения типа IOException или SQLException. Также возможно использование иерархии классов исключений. Например, если класс SQLException является подклассом Exception, то его можно указать как `catch (IOException | Exception ex).`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 775. `Что вы знаете об обрабатываемых и не обрабатываемых (checked/unchecked) исключениях?`

В Java есть два типа исключений: обрабатываемые (checked) и необрабатываемые (unchecked). 


`Обрабатываемые исключения` - это те, которые должны быть обработаны в блоке try-catch или быть перехваченными вызывающим методом. Это исключения, которые могут возникнуть в процессе выполнения программы, но которые программа может и должна обработать. Примерами обрабатываемых исключений являются IOException (возникает, когда происходит сбой ввода-вывода), SQLException (ошибка при выполнении SQL-запроса) и ClassNotFoundException (если класс, на который ссылается программа, не найден во время выполнения).

`Необрабатываемые исключения`, также называемые ошибками, отличаются от обрабатываемых тем, что вызывающий метод не обязан их перехватывать или обрабатывать. Обычно это исключения, которые указывают на ошибки в самой программе, и их следует исправлять, а не обрабатывать. Примеры необрабатываемых исключений включают в себя NullPointerException (возникает, когда программа пытается обратиться к объекту, который не был инициализирован), ArrayIndexOutOfBoundsException (возникает, когда индекс массива находится за пределами допустимого диапазона) и ClassCastException (возникает, когда программа пытается привести объект к неправильному типу).


Пример кода для обработки checked исключений в Java:
```java
try {
    FileInputStream fileInputStream = new FileInputStream("file.txt");
    // do something with the input stream
} catch (FileNotFoundException e) {
    System.out.println("The file was not found.");
}
```
Пример кода для обработки unchecked исключений в Java:
```java
String str = null;
try {
    System.out.println(str.length()); // вызывает java.lang.NullPointerException
} catch (NullPointerException e) {
    System.out.println("The string is null.");
}
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 776. `В чем особенность RuntimeException?`

`public class RuntimeException extends Exception` — базовый класс для ошибок во время выполнения.

Особенность класса RuntimeException в том, что этот класс наследуется от класса Exception, но является подклассом непроверяемых исключений, то есть не требует обработки или объявления с помощью оператора throws. Это сделано для того, чтобы программисты могли легче обрабатывать ошибки, связанные с некорректным использованием методов класса, например, когда указывается неправильный индекс массива или деление на ноль. RuntimeException могут возникать в ходе выполнения программы, и обычно их нельзя заранее предотвратить. Единственное, что можно сделать, - это обработать исключение, если оно возникнет.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 777. `Как написать собственное (“пользовательское”) исключение? Какими мотивами вы будете руководствоваться при выборе типа исключения: checked/unchecked?`

Для написания пользовательского исключения в Java необходимо создать свой класс и унаследовать его от одного из существующих классов исключений. Например, для создания непроверяемого исключения можно унаследоваться от класса RuntimeException, а для создания проверяемого - от класса Exception. В классе-исключении необходимо определить конструкторы и методы, а также можно добавить свои поля и методы.

Пример создания пользовательского проверяемого исключения:
```java
public class MyCheckedException extends Exception {
   public MyCheckedException() { }
   public MyCheckedException(String message) {
      super(message);
   }
}
```
Пример создания пользовательского непроверяемого исключения:
```java
public class MyUncheckedException extends RuntimeException {
   public MyUncheckedException() { }
   public MyUncheckedException(String message) {
      super(message);
   }
}
```
При выборе типа исключения необходимо определить, должен ли вызывающий код обрабатывать это исключение или нет. Если вызывающий код должен обработать исключение, необходимо выбрать проверяемое исключение. В противном случае, если вызывающий код не может обработать исключение или это не имеет смысла, лучше выбрать непроверяемое исключение.

Кроме того, при выборе типа исключения необходимо учитывать, что непроверяемые исключения не обязательно должны быть выброшены из метода или объявлены в его сигнатуре, в отличие от проверяемых исключений. Однако, если исключение выбрасывается и должно быть обработано вызывающим кодом, лучше использовать проверяемое исключение.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 778. `Какой оператор позволяет принудительно выбросить исключение?`

В Java оператор, который позволяет принудительно выбросить исключение, называется throw. Он используется для отправки исключения в явном виде из метода или блока кода. Например, для выброса экземпляра исключения Exception можно использовать следующий код:
```java
throw new Exception("Some error message");
```
где "Some error message" - это сообщение об ошибке, которое будет включено в исключение.

Также следует упомянуть оператор throws, который используется для указания типов исключений, которые могут быть выброшены методом. Он добавляется в сигнатуру метода после блока параметров. Например, следующая сигнатура метода указывает, что он может выбросить исключение типа IOException:
```java
public void myMethod() throws IOException {
  // some code here
}
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 779. `Есть ли дополнительные условия к методу, который потенциально может выбросить исключение?`

Да, есть. Если метод может выбросить исключение, то это должно быть указано в сигнатуре метода при помощи ключевого слова throws, за которым следует список исключений, которые могут быть выброшены. Например:
```java
public void myMethod() throws IOException, InterruptedException {
    // тело метода, которое может вызвать исключение IOException или InterruptedException
}
```
В этом примере метод myMethod() может выбросить два типа исключений: IOException и InterruptedException. Если метод вызывается в другом методе, который не ловит эти исключения, то также должно быть указано, что он тоже может выбросить эти исключения. Это делается аналогичным образом, через ключевое слово throws.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 780. `Может ли метод main выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?`

Да, метод main в Java может выбрасывать исключения. Если исключение не обрабатывается в самом методе main, то оно будет передано системе, которая затем обработает его соответствующим образом. Если исключение не будет обработано ни в одном из методов в стеке вызовов, то Java Virtual Machine (JVM) завершит работу с соответствующим сообщением об ошибке и стеком трассировки (stack trace), который указывает на последовательность вызовов методов, которые привели к возникновению ошибки.

Например, если в методе main было выброшено исключение IOException и оно не было обработано в этом же методе, то ошибка будет передана в систему и может быть обработана либо другими методами в программе, либо обработчиком исключений по умолчанию, который может завершить работу программы и вывести сообщение об ошибке с описанием проблемы и стеком трассировки.

Пример кода, который может выбросить IOException:
```java
import java.io.IOException;

public class Main {
  public static void main(String[] args) throws IOException {
    throw new IOException("Something went wrong");
  }
}
```
В этом примере мы выбрасываем IOException при запуске метода main и указываем, что исключение не будет обрабатываться внутри самого метода, а будет передано выше по стеку вызовов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 781. `Если оператор return содержится и в блоке catch и в finally, какой из них “главнее”?`

Если оператор return содержится и в блоке catch и в блоке finally, то в конечном итоге возвращаемое значение будет зависеть от того, было ли выброшено исключение и было ли оно обработано.

Если исключение было выброшено, то выполнение перейдет в блок catch, и значение, возвращаемое в блоке catch, будет являться конечным результатом. Если исключение не было выброшено, то выполнение перейдет в блок finally, и значение, возвращаемое в блоке finally, будет являться конечным результатом.

Это довольно сложное поведение, и в целом не рекомендуется иметь оператор return в обоих блоках. Вместо этого рекомендуется использовать только один оператор return, и помещать его в блок try перед блоком catch и finally.

Например, вот как это может выглядеть на Java:
```java
public static int myMethod() {
    try {
        // некоторый код, который может вызвать исключение
        return 1;
    } catch (Exception e) {
        // обрабатывать исключение
        return 2;
    } finally {
        // какой-то код, который всегда работает
        return 3;
    }
}
```
Здесь будет возвращено значение 3, потому что блок finally всегда выполняется, а оператор return в блоке finally имеет приоритет по отношению к операторам return в блоках try и catch.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 782. `Что вы знаете о OutOfMemoryError?`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 783. `Что вы знаете о SQLException? К какому типу checked или unchecked оно относится, почему?`

SQLException — это класс исключений в языке программирования Java, представляющий ошибки, возникающие при доступе к базе данных с помощью JDBC. SQLException — это проверенное исключение, что означает, что оно должно быть либо перехвачено, либо объявлено в сигнатуре метода с помощью ключевого слова «throws». Непроверенные исключения, такие как RuntimeException и Error, могут быть выброшены без объявления в сигнатуре метода. 

Причина, по которой SQLException является проверенным исключением, заключается в том, что оно представляет собой исправимую ошибку при доступе к базе данных, и код, использующий JDBC, должен иметь возможность осмысленно обрабатывать эти ошибки. Например, исключение SQLException может быть выдано, если не удается установить соединение с базой данных или если запрос не выполняется из-за синтаксической ошибки. 

Делая SQLException проверенным исключением, язык Java гарантирует, что разработчики знают об этих возможных состояниях ошибок и вынуждены обрабатывать их в своем коде. Следовательно, чтобы использовать JDBC в Java, вы должны либо обрабатывать SQLException с помощью блок try-catch или объявите его, используя ключевое слово «throws» в сигнатуре метода.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 784. `Что такое Error? В каком случае используется Error. Приведите пример Error’а.`

Error — это класс в Java, представляющий ошибку времени выполнения или ошибку, связанную с приложением, которую нельзя исправить. Исключение Error возникает, когда возникает серьезная проблема, от которой программа не должна пытаться восстановиться. Примеры ситуаций, которые могут привести к ошибке, включают исчерпание ресурсов на уровне системы, отсутствие системных файлов и переполнение стека. Вот пример того, как выдать ошибку в Java:

```java
if (someCondition) {
   throw new Error("This is an example of an Error");
}
```

В этом примере выдается ошибка с сообщением «Это пример ошибки», если условие истинно. Программа не должна пытаться исправить эту ошибку, а вместо этого должна завершить работу или предпринять другие соответствующие действия.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 785. `Какая конструкция используется в Java для обработки исключений?`

В Java для обработки исключений используется конструкция try-catch. Вы можете обернуть код, который может вызвать исключение, в блок try, после которого следует один или несколько блоков catch, которые будут выполнены при возникновении исключения определенного типа. Конструкция try-catch позволяет вам обрабатывать исключения в вашем коде, избежать аварийных остановок и скрыть детали ошибок от конечного пользователя. Пример:
```java
try {
    // Код, который может вызвать исключение
} catch (SomeException e) {
    // Код, который обрабатывает исключение типа SomeException
}
```
Если вам нужно выполнить код после завершения блока try (независимо от того, возникло исключение или нет), вы можете использовать блок finally. Пример:
```java
try {
    // Код, который может вызвать исключение
} catch (SomeException e) {
    // Код, который обрабатывает исключение типа SomeException
} finally {
    // Код, который будет выполнен после завершения блока try-catch, независимо от того, возникло исключение или нет.
}
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 786. `Предположим, есть блок try-finally. В блоке try возникло исключение и выполнение переместилось в блок finally. В блоке finally тоже возникло исключение. Какое из двух исключений “выпадет” из блока try-finally? Что случится со вторым исключением?`

Если в блоке try возникает исключение, а затем выполнение уходит в блок finally, и там возникает исключение, то это второе исключение "перебросится" вверх по стеку вызовов методов в вызывающий код, в то время как первое исключение будет потеряно.

Конкретная реакция на второе исключение будет зависеть от того, обрабатывается ли его кодом в вызывающем методе или перебрасывается выше. Однако, исключения в блоке finally могут затруднить отладку программы, так как первоначальная причина исключения может быть скрыта, а стек вызовов может быть запутанным. Из-за этого рекомендуется избегать использования вложенных блоков try-finally, а также тщательно обрабатывать исключения, которые могут возникнуть в блоке finally.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 786 `Предположим, есть метод, который может выбросить IOException и FileNotFoundException в какой последовательности должны идти блоки catch? Сколько блоков catch будет выполнено?`

Если метод может выбросить исключения IOException и FileNotFoundException, то блоки catch должны следовать в порядке от конкретного к более общему, то есть сначала нужно перехватывать FileNotFoundException, а затем IOException. Это связано с тем, что FileNotFoundException является конкретным подклассом IOException, и при наличии нескольких блоков catch будет выполнен только первый, который соответствует типу выброшенного исключения.

Следующий код демонстрирует правильный порядок блоков catch для обработки исключений IOException и FileNotFoundException:
```java
try {
    // код, который может выбросить IOException или FileNotFoundException
} catch (FileNotFoundException e) {
    // обработка FileNotFoundException
} catch (IOException e) {
    // обработка IOException
}
```
В зависимости от того, какие исключения будут выброшены, будет выполнен либо первый блок catch, либо второй, но не оба сразу.


к оглавлению


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 4. Коллекции (перейти в раздел)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 787. `Дайте определение понятию “коллекция”.`
"Коллекция" - это набор элементов, которые могут храниться и использоваться вместе в рамках одной структуры данных. В Java "коллекции" обеспечивают удобную и эффективную работу с группами элементов различного типа и объема. Java Collections Framework является частью стандартной библиотеки Java, которая предоставляет реализацию множества структур данных, таких как списки, множества, отображения и т.д. Все коллекции фреймворка Java реализуют общие интерфейсы, которые позволяют использовать их единообразно и удобно в программе.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 788. `Назовите преимущества использования коллекций.`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 789. `Какие данные могут хранить коллекции?`

Коллекции в Java могут хранить различные типы данных, в зависимости от типа коллекции.

Например, в ArrayList и LinkedList можно хранить любые ссылочные типы данных (например, объекты классов). В HashSet и TreeSet можно хранить уникальные элементы любого типа данных (при условии, что они реализуют интерфейс hashCode() и equals()). В HashMap и TreeMap можно хранить пары "ключ-значение" любых типов данных, и т.д.

Java Collections Framework также предоставляет специализированные коллекции для хранения определенных типов данных, например, Vector для хранения объектов в последовательности, Stack для реализации стека, PriorityQueue для хранения элементов в порядке их приоритета и т.д.

Таким образом, коллекции в Java могут хранить широкий диапазон данных, начиная от примитивных типов до сложных объектов, в зависимости от выбранной коллекции и типов данных, которые вы хотите хранить в ней.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 790. `Какова иерархия коллекций?`
![CollectionsHierarchy](images/java/CollectionsHierarchy.png)

В Java коллекции организованы в виде иерархии классов и интерфейсов. На вершине этой иерархии находится интерфейс Collection, а интерфейс Map является отдельной ветвью. Вот некоторые интерфейсы и классы, относящиеся к этой иерархии:

Вот основные интерфейсы Java коллекций:
```
+ Collection
      AbstractCollection
      ArrayList
      LinkedList

+ List
      AbstractList
      ArrayList
      LinkedList
+ Set
      AbstractSet
      HashSet
      LinkedHashSet
+ SortedSet
      TreeSet
+ NavigableSet
      TreeSet
+ Queue
      AbstractQueue
      LinkedList
      PriorityQueue
+ Deque
      ArrayDeque
      LinkedList
```
Collection представляет общую структуру всех коллекций, а List, Set, Queue и Map представляют различные типы коллекций. Классы, такие как ArrayList и HashSet, предоставляют конкретную реализацию этих интерфейсов. Они значительно различаются по своим особенностям, таким как производительность, порядок хранения элементов и возможность хранения дубликатов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 791. `Что вы знаете о коллекциях типа List?`

`Java Collections типа List` - это упорядоченная коллекция элементов, которая может содержать дублирующиеся элементы. Она предоставляет методы для добавления, удаления и доступа к элементам по индексу. Некоторые из наиболее распространенных классов, реализующих интерфейс List, включают ArrayList, LinkedList и Vector.

`ArrayList` - это изменяемый список, который расширяется по мере необходимости и позволяет быстро доступать к элементам по индексу.

`LinkedList` - это двунаправленный связанный список, который позволяет быстро добавлять и удалять элементы из начала и конца списка.

`Vector` - это синхронизированный список, который подобен ArrayList, но обеспечивает потокобезопасность при одновременном доступе из нескольких потоков.

Интерфейс List предоставляет методы, такие как add(), remove(), get(), indexOf() и size(), которые позволяют манипулировать списком элементов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 792. `Что вы знаете о коллекциях типа Set?`
Set (множество) в Java - это коллекция, которая хранит уникальные элементы в неупорядоченном виде. Элементы, добавленные в Set, должны быть уникальными, то есть Set не может содержать дубликаты.

Set в Java является интерфейсом, который реализует коллекцию, содержащую только уникальные элементы. Он представлен классами HashSet, TreeSet и LinkedHashSet.

HashSet не содержит дубликатов и не гарантирует порядок хранения элементов.

TreeSet хранит элементы в отсортированном порядке, который может быть настраиваемым.

LinkedHashSet гарантирует сохранение порядка элементов в том порядке, в котором они были добавлены.

Интерфейс Set также имеет несколько полезных методов, таких как add() для добавления элемента, remove() для удаления элемента и contains() для проверки наличия элемента в наборе.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 793. `Что вы знаете о коллекциях типа Queue?`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 794. `Что вы знаете о коллекциях типа Map, в чем их принципиальное отличие?`
Коллекции типа Map в Java представляют собой структуру данных, которая содержит пары ключ-значение и позволяет быстро находить значение по его ключу. Они отличаются от других коллекций, таких как List и Set, тем, что элементы в Map хранятся в виде пар ключ-значение, а не отдельных элементов. Ключи должны быть уникальными, в то время как значения могут повторяться. Map-ы могут быть реализованы различными способами, но основными реализациями являются HashMap, TreeMap и LinkedHashMap.

`HashMap` - это наиболее распространенная реализация Map-а в Java. Он предоставляет постоянное время выполнения для основных операций, таких как get() и put(). Однако порядок элементов в HashMap не гарантируется.

`TreeMap` - это реализация, которая хранит пары ключ-значение в отсортированном порядке, основанном на ключе. В отличие от HashMap, TreeMap гарантирует порядок элементов.

`LinkedHashMap` - это реализация, которая сохраняет порядок вставки элементов. Ключи хранятся в том порядке, в котором они были добавлены.

В целом, использование Map позволяет эффективно хранить и доступаться к данным по ключу. Конкретная реализация Map должна выбираться в зависимости от требований к производительности и составу данных.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 795. `Назовите основные реализации List, Set, Map.`
В Java есть несколько основных реализаций интерфейсов List, Set и Map:
```
List:
    ArrayList
    LinkedList
    Vector (устаревший)

Set:
    HashSet
    LinkedHashSet
    TreeSet

Map:
    HashMap
    LinkedHashMap
    TreeMap
    Hashtable (устаревший)
```
Эти реализации предоставляют разные способы хранения и организации данных в список, множество или отображение.

Например, ArrayList хранит элементы в массиве и позволяет быстрый доступ к элементам по индексу, в то время как LinkedList хранит элементы в виде связанного списка и имеет быстрое добавление и удаление элементов.

HashSet использует хэш-функцию для быстрого поиска элементов в множестве, LinkedHashSet поддерживает порядок вставки элементов, а TreeSet хранит элементы в отсортированном порядке.

HashMap использует хэш-таблицу для быстрого поиска элементов по ключу, LinkedHashMap поддерживает порядок вставки элементов, а TreeMap хранит элементы в отсортированном порядке ключей.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 796. `Какие реализации SortedSet вы знаете и в чем их особенность?`
Существует несколько реализаций интерфейса SortedSet в Java, включая:

`TreeSet` - основанная на TreeMap, имеет время доступа O(log n) для операций добавления, удаления и поиска элементов. Элементы будут автоматически отсортированы в порядке возрастания.

`ConcurrentSkipListSet` - это потокобезопасная реализация SortedSet, основанная на ConcurrentSkipListMap, с доступным временем O(log n) для операций добавления, удаления и поиска элементов. Он использует блокировки, которые позволяют нескольким потокам одновременно изменять набор.

`CopyOnWriteArraySet` - это потокобезопасная реализация SortedSet, основанная на CopyOnWriteArrayList, которая предоставляет последовательный доступ к элементам. Это означает, что время доступа к элементу O(n), но операции добавления, удаления и поиска элементов являются потокобезопасными, так как копия набора создается при каждой модификации.

`EnumSet` - это реализация SortedSet, которая предназначена только для перечислений. Он использует битовые флаги для представления элементов множества и поэтому не может изменять размер после создания. Он быстр и использует меньше памяти, чем другие реализации множества.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 797. `В чем отличия/сходства List и Set?`

В Java, List и Set являются двумя разными типами коллекций, которые предоставляют различные способы организации и работы с набором элементов.

List представляет собой упорядоченную коллекцию элементов, которые могут содержать повторяющиеся значения. Доступ к элементам осуществляется по индексу, то есть каждый элемент имеет свой порядковый номер. Примерами реализаций List являются ArrayList и LinkedList.

Set представляет собой неупорядоченную коллекцию уникальных элементов. Каждый элемент может встречаться только один раз. Доступ к элементам осуществляется через методы, предоставляемые самим интерфейсом Set. Примерами реализаций Set являются HashSet и TreeSet.

В общем смысле List и Set имеют несколько различающиеся свойства:

+ List поддерживает дублирование элементов, Set - нет;

+ List обеспечивает доступ к элементам по индексу, а Set - нет;

+ Set гарантирует, что не будет дублирования элементов, List - нет;

+ Set хранит элементы в произвольном порядке, в то время как List - в порядке их добавления.

Выбор между List и Set зависит от конкретного случая использования коллекции и требований к ее поведению.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 798. `Что разного/общего у классов ArrayList и LinkedList, когда лучше использовать ArrayList, а когда LinkedList?`

Оба класса ArrayList и LinkedList реализуют интерфейс List в Java и предоставляют реализацию динамического массива. Однако, есть некоторые ключевые различия:

+ Сложность операций вставки/удаления элемента:

+ + В ArrayList при вставке/удалении элемента происходит смещение всех последующих элементов в памяти, что требует больше времени для выполнения операции;

+ + В LinkedList такие операции затрагивают только соседние элементы, но требуют более сложной работы с указателями.

+ Доступ к элементам:

+ + В ArrayList к элементу можно обращаться по индексу, что позволяет производить доступ за O(1) времени;

+ + В LinkedList к элементу необходимо обращаться последовательно, что может затянуться на O(n) времени.

Поэтому, если в приложении используются операции вставки/удаления элементов, преимущественно в начале/конце списка, рекомендуется использовать LinkedList, а если приложение быстрее работает с доступом к элементу по индексу, то следует использовать ArrayList.

Небольшой exception будет, если вы работаете с большими наборами данных (несколько миллионов элементов): в таком случае ArrayList намного эффективнее, чем LinkedList.

ArrayList хранит элементы в виде массива переменной длины, который автоматически расширяется по мере добавления новых элементов в список. LinkedList представляет собой двусвязный список, который хранит ссылки на следующий и предыдущий узлы.

+ `Когда использовать ArrayList`:

+ + если требуется доступ к элементам списка по индексу, т.е. нужен быстрый доступ к произвольным элементам

+ + если требуется итерация (перебор) списка, особенно в одном направлении.

+ `Когда использовать LinkedList`:

+ + если необходимо добавлять или удалять элементы в середине списка

+ + при интенсивном использовании операций вставки и удаления, особенно для больших списков.

Таким образом, оба класса предоставляют реализацию списка, но используют разные методы хранения элементов, поэтому выбор зависит от конкретных требований приложения.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 799. `В каких случаях разумно использовать массив, а не ArrayList?`

В Java массивы используются для хранения элементов фиксированного размера. Однако, если вам нужно хранить элементы переменной длины, то лучшим выбором будет ArrayList, который реализует интерфейс List и автоматически увеличивает свой размер при добавлении новых элементов.

Использование массивов в Java может оказаться разумным в случаях, когда:

+ Вы знаете заранее фиксированный размер элементов;

+ Вам нужен прямой доступ к элементам по индексу;

Вам нужно хранить примитивные типы данных (такие как int, double), которые могут быть размещены непосредственно в массиве.

Однако в остальных случаях, рекомендуется использовать ArrayList, который упрощает добавление и удаление элементов и позволяет динамически изменять размер коллекции.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 800. `Чем отличается ArrayList от Vector?`
В Java классы ArrayList и Vector реализуют интерфейс List и имеют схожую реализацию динамического массива. Но есть несколько отличий:

+ `Синхронизация`: Vector'ы синхронизированы по умолчанию, что может привести к небольшому падению производительности. ArrayList'ы по умолчанию не синхронизированы и не потокобезопасны.

+ `Размер массива`: Когда элементы добавляются в Vector, он инкрементирует размер массива на 100% (или на другой заданный процент). ArrayList инкрементирует размер массива на 50% его текущего размера.

+ `Итераторы:` Итераторы для обоих классов реализованы одинаково, но для Vector рекомендуется использовать его старшую сестру - Enumeration.

В общем, если вы не работаете в многопоточном окружении или вам не нужна дополнительная синхронизация, то ArrayList более предпочтительный выбор благодаря своей лучшей производительности. Если нужна синхронизация, то рекомендуется использовать классы, которые реализуют интерфейс List вместо Vector.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 801. `Что вы знаете о реализации классов HashSet и TreeSet?`

HashSet и TreeSet - это два класса в Java, которые унаследованы от интерфейса Set и предоставляют доступ к набору уникальных элементов.

HashSet реализует паттерн хэш-таблицы и является наиболее популярным классом множества в Java. В отличие от списка, который хранит элементы в последовательном порядке, HashSet хранит элементы в случайном порядке. Элементы HashSet хранятся в виде хэш-кодов, что обеспечивает быстрый поиск элементов. Класс HashSet не гарантирует порядок, в котором элементы будут возвращены при итерировании по множеству.

TreeSet реализует интерфейсы NavigableSet и SortedSet, что означает, что элементы в нем будут храниться в отсортированном порядке. Класс TreeSet сохраняет элементы в древовидной структуре, что обеспечивает быстрый доступ к элементам, а также возможность выполнять операции, связанные с диапазонами элементов. Однако, TreeSet медленнее, чем HashSet, потому что для каждой операции добавления, удаления и поиска элемента необходимо выполнить дополнительные манипуляции со структурой дерева.

Также следует учитывать, что при использовании TreeSet необходимо, чтобы добавляемые элементы были сравнимы или был передан компаратор при создании объекта TreeSet.

Несмотря на различия в их реализации, оба класса имеют одинаковую сложность времени выполнения для основных операций, таких как вставка, удаление и поиск элемента, равную O(1) в среднем случае и O(N) в худшем случае.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 802. `Чем отличаются HashMap и TreeMap? Как они устроены и работают? Что со временем доступа к объектам, какие зависимости?`

HashMap и TreeMap являются двумя реализациями интерфейса Map в Java, оба позволяют хранить пары ключ-значение и обеспечивают быстрый доступ к элементам за O(1) и O(log n) времени соответственно.

Основное отличие между HashMap и TreeMap заключается в том, что HashMap не гарантирует порядок элементов, в то время как TreeMap поддерживает упорядоченный список элементов по ключу, основанный на естественном порядке сортировки или порядке, определяемом пользователем через реализацию интерфейсов Comparable или Comparator. HashMap реализована с помощью хеширования, тогда как TreeMap использует красно-черное дерево для хранения элементов.

Доступ к элементам в HashMap происходит быстрее, чем в TreeMap, но порядок элементов не гарантирован, а ассимптотическая сложность удаления и вставки элементов в HashMap в худшем случае O(n), хотя в большинстве случаев это O(1). TreeMap гарантирует логарифмическую асимптотическую сложность для поиска, удаления и вставки элементов за счет своей структуры хранения и поддержки упорядоченного списка элементов.

Если нам нужно упорядочить элементы по ключу, то TreeMap будет лучшим выбором, в противном случае использование HashMap является более эффективным выбором.

Что касается времени доступа к объектам, в общем случае время доступа и добавления элементов в HashMap и TreeMap относительно одинаковое и зависит от размера коллекции. Однако, в TreeMap операции прохода по коллекции и удаления элементов могут занимать больше времени из-за того, что TreeMap должен сохранять свой порядок.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 803. `Что такое Hashtable, чем она отличается от HashMap? На сегодняшний день она deprecated, как все-таки использовать нужную функциональность?`

Hashtable и HashMap - это две разные имплементации интерфейса Map в Java. Hashtable появилась в Java 1.0, а HashMap - в Java 1.2. Основное отличие между ними заключается в том, что Hashtable является потокобезопасной структурой данных, что означает, что ее методы синхронизированы и ее можно использовать в нескольких потоках одновременно без риска возникновения проблем с параллельным доступом. Однако, это может замедлять работу программы и создавать лишние накладные расходы в случае, если этой функциональности не требуется.

Следует отметить, что на сегодняшний день Hashtable является устаревшей и не рекомендуется к использованию. Вместо нее стоит использовать ConcurrentHashMap, который также является потокобезопасной каратой, но более эффективно реализован по сравнению с Hashtable. А для непотокобезопасных задач стоит использовать HashMap.

Кроме того, можно использовать связку коллекций и методов из пакета java.util.concurrent в зависимости от требований конкретной задачи для достижения наилучшей производительности.

Пример использования ConcurrentHashMap:
```java
Map<String, String> myMap = new ConcurrentHashMap<>();
myMap.put("key", "value");
String value = myMap.get("key");
```
Пример использования HashMap:
```java
Map<String, String> myMap = new HashMap<>();
myMap.put("key", "value");
String value = myMap.get("key");
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 804. `Что будет, если в Map положить два значения с одинаковым ключом?`

Если в Map положить два значения с одинаковым ключом, то первое значение будет заменено вторым. При этом, если метод put() будет вызван второй раз с тем же ключом, то ключ будет обновлен со значением, переданным вторым аргументом.

Например, рассмотрим следующий код на Java:
```java
Map<String, Integer> map = new HashMap<>();
map.put("apple", 1);
map.put("banana", 2);
map.put("apple", 3);
System.out.println(map.get("apple")); // выведет 3
```
Здесь мы создали HashMap и поместили в него две пары ключ-значение. Затем мы обновили значение, связанное с ключом "apple", вызвав метод put() еще раз с этим же ключом. В результате, выводится значение 3, поскольку ключ "apple" был перезаписан со значением 3.

Если же ключи будут различаться, то в Map будут храниться пары уникальных ключей и значений, каждый из которых можно будет получить при обращении к соответствующему ключу.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 805. `Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?`

Для задания порядка следования объектов в коллекции можно использовать интерфейс java.util.Comparable. Этот интерфейс имеет метод compareTo(), который определяет порядок следования элементов. Если вы хотите отсортировать коллекцию на основе этого порядка, вы можете использовать метод Collections.sort().

Если нужна более гибкая сортировка, можно использовать интерфейс java.util.Comparator. Этот интерфейс позволяет определить более сложные правила сортировки, например, с помощью нескольких критериев сортировки или сортировки в обратном порядке.

Вот примеры:

+ Сортировка с использованием Comparable:
```java
public class MyClass implements Comparable<MyClass> {
    private int value;

    public MyClass(int value) {
        this.value = value;
    }

    public int compareTo(MyClass other) {
        return Integer.compare(this.value, other.value);
    }
}
```
Затем можно отсортировать список объектов MyClass с помощью метода Collections.sort():
```java
List<MyClass> list = new ArrayList<>();
list.add(new MyClass(3));
list.add(new MyClass(1));
list.add(new MyClass(2));
Collections.sort(list);
```
Сортировка с использованием Comparator:
```java
public class MyComparator implements Comparator<MyClass> {
    public int compare(MyClass a, MyClass b) {
        return Integer.compare(a.getValue(), b.getValue());
    }
}
```
Используйте Collections.sort() для сортировки списка объектов MyClass с помощью этого компаратора:
```java
List<MyClass> list = new ArrayList<>();
list.add(new MyClass(3));
list.add(new MyClass(1));
list.add(new MyClass(2));
Collections.sort(list, new MyComparator());
```
Если нет необходимости переопределять compareTo() в классе элементов коллекции, нет смысла создавать отдельный класс компаратора. Можно воспользоваться методом Collections.sort() 



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 806. `Дайте определение понятию “итератор”.`

На Java, итераторы представляют собой механизм доступа к элементам коллекции без необходимости знать ее внутреннюю реализацию. Итератор позволяет проходить по коллекции последовательно и удалять элементы во время итерации. Он имеет три основных метода: hasNext(), next(), remove(). Метод hasNext() возвращает true, если есть следующий элемент в коллекции, который может быть прочитан методом next(). В свою очередь, метод next() возвращает следующий элемент и переходит к следующему. Метод remove() удаляет последний элемент, который был возвращен методом next() и удаляет его из коллекции. Итераторы являются частью Java Collections Framework, который содержит реализации множества различных типов коллекций, таких как списки, множества, словари и очереди. Вот пример использования итератора для прохода по списку и вывода каждого элемента:
```java
List<String> myList = new ArrayList<String>();
myList.add("foo");
myList.add("bar");
myList.add("baz");

Iterator<String> iter = myList.iterator();
while (iter.hasNext()) {
    String item = iter.next();
    System.out.println(item);
}
```
Этот код выведет элементы списка в порядке добавления: foo, bar, baz.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 807. `Какую функциональность представляет класс Collections?`
Класс Collections в Java является утилитным классом, предоставляющим различные методы для работы со структурами данных, реализующими интерфейсы Collection, List, Set и Map. Некоторые из этих методов включают сортировку, перетасовку, копирование, заполнение, объединение и другие операции над коллекциями.

Например, метод sort позволяет отсортировать список, реализующий интерфейс List, по возрастанию или убыванию, а метод shuffle перемешивает элементы списка в случайном порядке.

Пример использования метода sort:
```java
List<Integer> list = new ArrayList<>();
list.add(3);
list.add(1);
list.add(2);
Collections.sort(list); // Сортировка списка по возрастанию
System.out.println(list); // [1, 2, 3]
```
Пример использования метода shuffle:
```java
List<Integer> list = new ArrayList<>();
list.add(1);
list.add(2);
list.add(3);
Collections.shuffle(list); // Перемешивание элементов списка 
System.out.println(list); // [2, 3, 1] (результат может быть другим в зависимости от порядка элементов)
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 808. `Как получить не модифицируемую коллекцию?`

Чтобы получить неизменяемую коллекцию в Java, вы можете использовать метод Collections.unmodifiedCollection(), предоставляемый классом java.util.Collections. Например, предположим, что у вас есть ArrayList, который вы хотите сделать немодифицируемым:


```java
import java.util.*;

List<String> list = new ArrayList<>();
list.add("one");
list.add("two");
list.add("three");

Collection<String> unmodifiable = Collections.unmodifiableCollection(list);

```
Теперь неизменяемая коллекция содержит те же элементы, что и коллекция списка, но ее нельзя изменить. Если вы попытаетесь добавить или удалить элементы из неизменяемой коллекции, будет выдано исключение UnsupportedOperationException.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 809. `Какие коллекции синхронизированы?`

В Java в классе Collections есть несколько коллекций, которые могут быть синхронизированы. Эти коллекции являются безопасными для использования в многопоточных приложениях, когда несколько потоков имеют доступ к одним и тем же коллекциям. Некоторые из синхронизированных коллекций в Java включают:

+ `ArrayList` - существует синхронизированная версия - Collections.synchronizedList(), которая возвращает синхронизированный список.

+ `LinkedList` - также имеет синхронизированную версию - Collections.synchronizedList().

+ `Hashtable` - этот класс представляет устаревшую, но синхронизированную реализацию интерфейса Map.

+ `Vector` - также представляет устаревшую, но синхронизированную реализацию интерфейса List.

Новые коллекции, такие как ArrayList и HashMap, которые были добавлены в Java, не синхронизированы по умолчанию. Однако, вы можете использовать класс Collections.synchronizedList() для создания синхронизированных версий этих коллекций.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 810. `Как получить синхронизированную коллекцию из не синхронизированной?`

Чтобы получить синхронизированную коллекцию из несинхронизированной в Java, можно использовать методы класса Collections. Например, чтобы получить синхронизированный список из несинхронизированного, можно использовать метод synchronizedList:
```java
List<String> unsynchronizedList = new ArrayList<>();
List<String> synchronizedList = Collections.synchronizedList(unsynchronizedList);
```
Аналогично можно получить синхронизированные версии Set и Map, используя методы synchronizedSet и synchronizedMap. Вот полный пример:
```java
List<String> unsynchronizedList = new ArrayList<>();
List<String> synchronizedList = Collections.synchronizedList(unsynchronizedList);

Set<String> unsynchronizedSet = new HashSet<>();
Set<String> synchronizedSet = Collections.synchronizedSet(unsynchronizedSet);

Map<String, Integer> unsynchronizedMap = new HashMap<>();
Map<String, Integer> synchronizedMap = Collections.synchronizedMap(unsynchronizedMap);
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 811. `Как получить коллекцию только для чтения?`

Чтобы получить неизменяемую (только для чтения) коллекцию в Java, можно использовать методы из класса Collections. Например, для создания неизменяемого списка можно использовать метод Collections.unmodifiableList(), для создания неизменяемого множества - Collections.unmodifiableSet(), и т.д. Здесь пример создания неизменяемого списка:
```java
List<String> originalList = new ArrayList<>();
originalList.add("one");
originalList.add("two");
originalList.add("three");
List<String> unmodifiableList = Collections.unmodifiableList(originalList);
```
После этого unmodifiableList будет неизменяемым, то есть любые попытки изменить его содержимое приведут к генерации исключения UnsupportedOperationException. Чтобы получить неизменяемую коллекцию из какой-то другой коллекции, можно использовать метод unmodifiableXXX() из класса Collections:
```java
List<String> originalList = new ArrayList<>();
originalList.add("one");
originalList.add("two");
originalList.add("three");
List<String> unmodifiableList = Collections.unmodifiableList(originalList);
Set<String> originalSet = new HashSet<>(originalList);
Set<String> unmodifiableSet = Collections.unmodifiableSet(originalSet);
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 812. `Почему Map не наследуется от Collection?`
Map в Java не наследуется от Collection, потому что она не является коллекцией в смысле хранения и управления группой объектов. Map является отображением, которое связывает каждый ключ со своим значением, поэтому обычные операции над коллекциями, такие как добавление, удаление и поиск, не работают для Map в том же самом контексте. Вместо этого Map имеет свои уникальные методы, такие как put() и get(), которые позволяют добавлять и получать значения, связанные с определенными ключами. Таким образом, Map является своего рода контейнером, но не реализует интерфейс Collection и не является его подклассом.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 813. `В чем разница между Iterator и Enumeration?`

Iterator и Enumeration - это два интерфейса в Java для перебора элементов в коллекциях.

Основное отличие между Iterator и Enumeration заключается в возможности удаления элемента во время перебора коллекции. Итератор позволяет удалить элемент, который был возвращен последним вызовом next(). Enumeration не позволяет удалять элементы, а также не имеет метода forEachRemaining(), который позволяет выполнить операцию для каждого оставшегося элемента коллекции.

Другое отличие между Iterator и Enumeration заключается в том, что Iterator предоставляет более безопасное и эффективное итерирование по элементам коллекции, чем Enumeration, и может быть использован совместно со многими коллекциями (ArrayList, LinkedList, HashSet и т. д.), в то время как Enumeration ограничен на некоторых коллекциях (Hashtable и Vector).



+ Пример использования Iterator в Java:
```java
List<String> myCollection = new ArrayList<>();
// добавление элементов в коллекцию
Iterator<String> it = myCollection.iterator();
while (it.hasNext()) {
    String element = it.next();
    // обработка элемента
}
```
+ Пример использования Enumeration в Java:
```java
Vector<String> myVector = new Vector<>();
// добавление элементов в вектор
Enumeration<String> en = myVector.elements();
while (en.hasMoreElements()) {
    String element = en.nextElement();
    // обработка элемента
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 814. `Как реализован цикл foreach?`

В Java цикл foreach также называется циклом "for-each". Этот цикл используется для перебора элементов массивов или коллекций без явного указания индекса. Вот пример использования цикла for-each для перебора элементов массива:
```java
int[] nums = {1, 2, 3, 4, 5};
for (int num : nums) {
    System.out.println(num);
}
```
Этот код выведет на консоль числа от 1 до 5.

Этот же цикл можно использовать для перебора элементов коллекций, например ArrayList:
```java
ArrayList<String> names = new ArrayList<>();
names.add("Alice");
names.add("Bob");
names.add("Charlie");
for (String name : names) {
    System.out.println(name);
}
```
Этот код выведет на консоль имена Alice, Bob и Charlie.

Цикл for-each не подходит для тех случаев, когда необходим доступ к индексу элемента или когда нужно изменять элементы коллекции внутри цикла. В этих случаях лучше использовать обычный цикл for.

Вот некоторые примеры использования цикла foreach в Java для массива и коллекции:

Пример для массива:
```java
int[] arr = {1, 2, 3, 4, 5};
for (int num : arr) {
    System.out.println(num);
}
```
Пример для коллекции:
```java
List<String> list = new ArrayList<>();
list.add("foo");
list.add("bar");
for (String str : list) {
    System.out.println(str);
}
```
Здесь переменная num принимает значение каждого элемента массива arr по порядку, а переменная str принимает значение каждого элемента коллекции list по порядку. Вы можете использовать эти переменные для выполнения каких-либо операций с каждым элементом.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 815. `Почему нет метода iterator.add() чтобы добавить элементы в коллекцию?`
В интерфейсе java.util.Iterator нет метода add(), так как это лишь итератор для прохода по элементам коллекции, и его задача заканчивается на чтении элементов. Если вам нужно добавить элементы в коллекцию, используйте соответствующие методы коллекции, такие как add() для списков List или HashSet, или put() для карт Map. Пример использования метода add():
```java
List<String> list = new ArrayList<>();
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    String element = it.next();
    if (someCondition) {
        list.add(newElement); // Ошибка ConcurrentModificationException, вызванная перебором и модификацией внутри оного
    }
}
```
list.add(newElement); вызовет ошибку ConcurrentModificationException, так как мы не можем изменять коллекцию во время итерации по ней.

Если вы хотите добавить элементы в коллекцию, в то время как вы перебираете её элементы, используйте ListIterator, который содержит метод add() для этой цели. Вы можете получить ListIterator, вызвав метод listIterator() на списке:
```java
List<String> list = new ArrayList<>();
ListIterator<String> it = list.listIterator();
while (it.hasNext()) {
    String element = it.next();
    if (someCondition) {
        it.add(newElement); // Добавление элемента в список, вызов не вызовет ConcurrentModificationException
    }
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 816. `Почему в классе iterator нет метода для получения следующего элемента без передвижения курсора?`

В Java интерфейс Iterator не предоставляет метода для получения следующего элемента без передвижения курсора. Это сделано намеренно, чтобы гарантировать, что каждый элемент коллекции обрабатывается ровно один раз. Если бы был такой метод, он мог бы привести к непредсказуемости в обходе коллекции и возможным ошибкам. Вместо этого, для проверки следующего элемента используется метод hasNext(), а для получения следующего элемента используется next(), который одновременно передвигает курсор на следующий элемент в коллекции и возвращает его значение.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 817. `В чем разница между Iterator и ListIterator?`

Iterator и ListIterator являются интерфейсами в Java Collections Framework, которые обеспечивают способ перебора коллекции объектов. Однако ListIterator является подтипом Iterator и предоставляет дополнительные функции, которых нет у Iterator. 

Вот некоторые ключевые различия между Iterator и ListIterator:
+ Iterator можно использовать для обхода любой коллекции, тогда как ListIterator можно использовать только с реализациями List, такими как ArrayList, LinkedList и т. д. 
+ Iterator можно использовать для обхода элементов только в прямом направлении, а ListIterator может перемещать элементы как в прямом, так и в обратном направлении. 
+ ListIterator предоставляет дополнительные методы, такие как previous(), hasPrevious(), add(), set() и remove(), которых нет в Iterator.

Таким образом, если вам нужно пройти по списку как в прямом, так и в обратном направлении, или если вам нужно добавить, удалить или изменить элементы во время итерации по списку, вы должны использовать ListIterator. В противном случае используйте итератор.

Вот пример использования Iterator и ListIterator:
```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

public class IteratorExample {
   public static void main(String[] args) {
      List<String> names = new ArrayList<>();
      names.add("John");
      names.add("Mary");
      names.add("Bob");
      names.add("Sarah");

      // Example of using an Iterator
      Iterator<String> iterator = names.iterator();
      while (iterator.hasNext()) {
          System.out.println(iterator.next());
      }

      // Example of using a ListIterator
      ListIterator<String> listIterator = names.listIterator(names.size());
      while (listIterator.hasPrevious()) {
          System.out.println(listIterator.previous());
      }
   }
}
```
В этом примере мы сначала создаем список имен, а затем используем итератор для обхода элементов в списке в прямом направлении. Затем мы используем ListIterator для обхода элементов списка в обратном направлении.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 818. `Какие есть способы перебора всех элементов List?`

В Java есть несколько способов перебора всех элементов списка (List):

+ `Цикл for`:
```java
List<String> list = Arrays.asList("one", "two", "three");
for(int i = 0; i < list.size(); i++) {
    System.out.println(list.get(i));
}
```
+ `Цикл for each`:
```java
List<String> list = Arrays.asList("one", "two", "three");
for(String str : list) {
    System.out.println(str);
}
```
+ `Итератор`:
```java
List<String> list = Arrays.asList("one", "two", "three");
Iterator<String> iterator = list.iterator();
while(iterator.hasNext()) {
    System.out.println(iterator.next());
}
```

 
+ `Использование метода forEach()`:
```java 
List<String> list = new ArrayList<>();
list.add("один");
list.add("два");
list.add("три");

list.forEach((element) -> {
    System.out.println(element);
});

```
Каждый из этих способов имеет свои преимущества и недостатки, в зависимости от ситуации. Например, цикл for обычно быстрее работает, чем итератор, но итератор можно использовать для удаления элементов списка во время итерации. выбор способа перебора зависит от конкретной задачи.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 819. `В чем разница между fail-safe и fail-fast свойствами?`

В Java fail-fast и fail-safe свойства относятся к итераторам коллекций.

Fail-fast свойство позволяет выявить ошибки в многопоточных приложениях, где несколько потоков могут изменять одну и ту же коллекцию одновременно. При возникновении такой ситуации итератор бросает исключение ConcurrentModificationException. Fail-fast итераторы работают быстрее, тем самым уменьшая затраты на синхронизацию.

Fail-safe свойство заключается в том, что итератор создает копию коллекции и работает с ней. Таким образом, он гарантирует, что возвращаемые им элементы верны на момент создания итератора. Это свойство не бросает исключений при изменении коллекции другим потоком, так как она остается в неизменном состоянии. Однако это может привести к неактуальным данным, если коллекция продолжает изменяться в других потоках.

В общем случае, fail-fast итераторы предпочтительнее, так как они позволяют выявлять ошибки в работе с коллекциями раньше. Однако, если ваша программа не требует таких проверок или работает с потоками без изменения коллекции, fail-safe итератор может быть более подходящим выбором.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 820. `Что делать, чтобы не возникло исключение ConcurrentModificationException?`

Чтобы избежать исключения ConcurrentModificationException в Java, необходимо использовать правильный подход при итерировании коллекций. Исключение возникает, когда коллекция изменяется во время итерации. Для этого есть несколько вариантов решения:

+ Использовать итератор вместо цикла for-each. Итератор позволяет удалять элементы коллекции без возникновения исключения:
```java
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String item = iterator.next();
    if (item.equals("somevalue")) {
        iterator.remove();
   }
}
```
+ Использовать копию коллекции для итерации, если изменения необходимы только в оригинальной коллекции:
```java
List<String> copyList = new ArrayList<>(originalList);
for (String item : copyList) {
    if (item.equals("somevalue")) {
        originalList.remove(item);
    }
}
```
+ Использовать конкурентные коллекции, такие как ConcurrentLinkedQueue или ConcurrentHashMap, которые позволяют изменять коллекцию без блокировки ее состояния:
```java
ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();
queue.add("value1");
queue.add("value2");
for (String item : queue) {
    if (item.equals("value1")) {
        queue.remove(item);
    }
}
```
Кроме того, можно синхронизировать доступ к коллекции, чтобы избежать ее изменения во время итерации. Но этот способ может привести к проблемам с производительностью, поэтому лучше использовать решения, представленные выше.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 821. `Что такое стек и очередь, расскажите в чем их отличия?`
Стек и очередь - это два базовых структурных элемента данных в программировании, которые являются взаимопротивоположными. Они имеют разные свойства и применяются в разных ситуациях.
Основная разница между стеком и очередью заключается в порядке, в котором элементы добавляются и извлекаются.

Стек - это коллекция элементов данных, которые сохраняются в порядке "последний вошел - первый вышел" (LIFO). Это означает, что последний элемент, добавленный в стек, будет первым, который будет удален из стека. Операции, доступные для стека, обычно ограничены добавлением нового элемента и удалением наиболее недавно добавленного элемента. Стек широко используется для решения задачи обхода деревьев, генерации парсеров, решения задач в обработке синтаксических конструкций.

Очередь - это коллекция элементов данных, которые сохраняются в соответствии с принципом "первый вошел, первый вышел" (FIFO). Это означает, что первый элемент, добавленный в очередь, будет первым, который будет удален из очереди. Операции, доступные для очереди, обычно ограничены добавлением новых элементов и удалением элементов из начала очереди. Очередь используется в различных задачах, включая управление процессами в операционных системах и реализацию алгоритмов BFS (обход в ширину) в Графах.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 822. `В чем разница между интерфейсами Comparable и Comparator?`

В Java интерфейсы Comparable и Comparator позволяют определить порядок сортировки объектов. Однако, эти интерфейсы используются в разных ситуациях и имеют разные подходы.

Comparable - интерфейс, который реализуется классом, который нужно сравнивать. Этот интерфейс имеет один метод compareTo(), который принимает другой объект того же типа и возвращает целое число. Это число указывает, нужно ли считать текущий объект больше, меньше или равным переданному объекту. Пример: если нужно отсортировать массив строк в алфавитном порядке, то можно реализовать Comparable в классе String, так что строки будут сравниваться по значению символов.

Comparator - интерфейс, который реализуется для сравнения двух объектов другого класса. Этот интерфейс имеет один метод compare(), который принимает два объекта и возвращает целое число. Это число указывает, нужно ли считать первый объект больше, меньше или равным второму объекту. Пример: если нужно отсортировать список пользователей по возрасту, можно реализовать Comparator в классе User, чтобы объекты сравнивались по возрастному значению.



В целом, интерфейс Comparable используется для определения естественного порядка элементов класса (например, числа можно сравнить по значению), а интерфейс Comparator используется для сравнения элементов разных классов или для определения альтернативного способа сравнения внутри класса (например, строки можно сравнить по длине).



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 823. `Почему коллекции не наследуют интерфейсы Cloneable и Serializable?`

В Java коллекции не наследуют интерфейсы Cloneable и Serializable, потому что это может привести к проблемам с безопасностью и управлением памятью. Эти интерфейсы используются для создания копий объектов и сериализации их в байтовый поток соответственно. Когда коллекция реализует эти интерфейсы, она становится уязвимой к непреднамеренным копированиям и сериализации, что может привести к ошибкам и неожиданным поведениям в программе. Это может быть особенно проблематично при работе с распределенными системами и сериализации данных. Вместо этого коллекции в Java предпочитают создавать свои собственные методы копирования и сериализации, ориентированные на конкретные нужды этих коллекций.

Cloneable - это маркерный интерфейс, который используется для указания того, что объект может быть клонирован. Если вы хотите клонировать объект коллекции в Java, вы должны вызвать метод clone(), который определен в классе Object. Метод этот имеет защищенный доступ, и может быть переопределен только в классе, который поддерживает клонирование.

Что касается интерфейса Serializable, то он используется для маркировки классов, которые могут быть сохранены в потоке данных. Классы, реализующие этот интерфейс, могут быть сериализованы, т.е. преобразованы в поток байтов, которые могут быть сохранены на диске или переданы по сети.

Таким образом, хотя Java-коллекции не наследуют явно интерфейсы Cloneable и Serializable, они все же могут быть клонированы и сериализованы благодаря тому, что предоставляют соответствующие методы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 824. `Что такое «коллекция»?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 825. `Назовите основные интерфейсы JCF и их реализации.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 826. `Расположите в виде иерархии следующие интерфейсы: List, Set, Map, SortedSet, SortedMap, Collection, Iterable, Iterator, NavigableSet, NavigableMap.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 827. `Почему Map — это не Collection, в то время как List и Set являются Collection?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 828. `В чем разница между классами java.util.Collection и java.util.Collections?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 829. `Что такое «fail-fast поведение»?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 830. `Какая разница между fail-fast и fail-safe?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 831. `Приведите примеры итераторов реализующих поведение fail-safe`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 832. `Чем различаются Enumeration и Iterator.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 833. `Как между собой связаны Iterable и Iterator?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 834. `Как между собой связаны Iterable, Iterator и «for-each»?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 835. `Сравните Iterator и ListIterator.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 836. `Что произойдет при вызове Iterator.next() без предварительного вызова Iterator.hasNext()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 837. `Сколько элементов будет пропущено, если Iterator.next() будет вызван после 10-ти вызовов Iterator.hasNext()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 838. `Как поведёт себя коллекция, если вызвать iterator.remove()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 839. `Как поведёт себя уже инстанциированный итератор для collection, если вызвать collection.remove()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 840. `Как избежать ConcurrentModificationException во время перебора коллекции?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 841. `Какая коллекция реализует дисциплину обслуживания FIFO?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 842. `Какая коллекция реализует дисциплину обслуживания FILO?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 843. `Чем отличается ArrayList от Vector?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 844. `Зачем добавили ArrayList, если уже был Vector?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 845. `Чем отличается ArrayList от LinkedList? В каких случаях лучше использовать первый, а в каких второй?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 846. `Что работает быстрее ArrayList или LinkedList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 847. `Какое худшее время работы метода contains() для элемента, который есть в LinkedList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 848. `Какое худшее время работы метода contains() для элемента, который есть в ArrayList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 849. `Какое худшее время работы метода add() для LinkedList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 850. `Какое худшее время работы метода add() для ArrayList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 851. `Необходимо добавить 1 млн. элементов, какую структуру вы используете?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 852. `Как происходит удаление элементов из ArrayList? Как меняется в этом случае размер ArrayList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 853. `Предложите эффективный алгоритм удаления нескольких рядом стоящих элементов из середины списка, реализуемого ArrayList.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 854. `Сколько необходимо дополнительной памяти при вызове ArrayList.add()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 855. `Сколько выделяется дополнительно памяти при вызове LinkedList.add()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 856. `Оцените количество памяти на хранение одного примитива типа byte в LinkedList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 857. `Оцените количество памяти на хранение одного примитива типа byte в ArrayList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 858. `Для ArrayList или для LinkedList операция добавления элемента в середину (list.add(list.size()/2, newElement)) медленнее?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 859. `В реализации класса ArrayList есть следующие поля: Object[] elementData, int size. Объясните, зачем хранить отдельно size, если всегда можно взять elementData.length?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 860. `Сравните интерфейсы Queue и Deque.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 861. `Кто кого расширяет: Queue расширяет Deque, или Deque расширяет Queue?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 862. `Почему LinkedList реализует и List, и Deque?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 863. `LinkedList — это односвязный, двусвязный или четырехсвязный список?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 864. `Как перебрать элементы LinkedList в обратном порядке, не используя медленный get(index)?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 865. `Что позволяет сделать PriorityQueue?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 866. `Stack считается «устаревшим». Чем его рекомендуют заменять? Почему?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 867. `Зачем нужен HashMap, если есть Hashtable?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 868. `В чем разница между HashMap и IdentityHashMap? Для чего нужна IdentityHashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 869. `В чем разница между HashMap и WeakHashMap? Для чего используется WeakHashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 870. `В WeakHashMap используются WeakReferences. А почему бы не создать SoftHashMap на SoftReferences?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 871. `В WeakHashMap используются WeakReferences. А почему бы не создать PhantomHashMap на PhantomReferences?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 872. `LinkedHashMap - что в нем от LinkedList, а что от HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 873. `В чем проявляется «сортированность» SortedMap, кроме того, что toString() выводит все элементы по порядку?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 874. `Как устроен HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 875. `Согласно Кнуту и Кормену существует две основных реализации хэш-таблицы: на основе открытой адресации и на основе метода цепочек. Как реализована HashMap? Почему, по вашему мнению, была выбрана именно эта реализация? В чем плюсы и минусы каждого подхода?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 876. `Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 877. `Какое начальное количество корзин в HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 878. `Какова оценка временной сложности операций над элементами из HashMap? Гарантирует ли HashMap указанную сложность выборки элемента?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 879. `Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 880. `В каком случае может быть потерян элемент в HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 881. `Почему нельзя использовать byte[] в качестве ключа в HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 882. `Какова роль equals() и hashCode() в HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 883. `Каково максимальное число значений hashCode()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 884. `Какое худшее время работы метода get(key) для ключа, которого нет в HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 885. `Какое худшее время работы метода get(key) для ключа, который есть в HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 886. `Сколько переходов происходит в момент вызова HashMap.get(key) по ключу, который есть в таблице?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 887. `Сколько создается новых объектов, когда вы добавляете новый элемент в HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 888. `Как и когда происходит увеличение количества корзин в HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 889. `Объясните смысл параметров в конструкторе HashMap(int initialCapacity, float loadFactor).`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 890. `Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 891. `Как перебрать все ключи Map?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 892. `Как перебрать все значения Map?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 893. `Как перебрать все пары «ключ-значение» в Map?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 894. `В чем отличия TreeSet и HashSet?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 895. `Что будет, если добавлять элементы в TreeSet по возрастанию?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 896. `Чем LinkedHashSet отличается от HashSet?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 897. `Для Enum есть специальный класс java.util.EnumSet. Зачем? Чем авторов не устраивал HashSet или TreeSet?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 898. `Какие существуют способы перебирать элементы списка?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 899. `Каким образом можно получить синхронизированные объекты стандартных коллекций?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 900. `Как получить коллекцию только для чтения?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 901. `Напишите однопоточную программу, которая заставляет коллекцию выбросить ConcurrentModificationException.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 902. `Приведите пример, когда какая-либо коллекция выбрасывает UnsupportedOperationException.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 903. `Реализуйте симметрическую разность двух коллекций используя методы Collection (addAll(...), removeAll(...), retainAll(...)).`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 904. `Как, используя LinkedHashMap, сделать кэш c «invalidation policy»?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 905. `Как одной строчкой скопировать элементы любой collection в массив?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 906. `Как одним вызовом из List получить List со всеми элементами, кроме первых и последних 3-х?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 907. `Как одной строчкой преобразовать HashSet в ArrayList?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 908. `Как одной строчкой преобразовать ArrayList в HashSet?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 909. `Сделайте HashSet из ключей HashMap.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 910. `Сделайте HashMap из HashSet<Map.Entry<K, V>>.`


к оглавлению


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 5. Строки (перейти в раздел)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 911. `Какие “строковые” классы вы знаете?`
На Java есть несколько классов, связанных со строками:

+ `String`, который является неизменяемым объектом для хранения строки.

+ `StringBuilder`, который является изменяемым объектом для построения строки.

+ `StringBuffer`, который также является изменяемым объектом для хранения и модификации строки, но является потокобезопасным и может использоваться в многопоточных приложениях.

+ `CharSequence`, который является интерфейсом для работы с последовательностями символов, включая строки.

Эти классы могут использоваться для различных задач, связанных со строками в Java.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 912. `Какие основные свойства “строковых” классов (их особенности)?`
Основные свойства "строковых" классов в Java (String, StringBuffer, StringBuilder):

+ `Неизменяемость`: Объекты класса String не могут быть изменены после создания. Каждый метод, который изменяет строку, фактически создает новый объект, а не изменяет существующий. В StringBuffer и StringBuilder объекты могут быть изменены после создания, и новые объекты не создаются при использовании различных методов.

+ `Потокобезопасность`: StringBuffer является потокобезопасным классом, позволяющим многопоточные операции над строками. StringBuilder не является потокобезопасным классом, но имеет более высокую производительность.

+ `Производительность`: StringBuffer и StringBuilder быстрее, чем String, при частых операциях конкатенации или изменении строк.

+ `Буферизация`: StringBuffer и StringBuilder создаются с начальной емкостью буфера, чтобы предотвратить излишние выделения памяти при изменении или добавлении символов в строку.

+ `Операции со строками`: В классах StringBuffer и StringBuilder есть множество методов для работы со строками, такие как вставка, удаление, замена, конкатенация, обращение символов и т.д.

+ `Методы сравнения`: Объекты класса String имеют множество методов сравнения строк, например, методы equals() и compareTo(). Методы сравнения не поддерживаются в StringBuffer и StringBuilder, так как они не предназначены для выполнения операций сравнения, а в первую очередь для работы со строками.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 913. `Можно ли наследовать строковый тип, почему?`
Да, в Java класс String может быть унаследован. Однако, класс String объявлен как final, поэтому он не может быть унаследован другими классами. Это означает, что нельзя создать подкласс от String и переопределить его методы, такие как equals() или toString().

Наследование заключается в том, чтобы создать новый класс, который расширяет или наследует функциональность уже существующего класса. Это позволяет создавать иерархию классов, где подклассы наследуют свойства и методы из класса-родителя.

В случае с классом String, можно использовать его в дочерних классах как обычную строку, но нельзя изменять его поведение.

Например,
```java
public class MyString extends String {
    // Код
}
```
будет вызывать ошибку компиляции, поскольку String объявлен как final.

Также можно создать новый класс и использовать объекты String в нем как обычный объект.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 914. `Дайте определение понятию конкатенация строк.`
Конкатенация строк - это операция объединения двух или более строк в одну строку. В Java для конкатенации строк можно использовать оператор +. Например:
```java
String str1 = "Hello";
String str2 = "World";
String result = str1 + " " + str2;
System.out.println(result); // output: "Hello World"
```
В данном примере мы объединяем значения переменных str1 и str2, а также вставляем между ними пробел. Результат конкатенации сохраняем в переменной result.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 915. `Как преобразовать строку в число?`
Чтобы преобразовать строку в число в Java, вы можете использовать методы синтаксического анализа классов-оболочек для соответствующего числового типа. Вот некоторые примеры: 

+ Чтобы преобразовать строку в целое число:
```java
String str = "123";
int num = Integer.parseInt(str);

```
+ Чтобы преобразовать строку в double:
```java
String str = "3.14";
double num = Double.parseDouble(str);

```
+ Чтобы преобразовать строку в long:
```java
String str = "9876543210";
long num = Long.parseLong(str);
```
Обратите внимание, что эти функции вызывают исключение NumberFormatException, если входная строка не является допустимым представлением числа. Кроме того, вы можете использовать метод valueOf классов-оболочек для преобразования строки в число:
```java
String str = "456";
Integer num = Integer.valueOf(str);

```

Это возвращает объект Integer, а не примитивный int. Кроме того, метод valueOf может обрабатывать ввод null, а методы синтаксического анализа — нет.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 916. `Как сравнить значение двух строк?`
Вы можете сравнить значения двух строк в Java, используя метод equals() или compareTo(). Метод equals() сравнивает значения двух объектов типа String на идентичность, тогда как метод compareTo() сравнивает значения двух объектов типа String лексикографически.

Вот примеры использования обоих методов:
```java
String str1 = "hello";
String str2 = "world";
String str3 = "hello";

// использование метода equals()
if(str1.equals(str3)){
  System.out.println("str1 и str3 равны");
} else {
  System.out.println("str1 и str3 не равны");
}

// использование метода compareTo()
if(str1.compareTo(str2) < 0){
  System.out.println("str1 меньше, чем str2");
} else if(str1.compareTo(str2) > 0){
  System.out.println("str1 больше, чем str2");
} else {
  System.out.println("str1 и str2 равны");
}
```
В этом примере str1 и str3 равны, потому что они содержат одинаковые значения. Второй блок if-else сравнивает str1 и str2 лексикографически и выдаст сообщение, что str1 меньше, чем str2.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 917. `Как перевернуть строку?`

Для переворачивания строки на Java есть несколько способов:

+ `Использование StringBuilder/StringBuffer`
```java
String originalString = "Hello World!";
StringBuilder stringBuilder = new StringBuilder(originalString);
String reversedString = stringBuilder.reverse().toString();
System.out.println(reversedString);
```
+ `Рекурсивная функция`
```java
public static String reverseStringWithRecursion(String str) {
    if (str.length() <= 1) {
        return str;
    }
    return reverseStringWithRecursion(str.substring(1)) + str.charAt(0);
}
String originalString = "Hello World!";
String reversedString = reverseStringWithRecursion(originalString);
System.out.println(reversedString);
```
+ `Использование метода reverse() класса StringTokenizer`
```java
String originalString = "Hello World!";
StringTokenizer tokenizer = new StringTokenizer(originalString, " ");
String reversedString = "";
while (tokenizer.hasMoreTokens()) {
    StringBuilder stringBuilder = new StringBuilder(tokenizer.nextToken());
    reversedString += stringBuilder.reverse().toString() + " ";
}
System.out.println(reversedString.trim());
```

+ `Использовать цикл for или while`, чтобы перебирать символы строки в обратном порядке и добавлять их в новую строку. Пример:
```java
String originalString = "Привет, мир!";
String reversedString = "";
for (int i = originalString.length() - 1; i >= 0; i--) {
    reversedString += originalString.charAt(i);
}
System.out.println(reversedString);
```
Это также выведет !рим ,тевирП на консоль. Однако, использование классов StringBuilder или StringBuffer более эффективно, когда вы работаете с большими строками или выполняете многократные операции реверсирования строки.

Это лишь несколько примеров того, как можно перевернуть строку на Java. Важно выбрать самый оптимальный способ в зависимости от конкретной задачи.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 918. `Как работает сравнение двух строк?`
В Java есть два способа сравнения строк:

+ `Оператор ==` сравнивает ссылки объектов, а не значения. Таким образом, оператор == возвращает true только если обе переменные ссылаться на один и тот же объект.

+ `Метод equals()` сравнивает значения объектов, а не ссылки. Метод equals() сравнивает символьную последовательность, содержащуюся в двух строках, игнорируя регистр.

Пример использования операторов сравнения и метода equals() в Java:
```java
String str1 = "Hello";
String str2 = "Hello";
String str3 = new String("Hello");

// использование оператора сравнения
System.out.println(str1 == str2); // true
System.out.println(str1 == str3); // false

// использование метода equals()
System.out.println(str1.equals(str2)); // true
System.out.println(str1.equals(str3)); // true
```
+ `статический метод compare()` класса String, который используется для лексикографического сравнения двух строк. Этот метод возвращает значение 0, если строки равны; значение меньше нуля, если первая строка меньше второй, и значение больше нуля, если первая строка больше второй.

Пример:
```java
String str1 = "apple";
String str2 = "orange";
int result = str1.compareTo(str2);

if (result < 0) {
    System.out.println("str1 меньше, чем str2");
} else if (result > 0) {
    System.out.println("str1 больше, чем str2");
} else {
    System.out.println("str1 и str2 равны");
}
```
Этот пример выведет на экран "str1 меньше, чем str2", потому что строки сравниваются лексикографически и "apple" идет перед "orange" в алфавитном порядке.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 919. `Как обрезать пробелы в конце строки?`
Для удаления пробелов в конце строки в Java можно использовать `метод trim()`. Он удаляет все начальные и конечные пробелы строки.

Пример использования:
```java
String str = "  example string    ";
String trimmed = str.trim(); // "example string"
```
Метод trim() возвращает новую строку без пробелов в начале и в конце. Оригинальная строка остается неизменной.

Также можно использовать `метод replaceAll()` с регулярным выражением, чтобы удалить все символы пробела в конце строки:
```java
String str = "  example string    ";
String trimmed = str.replaceAll("\\s+$", ""); // "example string"
```
В этом примере регулярное выражение \\s+$ соответствует любым символам пробела, которые находятся в конце строки.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 920. `Как заменить символ в строке?`

Чтобы заменить символ в строке в Java, вы можете использовать метод replace(). Вот пример фрагмента кода, который заменяет все вхождения символа «a» на «b» в заданной строке:

```java 
String str = "example string";
String newStr = str.replace('a', 'b');
System.out.println(newStr);

```
Это выведет «строку exbmple», которая является исходной строкой со всеми экземплярами «a», замененными на «b». Обратите внимание, что метод replace() возвращает новую строку, поэтому важно сохранить результат в новой переменной (в данном примере, newStr), если вы хотите сохранить измененную строку. 

Если вы хотите заменить подстроку другой подстрокой, вы можете использовать метод replace() со строковыми аргументами вместо символьных аргументов. Вот пример, который заменяет все вхождения подстроки «привет» на «до свидания» в заданной строке:

```java 
String str = "hello world, hello everyone";
String newStr = str.replace("hello", "goodbye");
System.out.println(newStr);

```
Это выведет "goodbye world, goodbye everyone".



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 921. `Как получить часть строки?`

Для получения части строки в Java вы можете использовать метод substring(startIndex, endIndex) класса String. Метод извлекает из строки подстроку, начиная с индекса startIndex и заканчивая endIndex - 1. Если endIndex не указан, то возвращается подстрока, начиная с startIndex и до конца строки.

Вот пример использования метода substring():
```java 
String str = "Hello World!";
String substr1 = str.substring(0, 5); // извлекаем "Hello"
String substr2 = str.substring(6); // извлекаем "World!"
```
В этом примере, мы создали новую строку str, а затем использовали метод substring() для извлечения двух подстрок: с 0-го по 4-й символ и с 6-го символа до конца строки.

Обратите внимание, что строки в Java неизменяемы, поэтому метод substring() не изменяет исходную строку, а возвращает новую строку - подстроку исходной.

Также в Java есть еще методы извлечения части строки, такие как subSequence() и charAt().

+ Если нужно получить один символ строки по его индексу, можно воспользоваться методом charAt():
```java
char ch = str.charAt(0); // Получаем первый символ строки
```

+ Вот пример использования метода subSequence() для извлечения части строки:
```java 
String str = "Hello World";
CharSequence sub = str.subSequence(0, 5); // извлечь первые 5 символов
System.out.println(sub); // печатает "Hello"

```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 922. `Дайте определение понятию “пул строк”.`
В Java "пул строк" (string pool) - это механизм оптимизации памяти, при котором каждая уникальная строка, созданная в программе, сохраняется в пуле строк. Если другая строка с тем же значением создается позже, то она не создается, а ссылается на уже существующую строку в пуле. Таким образом, память оптимизируется и избегается создание большого количества одинаковых строк.

Например, вот как создается строка "hello":
```java
String s = "hello";
```
Эта строка помещается в пул строк. При создании другой строки с тем же значением: 
```java
String t = "hello";
```
возвращается ссылка на уже созданный объект, поэтому t ссылается на тот же объект в пуле строк, что и s.

Когда строки создаются через литералы (например, "hello"), они автоматически помещаются в пул строк. Также можно явно поместить строку в пул с помощью метода intern(). Например:
```java
String str1 = "hello"; // создание строки через литерал
String str2 = new String("hello"); // создание строки через объект
boolean isSameObject = str1 == str2; // false, так как два разных объекта
boolean isSameValue = str1.equals(str2); // true, так как содержимое строк одинаковое
String str3 = str2.intern(); // явное помещение в пул строк
boolean isSameObject2 = str1 == str3; // true, так как оба объекта ссылается на одну строку в пуле
```
Использование пула строк может существенно улучшить производительность программы и сократить потребление памяти при работе с большим количеством одинаковых строк. Однако, если необходимо работать со строками с большим объемом данных, следует быть осторожным с использованием пула строк, так как это может привести к утечке памяти.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 923. `Какой метод позволяет выделить подстроку в строке?`
В Java для выделения подстроки в строке можно использовать метод substring() класса String. Этот метод принимает два аргумента - начальный и конечный индексы подстроки (включительно) и возвращает новую строку, содержащую только указанную подстроку. Например:
```java
String str = "Hello, World!";
String substr = str.substring(7, 12);
System.out.println(substr); // выводит "World"
```
Если второй аргумент метода substring() не указан, то он будет вырезать все символы от указанного индекса до конца строки. Или, если второй аргумент превышает длину строки, то он будет вырезать все символы от указанного индекса до конца строки. Например:
```java
String str = "Hello, World!";
String substr1 = str.substring(7); // вырежет "World!"
String substr2 = str.substring(7, 20); // вырежет "World!"
```
substr1 будет равен "World!", а substr2 будет равен "World".



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 924. `Как разбить строку на подстроки по заданному разделителю?`

В Java можно использовать метод split(), который разделяет строку на подстроки по определенному разделителю. Вот пример использования:
```java 
String str = "разделенные|строки|по|вертикальной черте";
String[] substrings = str.split("\\|");
```
В данном примере строка str разделяется на массив подстрок substrings с помощью разделителя "|". Обратите внимание на то, что строка разделителя нуждается в экранировании, поэтому используется двойной слэш \.

Вы также можете использовать регулярные выражения вместо обычной строки в split() для более продвинутой обработки текста.

Например, представим, что у нас есть строка "раз,два,три" и мы хотим получить массив строк ["раз", "два", "три"]. Мы можем использовать следующий код:
```java
String str = "раз,два,три";
String[] arr = str.split(",");
```
В этом примере мы передаем разделитель (",") в качестве аргумента метода 
split(). Метод разбивает исходную строку на элементы массива, используя разделитель, и возвращает полученный массив строк.

Если требуется использовать разделитель, который является регулярным выражением (например, точка или знак вопроса), то перед разделителем следует добавлять слеш (/). Например:
```java
String str = "раз.два.три";
String[] arr = str.split("\\.");
```

Вот пример использования метода split() для разбивки строки на подстроки по новой строке:
```java
String str = "Привет\nмир\nJava";
String[] substrings = str.split("\n");
for (String substring : substrings) {
    System.out.println(substring);
}
```
Этот код выведет:
```
Привет
мир
Java
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 925. `Какой метод вызывается для преобразования переменной в строку?`

В Java метод toString() вызывается для преобразования объекта в строку. Если вы вызываете toString() на объекте, который не является строкой, то возвращаемое значение будет строковое представление объекта. Например:
```java
Integer myInt = 42;
String str = myInt.toString();
```
В этом примере, toString() вызывается на объекте myInt, который является типом Integer. Эта операция возвращает строковое представление myInt, которое затем присваивается переменной str.

Также, для преобразования примитивного типа в строку вы можете использовать метод String.valueOf(). Например:
```java
int myInt = 42;
String str = String.valueOf(myInt);
```
В этом примере, примитивное число myInt преобразуется в строку, используя метод String.valueOf().



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 926. `Как узнать значение конкретного символа строки, зная его порядковый номер в строке?`

Для того чтобы получить значение конкретного символа строки в Java, зная его порядковый номер, можно использовать метод charAt(). Нумерация символов начинается с нуля. Например, чтобы получить символ строки по ее индексу, можно сделать следующее:
```java
String str = "Hello, world!";
char ch = str.charAt(7); // получаем символ с индексом 7 (букву "w")
System.out.println(ch); // выводим символ в консоль
```
В данном примере мы получаем символ строки, находящийся под индексом 7, и выводим его значение в консоль.

Также можно использовать оператор квадратных скобок [], чтобы получить символ строки по индексу. Например:
```java 
String str = "Hello, world!";
char ch = str[7]; // получаем символ строки с индексом 7 (букву "w")
System.out.println(ch); // выводим символ в консоль
```
Оба варианта эквивалентны и выполняют одну и ту же задачу.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 927. `Как найти необходимый символ в строке?`
Чтобы найти определенный символ в строке в Java, вы можете использовать метод indexOf() класса String. Например:
```java
String str = "Hello, world!";
char ch = 'o';
int index = str.indexOf(ch);
System.out.println(index);

```

Это вернет индекс первого появления символа «o» в строке. Если символ не найден, метод indexOf() возвращает -1.

Вы также можете использовать метод charAt() для получения символа по определенному индексу в строке. Например:
```java
char myChar = str.charAt(index);
System.out.println(myChar);
```




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 928. `Можно ли синхронизировать доступ к строке?`

Да, в Java можно синхронизировать доступ к строке, используя ключевое слово synchronized. Если два или более потока пытаются изменить строку одновременно в разных частях кода, может произойти гонка данных (race condition), что приведет к непредсказуемому результату. Для избежания этой ситуации можно объявить метод, который изменяет строку, как synchronized. Например:
```java
public class Example {
    private String synchronizedString = "Hello, world!";

    public synchronized void appendToString(String str) {
        synchronizedString += str;
    }
}
```
В этом примере метод appendToString был объявлен как synchronized, что обеспечивает синхронизированный доступ к строке synchronizedString.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 929. `Что делает метод intern()?`

Метод intern() в Java используется для уменьшения использования памяти при работе со строками. Он возвращает ссылку на объект строки из пула, если такой объект уже существует в пуле, иначе добавляет его в пул и возвращает ссылку на него. Если вы работаете со строками, которые могут иметь одинаковые значения, вызов метода intern() для каждой из них может помочь уменьшить нагрузку на память и ускорить выполнение кода, т.к. меньше объектов будет создано и собрано сборщиком мусора.

Вот пример использования метода intern():
```java
String str1 = "hello";
String str2 = new String("hello");
String str3 = str2.intern();

System.out.println(str1 == str2); // false
System.out.println(str1 == str3); // true
```
Здесь мы создаем 3 строки: первая создается с помощью литерала, вторая создается с явным вызовом конструктора, а третья получается путем вызова intern() на второй строке. Т.к. первая и третья строки имеют одинаковые значения, они ссылаются на один и тот же объект в пуле строк, в то время как вторая строка создает свой собственный объект.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 930. `Чем отличаются и что общего у классов String, StringBuffer и StringBuilder?`

Классы String, StringBuffer и StringBuilder имеют следующие сходства и различия:

`Сходства`:

+ + Все три класса позволяют работать с символьными строками в Java.

+ + Все они могут хранить и изменять содержимое строк.

+ + Все три класса находятся в пакете java.lang, что означает, что вы можете использовать их без необходимости импорта.
  
+ + Все три класса представляют строку в Java, но имеют различное поведение и способы работы со строками.

+ + Все три класса являются неизменяемыми типами данных - это означает, что если вы создали объект String, то вы не можете изменить его содержимое. Например:
```java
String s = "Hello";
s = s + " World"; // создается новый объект String, в переменной s остается ссылка на старый объект
```
+ + Все три класса могут использоваться для создания и изменения строк.

`Различия`:

+ + Объекты String являются неизменяемыми, что означает, что содержимое строки нельзя изменить после создания экземпляра. Вместо этого методы класса возвращают новые строковые объекты при изменении содержимого. Это может приводить к большому количеству ненужных объектов в памяти при частых изменениях содержимого.

+ + Объекты StringBuffer и StringBuilder позволяют изменять содержимое строки напрямую, т.е. объект в памяти изменяется непосредственно без создания нового объекта. Разница между ними заключается в том, что StringBuffer является потокобезопасным (thread-safe), т.е. может быть использован в многопоточных приложениях без необходимости использования дополнительных средств синхронизации, в то время как StringBuilder не является потокобезопасным.

+ + В общем случае, если вам требуется часто изменять содержимое строки и не работать в многопоточной среде, лучше использовать StringBuilder, а в случае многопоточности - StringBuffer. Если же содержимое строки не изменяется, используйте String.


+ + String - неизменяемый тип данных, а StringBuffer и StringBuilder - изменяемые. Это означает, что вы можете изменять содержимое объектов StringBuffer и StringBuilder, но не можете изменять объект String.

+ + StringBuffer и StringBuilder могут изменять строки без создания новых объектов, в отличие от String. Это более эффективно, когда вам нужно многократно изменять строку в цикле или при выполнении множественных операций со строками.

+ + StringBuilder быстрее, чем StringBuffer, но не является потокобезопасным.

Как правило, если вы работаете со строками, которые не изменяются, то используйте String. Если вам нужно многократно изменять строку в цикле или при выполнении множественных операций со строками, используйте StringBuffer или StringBuilder. Если вам не нужны функции многопоточности, лучше использовать StringBuilder, так как он быстрее, чем StringBuffer.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 931. `Как правильно сравнить значения строк двух различных объектов типа String и StringBuffer?`

Для того, чтобы сравнить значения строк двух разных объектов типа String и StringBuffer, сначала необходимо привести тип StringBuffer к String. Это можно сделать с помощью метода toString(). Затем можно использовать метод equals() для сравнения значений строк. Например:
```java
String str = "hello";
StringBuffer stringBuffer = new StringBuffer("hello");
if (str.equals(stringBuffer.toString())) {
  System.out.println("Строки совпадают");
} else {
  System.out.println("Строки не совпадают");
}
```
Этот код приведет к выводу "Строки совпадают", так как значения строк "hello" и "hello" равны. Обратите внимание, что использование оператора == для сравнения строк может привести к непредсказуемым результатам, так как это сравнивает ссылки на объекты, а не их значения.

173. Почему строка неизменная и финализированная в Java?
Строки в Java неизменяемы и финализированы (final) по своей природе, поэтому их содержимое не может быть изменено после создания объекта String. Это означает, что если вы попытаетесь изменить содержимое строки, например, путем изменения одного из ее символов, то будет создана новая строка с измененным содержимым, исходная строка останется неизменной.

Это сделано для обеспечения безопасности в многопоточных приложениях, поскольку изменяемые строки могут повредить данные других потоков.

Кроме того, финализация строк обеспечивает иммутабельность строк, то есть изменения строки создают новый объект, что имеет свойство безопасности в многопоточном окружении.

Но если вы все же планируете часто изменять строку в вашем приложении, то лучше использовать StringBuffer или StringBuilder, которые являются изменяемыми (mutable) и улучшают производительность по сравнению со строками, но они могут быть менее безопасными в многопоточных приложениях.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 932. `Почему массив символов предпочтительнее строки для хранения пароля?`

В Java массив символов (char[]) часто используется для хранения пароля вместо строк (String), потому что массивы символов изменяемы и их значения можно перезаписать непосредственно в массиве, в то время как строки являются неизменяемыми (immutable), и любые изменения строки приводят к созданию новой строки в памяти.

Когда пароль хранится в виде строки, он может остаться в памяти намного дольше, чем это необходимо. Это происходит из-за того, что строки не могут быть удалены до тех пор, пока они не удалятся сборщиком мусора (garbage collector). Это делает строки уязвимыми для взлома пароля посредством перехвата содержимого памяти.

Еще один аспект безопасности, когда используют массивы символов, связан с тем, что их можно перезаписать случайным шумом в памяти после того, как они не нужны. Это делает сложнее для злоумышленников взламывать хранилища паролей, поскольку их истинные значения в памяти могут быть перезаписаны шумом.

Таким образом, использование массивов символов для хранения паролей является предпочтительным, потому что они изменяемы и их значения можно перезаписать непосредственно в памяти, а также их содержимое можно легко перезаписать случайным шумом в памяти.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 933. `Почему строка является популярным ключом в HashMap в Java?`

Строки (String) являются популярным типом ключей в HashMap в Java, потому что они имеют хорошо определенный метод хеширования и могут быть использованы для уникальной идентификации объектов. В Java класс String является неизменяемым (immutable), то есть после создания строки ее значение нельзя изменить. Это позволяет использовать строки в качестве ключей безопасности, что они будут изменены после того, как были добавлены в HashMap.

Каждый объект в Java имеет метод hashCode(), который возвращает целочисленное значение, используемое для идентификации объекта в HashMap. Для строк метод hashCode() возвращает уникальное значение на основе содержимого строки, что делает строки хорошими кандидатами для ключей в HashMap.

Кроме того, класс String в Java переопределяет методы equals() и hashCode(), чтобы они сравнивали строки по их содержимому, а не по ссылке на объект. Это позволяет использовать строки, созданные с использованием разных ссылок, но содержащие одинаковое значение, в качестве ключей в HashMap.

В итоге, использование строк в качестве ключей в HashMap облегчает уникальную идентификацию объектов и упрощает работу с ассоциативными массивами в Java.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 933. `Напишите метод удаления данного символа из строки.`

Для удаления заданного символа из строки в Java можно использовать метод replace() класса String. Например, если символ, который нужно удалить, - это буква 'a', то можно сделать следующим образом:
```java
String originalString = "Some string with letter 'a' in it.";
String modifiedString = originalString.replace("a", "");
```
В данном примере, заменяем все вхождения символа 'a' на пустую строку, что фактически удаляет этот символ из строки. Результат будет записан в переменную modifiedString.

Вот пример метода удаления заданного символа из строки на Java:
```java
public static String removeChar(String str, char ch) {
    StringBuilder sb = new StringBuilder();
    char[] charArray = str.toCharArray();
    for (char c : charArray) {
        if (c != ch) {
            sb.append(c);
        }
    }
    return sb.toString();
}
```
Этот метод принимает в качестве параметров строку и символ, который нужно удалить из строки. Метод создает StringBuilder и преобразует заданную строку в массив символов. Затем он проходит по каждому символу в массиве и добавляет его в StringBuilder, если он не равен символу, который нужно удалить. Наконец, метод возвращает измененную строку, вызывая метод toString() на StringBuilder.

Пример использования метода:
```java
String originalStr = "Hello World";
char ch = 'o';
String newStr = removeChar(originalStr, ch);
System.out.println(newStr); // "Hell Wrld"
```

к оглавлению


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 6. Потоки ввода/вывода (перейти в раздел)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 934. `В чём заключается разница между IO и NIO?`
В Java IO (input-output) операции чтения/записи происходят блокирующим образом. Это означает, что приложение будет заблокировано до тех пор, пока чтение/запись не завершатся. Это может привести к задержкам в выполнении приложения.

В Java NIO (new/non-blocking io) операции чтения/записи происходят неблокирующим образом . Это означает, что приложение не будет заблокировано во время чтения/записи. Вместо этого, приложение может продолжать работу в то время, пока чтение/запись не завершатся. Это может улучшить производительность приложения.

Кроме того, в Java NIO используются буферы для чтения/записи данных. Это может ускорить операции ввода-вывода, особенно при операциях с файлами.

В целом, Java NIO предоставляет более эффективное и мощное средство для управления операциями ввода-вывода в Java.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 935. `Какие особенности NIO вы знаете?`

Java NIO (новый ввод-вывод) — это набор API-интерфейсов Java для выполнения операций ввода-вывода с упором на неблокирующий ввод-вывод. Вот некоторые из его особенностей:

+ `Каналы и буферы`. NIO API предоставляет интерфейс канала, который является средой для выполнения операций ввода-вывода. 
+ `Буферы` хранят данные, которые передаются по каналу. Неблокирующий ввод/вывод – каналы в NIO могут работать в неблокирующем режиме. Это позволяет программе выполнять другие задачи во время передачи данных. 
+ `Селекторы` — объект Selector позволяет одному потоку отслеживать несколько каналов на предмет готовности к вводу. Это особенно полезно при управлении большим количеством подключений. 
+ `Порядок байтов`. В отличие от традиционного ввода-вывода, в котором используется сетевой порядок байтов (обратный порядок байтов), NIO позволяет программисту указать порядок байтов, который будет использоваться для передачи данных по сети. 
+ `Файловый ввод-вывод с отображением памяти` — NIO предоставляет способ отображения файла в память, позволяя программе выполнять операции ввода-вывода непосредственно на файл с отображением памяти. 

В целом, NIO обеспечивает более гибкий и масштабируемый способ выполнения операций ввода-вывода в Java, особенно для сетевых приложений.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 936. `Что такое «каналы»?`
В Java "каналы" (англ. channels) являются частью пакета java.nio, который предоставляет альтернативный набор классов для более эффективной работы с вводом-выводом (I/O) данных, чем стандартные библиотеки Java.

Классы каналов позволяют выполнять как синхронное, так и асинхронное чтение и запись данных внутри NIO фреймворка. В отличие от стандартных библиотек Java, NIO каналы работают напрямую с буферами данных, что позволяет избежать копирования или перемещения данных, уменьшая задержку и увеличивая производительность.

Некоторые из основных классов каналов в Java включают:

+ `FileChannel` - используется для чтения и записи данных в файлы.

+ `SocketChannel` - используется для чтения и записи данных через сетевые соединения TCP.

+ `DatagramChannel` - используется для чтения и записи данных через сетевые соединения UDP.

+ `ServerSocketChannel` - используется для создания серверов, которые слушают и принимают входящие соединения через сетевые соединения TCP.

Использование каналов в Java может быть сложным, но оно позволяет увеличить скорость ввода-вывода данных в приложении.

Для создания объекта канала в Java NIO, нужно использовать вызовы методов open() в соответствующем классе, например, FileChannel.open() для работы с файлами, DatagramChannel.open() для работы с объектами Datagram и т.д.

Пример создания канала для чтения данных из файла:
```java
Path path = Paths.get("file.txt");
FileChannel fileChannel = FileChannel.open(path);
ByteBuffer buffer = ByteBuffer.allocate(1024);
fileChannel.read(buffer);
```
Для записи данных в канал используется метод write() в соответствующем классе канала.

Пример записи данных в файловый канал:
```java
Path path = Paths.get("file.txt");
FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE);
ByteBuffer buffer = ByteBuffer.wrap("Hello, World!".getBytes());
fileChannel.write(buffer);
```
Также каналы могут использоваться для работы с сетевыми соединениями, например, через SocketChannel, ServerSocketChannel и DatagramChannel.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 937. `Назовите основные классы потоков ввода/вывода.`

Основные классы потоков ввода/вывода в Java это `InputStream, OutputStream, Reader и Writer`. InputStream и OutputStream предназначены для чтения и записи байтов, а Reader и Writer - для чтения и записи символов. Каждый из этих классов имеет ряд наследников и различных реализаций, которые могут использоваться для работы с различными типами потоков данных, такими как файлы, сетевые соединения, массивы байтов и т.д.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 938. `В каких пакетах расположены классы потоков ввода/вывода?`
В Java классы, связанные с потоками ввода/вывода, расположены в пакетах java.io и java.nio.
Классы потоков ввода/вывода в Java расположены в пакете java.io. Этот пакет содержит классы, необходимые для ввода и вывода данных из потоков в различных форматах. Классы потоков ввода/вывода могут быть использованы для работы с файловой системой или с сетью, а также для работы с другими типами данных, например, массивами байтов и символьными данными.

Кроме того, начиная с Java 7, появился новый пакет java.nio.file, который содержит улучшенную поддержку работы с файловой системой и новые классы и интерфейсы для чтения и записи данных в файлы и другие источники. Классы из этого пакета используются вместе с классами из пакета java.io для выполнения работы с файлами и ввода-вывода в Java.

Некоторые классы из пакета java.io:

+ InputStream
+ OutputStream
+ Reader
+ Writer
+ File
+ FileInputStream
+ FileOutputStream
+ FileReader
+ FileWriter



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 939. `Какие подклассы класса InputStream вы знаете, для чего они предназначены?`

В Java есть множество подклассов класса InputStream. 

Некоторые из наиболее распространенных подклассов InputStream включают:

+ InputStream - абстрактный класс, описывающий поток ввода;
+ BufferedInputStream - буферизованный входной поток;
+ ByteArrayInputStream позволяет использовать буфер в памяти (массив байтов) в качестве источника данных для входного потока;
+ DataInputStream - входной поток для байтовых данных, включающий методы для чтения стандартных типов данных Java;
+ FileInputStream - входной поток для чтения информации из файла;
+ FilterInputStream - абстрактный класс, предоставляющий интерфейс для классов-надстроек, которые добавляют к существующим потокам полезные свойства;
+ ObjectInputStream - входной поток для объектов;
+ StringBufferInputStream превращает строку (String) во входной поток данных InputStream;
+ PipedInputStream реализует понятие входного канала;
+ PushbackInputStream - разновидность буферизации, обеспечивающая чтение байта с последующим его возвратом в поток, позволяет «заглянуть» во входной поток и увидеть, что оттуда поступит в следующий момент, не извлекая информации.
+ SequenceInputStream используется для слияния двух или более потоков InputStream в единый.

Каждый из этих подклассов предназначен для чтения данных из определенных источников и имеет свои собственные методы и функциональность для работы с этими данными.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 940. `Для чего используется PushbackInputStream?`

PushbackInputStream — это класс в Java IO API, который позволяет вам «отменить чтение» одного или нескольких байтов из входного потока. Это может быть полезно в ситуациях, когда вы прочитали больше данных, чем вам действительно нужно, и хотите «вернуть» лишние данные в поток, чтобы их можно было прочитать снова позже. Например, предположим, что вы читаете последовательность символов из потока и хотите оценить, соответствуют ли символы определенному шаблону. Если шаблон не совпадает, вы можете «не прочитать» символы и повторить попытку с другим шаблоном. Для этого вы можете использовать PushbackInputStream. Вот пример использования PushbackInputStream:

```java
PushbackInputStream in = new PushbackInputStream(inputStream);
int b = in.read();
if (b != 'X') {
  in.unread(b);
}

```
В этом примере мы создаем PushbackInputStream из существующего InputStream. Затем мы читаем один байт из потока, используя метод read(). Если байт не равен X, мы «не читаем» байт с помощью метода unread(). Это помещает байт обратно в поток, чтобы его можно было прочитать снова позже. Это всего лишь простой пример, но класс PushbackInputStream можно использовать во множестве более сложных сценариев, где вам нужно манипулировать содержимым входного потока.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 941. `Для чего используется SequenceInputStream?`

SequenceInputStream в Java — это класс, который используется для объединения двух или более входных потоков в один входной поток. Он читает из первого входного потока до тех пор, пока не будет достигнут конец файла, а затем читает из второго входного потока и так далее, пока не будет достигнут конец последнего входного потока. Это может быть полезно в ситуациях, когда вам нужно считывать данные из нескольких источников, как если бы они были одним источником. 

Например, у вас может быть программа, которой нужно считывать данные из нескольких файлов, но вы хотите обрабатывать их как один файл. 

В этом случае вы можете создать объект SequenceInputStream, передавая входные потоки для каждого файла, а затем читать из SequenceInputStream, как если бы это был один файл. Вот пример того, как вы можете использовать SequenceInputStream для чтения из двух входных файлов:

```java

InputStream input1 = new FileInputStream("file1.txt");
InputStream input2 = new FileInputStream("file2.txt");

SequenceInputStream sequence = new SequenceInputStream(input1, input2);

// Чтение из SequenceInputStream, как если бы это был один входной поток
int data = sequence.read();
while (data != -1) {
    // сделать что-то с данными

    data = sequence.read();
}

// Не забудьте закрыть потоки, когда закончите с ними
sequence.close();
input1.close();
input2.close();

```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 942. `Какой класс позволяет читать данные из входного байтового потока в формате примитивных типов данных?`

Класс DataInputStream позволяет читать данные из входного байтового потока в формате примитивных типов данных, включая типы данных boolean, byte, char, short, int, long, float, и double.

Пример использования DataInputStream для чтения целочисленного значения из байтового потока:
```java
import java.io.*;

public class ReadDemo {
   public static void main(String[] args) {
      byte[] buffer = { 0x12, 0x34, 0x56, 0x78 };
      ByteArrayInputStream input = new ByteArrayInputStream(buffer);
      DataInputStream dataInput = new DataInputStream(input);
      try {
         int value = dataInput.readInt();
         System.out.println(value);
      } catch (IOException e) {
         e.printStackTrace();
      }
   }
}
```

Этот код будет выводить число 305419896, которое является результатом чтения четырех байтов из байтового потока в формате int.

Пример использования:
```java
InputStream inputStream = new FileInputStream("data.bin");
DataInputStream dataInputStream = new DataInputStream(inputStream);

int intValue = dataInputStream.readInt();
float floatValue = dataInputStream.readFloat();
String stringValue = dataInputStream.readUTF();

dataInputStream.close();
```
В этом примере мы читаем из файла data.bin целое число, число с плавающей точкой и строку в формате UTF-8.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 943. `Какие подклассы класса OutputStream вы знаете, для чего они предназначены?`

Класс OutputStream в Java представляет абстрактный класс для всех выходных потоков байтов. Подклассы класса OutputStream определяют конкретные типы потоков вывода, которые могут использоваться для записи данных в различные цели, например, файлы или сетевые соединения.

Некоторые из наиболее распространенных подклассов класса OutputStream в Java включают в себя:

+ `FileOutputStream` - позволяет записывать данные в файлы.
+ `ByteArrayOutputStream` - позволяет записывать данные в память в виде массива байтов.
+ `FilterOutputStream` - представляет класс-оболочку, который добавляет определенную функциональность к уже существующему потоку вывода.
+ `ObjectOutputStream` - используется для записи объектов Java в поток вывода.
+ `DataOutputStream` - позволяет записывать примитивные типы данных Java (byte, short, int, long, float, double, boolean, char) в поток вывода.

Каждый из этих подклассов класса OutputStream предназначен для определенной цели и может использоваться в различных ситуациях в зависимости от требований приложения.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 944. `Какие подклассы класса Reader вы знаете, для чего они предназначены?`

Класс java.io.Reader - это абстрактный класс для чтения символьных данных из потока. Его подклассы предназначены для чтения из различных источников, включая файлы, буферы, символьные массивы и т.д.

Некоторые из подклассов Reader в Java включают:

+ `BufferedReader`: для более эффективного чтения данных из потока, чем чтение по одному символу за раз.
+ `InputStreamReader`: читает символы из InputStream и выполняет преобразование байтов в символы используя определенную кодировку.
+ `FileReader`: для чтения символов из файла в кодировке по умолчанию.
+ `CharArrayReader`: для чтения символов из входного символьного массива.
+ `StringReader`: для чтения символов из входной строки.

Эти подклассы часто используются в различных приложениях Java для чтения символьных данных из различных источников.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 945. `Какие подклассы класса Writer вы знаете, для чего они предназначены?`

Класс Writer и его подклассы предоставляют удобный способ записи символьных данных в потоки. Некоторые из подклассов Writer:

+ `BufferedWriter`: буферизует символьный вывод для повышения производительности.
+ `OutputStreamWriter`: конвертирует вывод OutputStream в символы.
+ `PrintWriter`: предоставляет удобные методы печати форматированного текста.
+ `StringWriter`: записывает символы в строку, которую можно затем использовать для получения символьных данных в виде строки.

Пример использования BufferedReader для записи символьных данных в файл:
```java
try (BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"))) {
    writer.write("Hello, world!");
} catch (IOException ex) {
    System.err.println("Failed to write to file: " + ex.getMessage());
}
```
В этом примере создается экземпляр BufferedWriter, который оборачивает FileWriter и буферизует символьный вывод, и затем вызывает его метод write, чтобы записать строку "Hello, world!". Если происходит ошибка записи, программа выводит сообщение об ошибке в стандартный поток ошибок.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 946. `В чем отличие класса PrintWriter от PrintStream?`

Класс PrintWriter и PrintStream - это классы ввода/вывода в Java, которые позволяют записывать текстовые данные в поток вывода (например, файл, консоль или сеть) с помощью методов, которые обрабатывают разные типы данных.

Главное отличие между PrintWriter и PrintStream заключается в том, как они обрабатывают исключения. В качестве части их обязательств по обработке исключений, PrintStream предоставляет методы checkError(), а PrintWriter возвращает исключение с помощью метода getError().

Кроме того, PrintStream использует кодировку, которая зависит от настроек операционной системы, в то время как PrintWriter всегда использует кодировку по умолчанию. Наконец, PrintWriter более эффективен, чем PrintStream на запись в файлы, так как использует меньше буферов памяти.

Если вам нужно выводить текстовые данные в поток вывода, то в большинстве случаев вы можете использовать любой из этих классов. Однако, если вам нужно более эффективный способ записи данных в файл, рекомендуется использовать PrintWriter.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 947. `Чем отличаются и что общего у InputStream, OutputStream, Reader, Writer?`

InputStream, OutputStream, Reader, и Writer в Java являются частью пакетов Java io и Java nio, которые позволяют выполнять чтение и запись данных из/в файла или другого потока.

InputStream и OutputStream используются для чтения и записи двоичных данных (байтов) из/в поток. Reader и Writer используются для чтения и записи символьных данных (текста) из/в поток.

Все эти классы имеют общий предок, а именно класс java.io.InputStream. InputStream и Reader - это классы, которые являются частью java.io пакета, тогда как OutputStream и Writer - это часть пакета java.io, как один из вариантов NIO (новый ввод-вывод), доступный в Java 4 и более поздних версиях.

Если нужно читать и записывать текстовые данные, то рекомендуется использовать классы Reader и Writer. Если нужно работать с бинарными данными, то используйте InputStream и OutputStream.

Некоторые классы, такие как BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriter и др., дополнительно добавляют функциональность, такую как буферизация, что упрощает работу с данными.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 948. `Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?`

В Java для преобразования байтовых потоков в символьные и обратно используются классы InputStreamReader и OutputStreamWriter.

Класс InputStreamReader позволяет считывать байты из InputStream и преобразовывать их в символы в соответствии с выбранной кодировкой.

Класс OutputStreamWriter позволяет записывать символы в OutputStream и преобразовывать их в байты в соответствии с выбранной кодировкой.

Примеры использования:

`Чтение из InputStream и перевод в строку`:
```java
InputStream input = new FileInputStream("file.txt");
Reader reader = new InputStreamReader(input, "UTF-8");
StringBuilder result = new StringBuilder();
int ch;
while ((ch = reader.read()) != -1) {
    result.append((char) ch);
}
reader.close();
input.close();
String str = result.toString();
```
`Запись строки в OutputStream`:
```java
OutputStream output = new FileOutputStream("file.txt");
Writer writer = new OutputStreamWriter(output, "UTF-8");
String str = "Привет, мир!";
writer.write(str);
writer.close();
output.close();
```
Обратите внимание, что в приведенных примерах используется кодировка UTF-8. Вы можете выбрать любую другую поддерживаемую кодировку в зависимости от ваших потребностей.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 949. `Какие классы позволяют ускорить чтение/запись за счет использования буфера?`

В Java для ускорения чтения и записи данных рекомендуется использовать буферизованные классы из пакета java.io. Вот некоторые классы, которые могут помочь в этом:

+ `BufferedInputStream` - буферизованный входной поток данных, который считывает данные из исходного потока в буфер и возвращает данные из буфера при каждом вызове метода read().
+ `BufferedOutputStream` - буферизованный выходной поток данных, который записывает данные в буфер и отправляет данные из буфера в целевой поток при каждом вызове метода flush().
+ `BufferedReader` - буферизованный символьный входной поток, который читает данные из исходного потока и возвращает данные из буфера при каждом вызове метода read().
+ `BufferedWriter` - буферизованный символьный выходной поток, который записывает данные в буфер и отправляет данные из буфера в целевой поток при каждом вызове метода flush().

Все эти классы предоставляют более эффективный способ чтения и записи данных благодаря использованию буфера. При использовании этих классов количество обращений к исходному потоку/целевому потоку уменьшается, что может ускорить процесс.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 950. `Какой класс предназначен для работы с элементами файловой системы?`

Для работы с элементами файловой системы в Java используется класс java.nio.file.Files из пакета nio. Примеры методов:

+ `Files.exists(Path path)` - проверяет существование файла или директории по указанному пути
+ `Files.isDirectory(Path path)` - проверяет, является ли файл, указанный по пути, директорией
+ `Files.isRegularFile(Path path)` - проверяет, является ли файл, указанный по пути, обычным (не директорией или специальным)
+ `Files.createDirectory(Path dir)` - создает директорию по указанному пути
+ `Files.createFile(Path file) - создает обычный файл по указанному пути

Например:
```java
import java.nio.file.*;

public class Example {
  public static void main(String[] args) {
    Path path = Paths.get("/path/to/file.txt");
    if (Files.exists(path)) {
      System.out.println("File exists.");
    } else {
      System.out.println("File does not exist.");
    }
  }
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 951.`Какие методы класса File вы знаете?`

Некоторые методы класса File в Java:

+ `exists()` - возвращает true, если файл или каталог существует.
+ `getName()` - возвращает имя файла или каталога.
+ `isDirectory()` - возвращает true, если это каталог.
+ `isFile()` - возвращает true, если это файл.
+ `list()` - возвращает список всех файлов и каталогов в данном каталоге.
+ `mkdir()` - создает каталог с заданным именем.
+ `delete()` - удаляет файл или пустой каталог.
+ `getPath()` - возвращает путь к файлу или каталогу в виде строки.
+ `renameTo()` - переименовывает файл или каталог.
+ `lastModified()` - возвращает время последней модификации файла.
+ `length()` - возвращает размер файла в байтах.
+ `getAbsolutePath()` - возвращает абсолютный путь к файлу или каталогу.

Пример использования:
```java
import java.io.File;

public class FileExample {
    public static void main(String[] args) {
        File file = new File("example.txt");
        if (file.exists()) {
            System.out.println("File exists");
            System.out.println("File size: " + file.length() + " bytes");
        } else {
            System.out.println("File not found.");
        }
    }
}
```
Эта программа проверяет, существует ли файл example.txt и выводит его размер в байтах, если он существует.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 952. `Что вы знаете об интерфейсе FileFilter?`

Интерфейс FileFilter в Java используется для фильтрации файлов в директории при использовании методов list() и listFiles() класса File. Он содержит единственный метод accept(), который принимает объект File и возвращает логическое значение, указывающее, должен ли объект File быть включен в результат фильтрации.

Вот пример использования интерфейса FileFilter:
```java
import java.io.File;
import java.io.FileFilter;

public class MyFileFilter implements FileFilter {
    @Override
    public boolean accept(File file) {
        // Реализация вашего фильтра
        return file.getName().endsWith(".txt"); // Возвращает true, если файл имеет расширение .txt
    }
}

public class Main {
    public static void main(String[] args) {
        File dir = new File("/path/to/directory");

        File[] files = dir.listFiles(new MyFileFilter());
        for (File file : files) {
            System.out.println(file.getName());
        }
    }
}
```
Это позволяет вывести имена всех файлов в директории, которые имеют расширение .txt. Отфильтрованный массив files передается в качестве аргумента в метод listFiles().




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 953. `Как выбрать все элементы определенного каталога по критерию (например, с определенным расширением)?`

Для выбора всех элементов определенного каталога по критерию в Java можно использовать метод listFiles() класса java.io.File, который возвращает массив объектов File, представляющих файлы и каталоги в указанном каталоге. Затем можно перебирать этот массив и выбрать только те файлы, которые совпадают с нужным критерием, например, расширением. Вот пример кода, который выбирает все файлы в каталоге, удовлетворяющие критерию расширения ".txt":
```java
import java.io.File;

public class FileFilterExample {
    public static void main(String[] args) {
        File dirPath = new File("/path/to/directory");
        File[] files = dirPath.listFiles((dir, name) -> name.toLowerCase().endsWith(".txt"));
        // process the selected files
        for (File file : files) {
            // do something with the file
        }
    }
}
```
В этом примере используется лямбда-выражение для фильтрации файлов по расширению. Вы можете настроить это выражение в соответствии с вашими нуждами.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 954. `Какие режимы доступа к файлу есть у RandomAccessFile?`

У класса RandomAccessFile в Java есть несколько режимов доступа к файлу:

+ `"r" (read-only)` - только для чтения. Если файл не существует, выбрасывается исключение FileNotFoundException.
+ `"rw" (read-write)` - для чтения и записи. Если файл не существует, он создается.
+ `"rws" (read-write-sync)` - для чтения и записи, с синхронной записью изменений на диск. Если файл не существует, он создается.
+ `"rwd" (read-write-data-sync)` - для чтения и записи, с синхронной записью изменений данных на диск. Если файл не существует, он создается.

Например, для открытия файла в режиме "read-write" можно использовать следующий код:
```java
RandomAccessFile file = new RandomAccessFile("file.txt", "rw");
```
Обратите внимание, что при открытии файла в режиме "rws" или "rwd" операции записи могут производиться медленнее из-за синхронизации со стороны системы ввода-вывода.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 955. `Какие классы поддерживают чтение и запись потоков в компрессированном формате?`

На языке Java, чтение и запись в компрессированном формате поддерживается классами DeflaterOutputStream и InflaterInputStream, которые находятся в пакете java.util.zip.

`DeflaterOutputStream` - это класс для записи байтов в поток, при этом данные сжимаются при помощи алгоритма сжатия Deflate. Пример использования:
```java
OutputStream outputStream = new DeflaterOutputStream(new FileOutputStream("compressed.gz"));
outputStream.write("Hello World".getBytes());
outputStream.close();
```
`InflaterInputStream` - это класс для чтения байтов из потока и автоматического разжатия с использованием алгоритма сжатия Deflate. Пример использования:
```java
InputStream inputStream = new InflaterInputStream(new FileInputStream("compressed.gz"));
byte[] buffer = new byte[1024];
int length;
while ((length = inputStream.read(buffer)) > 0) {
    System.out.print(new String(buffer, 0, length));
}
inputStream.close();
```
Обратите внимание, что в приведенных примерах в качестве сжатия используется алгоритм Deflate, но также существуют другие алгоритмы, такие как GZIP, которые также могут быть использованы для сжатия потоков данных.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 956. `Существует ли возможность перенаправить потоки стандартного ввода/вывода?`

Да, в Java можно перенаправить потоки стандартного ввода/вывода. Для этого можно использовать классы System.in, System.out и System.err. Например, чтобы перенаправить стандартный поток ввода на файл, можно использовать класс FileInputStream:
```java
System.setIn(new FileInputStream("input.txt"));
```
После этого все вызовы System.in.read() будут читать данные из файла "input.txt" вместо стандартного потока ввода.

Аналогично, чтобы перенаправить стандартный поток вывода в файл, можно использовать класс FileOutputStream:
```java
System.setOut(new FileOutputStream("output.txt"));
```
После этого все вызовы System.out.println() будут записывать данные в файл "output.txt" вместо стандартного потока вывода.

При необходимости можно также перенаправить стандартный поток ошибок, используя метод System.setErr().



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 957. `Какой символ является разделителем при указании пути в файловой системе?`

В Java разделителем пути в файловой системе является символ / (slash).

Например, чтобы указать путь к файлу example.txt в папке mydir на диске C, можно использовать следующую строку:
```java
String filePath = "C:/mydir/example.txt";
```
Однако на операционных системах Windows можно использовать и символ \ (backslash) в качестве разделителя пути. В этом случае нужно экранировать символ обратной косой черты, чтобы он был интерпретирован как символ-разделитель. Например:
```java
String filePath = "C:\\mydir\\example.txt";
```
В любом случае, лучше всего использовать File.separator для обеспечения переносимости кода между разными операционными системами. Это позволяет автоматически определить корректный символ-разделитель пути в зависимости от операционной системы, на которой выполняется код. Например:
```java
String filePath = "C:" + File.separator + "mydir" + File.separator + "example.txt";
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 958. `Что такое «абсолютный путь» и «относительный путь»?`

`"Абсолютный путь"` - это путь к файлу или директории, который начинается с корневого каталога файловой системы, идентифицирующий конкретный файл или директорию на компьютере без ссылки на текущую директорию. Например, в операционной системе Windows абсолютный путь может иметь вид "C:\Users\John\Documents\file.txt".

`"Относительный путь"` - это путь, который начинается с текущей директории и указывает на файл или директорию относительно нее. То есть, это путь относительно текущего каталога (или другой точки отсчета). Например, если текущая директория в Windows - "C:\Users\John", а нужный файл находится в подкаталоге "Documents", то относительный путь будет выглядеть как "Documents\file.txt".

В языке Java, класс File имеет методы, которые могут возвращать абсолютный и относительный пути, такие как getAbsolutePath() и getPath(). Чтобы получить абсолютный путь, можно использовать метод getAbsolutePath(), а для получения относительного - getPath(). Например:
```java
File file = new File("Documents/file.txt");
String absolutePath = file.getAbsolutePath(); // абсолютный путь
String relativePath = file.getPath(); // относительный путь
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 959. `Что такое «символьная ссылка»?`

`"Символьная ссылка" ("symbolic link")` в Java - это ссылка, которая указывает на другой файл или каталог в файловой системе. В отличие от "жестких ссылок" ("hard links"), символьные ссылки могут указывать на файлы или каталоги на других разделах диска и даже на других машинах в сети. Символьные ссылки создаются с помощью метода java.nio.file.Files.createSymbolicLink() или с помощью команды ln -s в командной строке. Они широко используются в операционных системах Unix и Linux, но также поддерживаются в Windows, начиная с версии Windows Vista. Использование символьных ссылок в Java может быть полезно, например, для организации структуры файловой системы или для обработки файлов по определенной системе с помощью относительных путей. Обратите внимание, что символьные ссылки не поддерживаются в файловых системах FAT32 и NTFS до Windows Vista, а также не работают на macOS при использовании Time Machine.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 960. `Какие существуют виды потоков ввода/вывода?`

В Java существуют два вида потоков ввода/вывода - байтовые потоки и символьные потоки.

Байтовые потоки ввода/вывода предназначены для операций ввода/вывода байтовых данных, таких как изображения, аудио и видеофайлы. Конкретные классы, связанные с байтовыми потоками ввода/вывода, включают FileInputStream и FileOutputStream.

Символьные потоки ввода/вывода, с другой стороны, предназначены для операций ввода и вывода символьных данных, таких как текстовые файлы. Они конвертируют символы в байты для сетевых операций или записи в файлы, и наоборот. Конкретные классы, связанные с символьными потоками ввода/вывода, включают FileReader и FileWriter.

+ `InputStream` - поток ввода байтов из источника данных.
+ `OutputStream` - поток вывода байтов в приемник данных.
+ `Reader` - поток символьного ввода данных.
+ `Writer` - поток символьного вывода данных.

Зачастую, символьные потоки ввода/вывода используются в паре с классами BufferedReader и BufferedWriter для более эффективного чтения и записи данных.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 961. `Назовите основные предки потоков ввода/вывода.`

Основными предками потоков ввода-вывода в Java являются классы InputStream, OutputStream, Reader и Writer. Классы InputStream и Reader предоставляют методы для чтения данных из потока, а классы OutputStream и Writer предоставляют методы для записи данных в поток. Классы InputStream и OutputStream работают с байтами, а классы Reader и Writer работают с символами. Эти классы и их наследники используются для работы с различными типами потоков, такими как файловые потоки, сокеты, буферизованные потоки на основе других потоков и т.д.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 962. `Что общего и чем отличаются следующие потоки: InputStream, OutputStream, Reader, Writer?`

В Java, классы InputStream, OutputStream, Reader и Writer являются основными классами для работы с потоками данных.

+ `InputStream` - это абстрактный класс, представляющий входной поток байтов. Классы, наследующие InputStream, позволяют читать данные из различных источников, таких как файлы или сетевые соединения.

+ `OutputStream` - это абстрактный класс, представляющий выходной поток байтов. Классы, наследующие OutputStream, позволяют записывать данные в различные места назначения, такие как файлы или сетевые соединения.

+ `Reader` - это абстрактный класс, представляющий входной поток символов. Классы, наследующие Reader, позволяют читать текстовые данные из различных источников, таких как файлы или сетевые соединения.

+ `Writer` - это абстрактный класс, представляющий выходной поток символов. Классы, наследующие Writer, позволяют записывать текстовые данные в различные места назначения, такие как файлы или сетевые соединения.

В общем, все эти классы предоставляют абстракцию для чтения и записи данных в Java. Они предоставляют различные методы для чтения и записи данных, а также методы для управления потоком данных, такие как закрытие потока.

Главное отличие между InputStream/OutputStream и Reader/Writer заключается в том, что первые являются потоками байтов, а вторые - потоками символов, то есть они работают с разными типами данных. Однако, Reader и Writer работают только с кодировками Unicode, тогда как InputStream и OutputStream работают с байтами



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 963. `Что вы знаете о RandomAccessFile?`
RandomAccessFile — это класс в пакете java.io, который позволяет вам читать и записывать данные в файл в режиме произвольного доступа. Это означает, что вы можете читать или писать в любую точку файла, а не ограничиваться чтением или записью последовательно с начала или конца файла. 

Вы можете использовать класс RandomAccessFile для выполнения низкоуровневых операций ввода-вывода в файле, таких как чтение и запись байтов или символов, установка указателя файла в определенную позицию и получение текущей позиции указателя файла. Класс RandomAccessFile поддерживает как чтение, так и запись в файл. 

Вот пример создания объекта RandomAccessFile и чтения из него:
```java
import java.io.*;

public class RandomAccessFileExample {
    public static void main(String[] args) {
        try {
            RandomAccessFile file = new RandomAccessFile("filename.txt", "r");
            file.seek(10); // set the file pointer to position 10
            byte[] buffer = new byte[1024];
            int bytesRead = file.read(buffer, 0, buffer.length);
            System.out.println(new String(buffer, 0, bytesRead));
            file.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```
В этом примере мы создаем объект RandomAccessFile с именем файла «filename.txt» и режимом «r» (только для чтения). Затем мы устанавливаем указатель файла в позицию 10 с помощью метода seek() и считываем до 1024 байтов из файла в буфер с помощью метода read(). Наконец, мы выводим содержимое буфера на консоль. 

RandomAccessFile может быть полезным классом для определенных файловых операций ввода-вывода, когда вам нужно читать или записывать в определенные места в файле.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 964. `Какие есть режимы доступа к файлу?`

В Java для работы с файлами можно использовать класс File и класс RandomAccessFile. Класс RandomAccessFile имеет следующие режимы доступа к файлу:

+ "r" - открытие файла только для чтения;
+ "rw" - открытие файла для чтения и записи;
+ "rws" - открытие файла для чтения и записи, при этом каждое изменение записывается на диск синхронно;
+ "rwd" - открытие файла для чтения и записи, при этом каждое изменение записывается на диск в более общем случае.

Здесь "r" означает чтение (read), "w" - запись (write), "s" - синхронизация (synchronize), "d" - запись на диск (disk).

Для работы с файлами класс File использует следующие флаги:

+ "r" - открытие файла только для чтения;
+ "w" - перезапись файла, если он существует;
+ "a" - добавление данных в конец файла, если он существует
+ "x" - создание нового файла и открытие его для записи
+ "rw" - открытие файла для чтения и записи.

Например, для открытия файла только для чтения можно использовать такой код:
```java
File file = new File("filename.txt");
RandomAccessFile raf = new RandomAccessFile(file, "r");
```
Для открытия файла для записи используйте режим "rw".




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 965. `В каких пакетах лежат классы-потоки?`

В Java классы-потоки находятся в пакете java.io. Некоторые из наиболее часто используемых классов потоков включают InputStream, OutputStream, Reader and Writer. Они используются для ввода и вывода данных из файлов, сетевых соединений и других источников/целей. Кроме того, в пакете java.util.concurrent содержатся классы, которые используют потоки для работы с многопоточностью.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 966. `Что вы знаете о классах-надстройках?`

Классы-надстройки (wrapper classes) в Java представляют обёртки для примитивных типов данных, чтобы их можно было использовать в качестве объектов. Они необходимы, когда нужно передать примитивный тип данных в некоторый метод, который ожидает объект.

Например:

+ Integer - для целочисленных значений типа int
+ Double - для чисел с плавающей точкой типа double
+ Boolean - для значений true и false типа boolean
+ Character - для символов типа char
+ Byte - для байтов типа byte

Классы-надстройки имеют множество полезных методов, позволяющих работать с примитивными значениями как с объектами. Например, Double имеет методы для округления чисел, конвертации в другие типы данных, сравнения, и т.д.

Значения классов-надстроек могут быть изменены, например:
```java
Integer i = 5;
i++; // i теперь равно 6
```
Обратите внимание, что создание объектов классов-надстроек может иметь небольшой накладной расход по памяти и производительности. Используйте их только тогда, когда это действительно требуется, например, при работе с коллекциями объектов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 967. `Какой класс-надстройка позволяет читать данные из входного байтового потока в формате примитивных типов данных?`

Класс-надстройка DataInputStream позволяет читать данные из входного байтового потока в формате примитивных типов данных. Этот класс обеспечивает методы для чтения 8-, 16- и 32-битных значений типов byte, short, int, float и double из потока. Он также обеспечивает методы для чтения символов и строк из потока. Все методы DataInputStream являются синхронизированными для поддержания правильной последовательности чтения данных из потока. Главный недостаток этого класса заключается в том, что он не прочитает данные напрямую из файловой системы, но будет использовать переданный ему InputStream.

Объект DataInputStream может быть использован для чтения примитивных типов данных, таких как boolean, byte, char, short, int, long, float и double. Кроме того, его можно использовать для чтения строк, массивов байтов и других объектов, записанных в поток методами класса DataOutputStream. Например:
```java
import java.io.*;

public class Main {
  public static void main(String[] args) throws IOException {
    FileInputStream fis = new FileInputStream("data.dat");
    DataInputStream dis = new DataInputStream(fis);
    int i = dis.readInt();
    float f = dis.readFloat();
    double d = dis.readDouble();
    System.out.println("i = " + i);
    System.out.println("f = " + f);
    System.out.println("d = " + d);
  }
}
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 968. `Какой класс-надстройка позволяет ускорить чтение/запись за счет использования буфера?`

Класс BufferedInputStream и BufferedOutputStream являются надстройками над InputStream и OutputStream. Они добавляют внутренний буфер, который может ускорить процесс чтения/записи данных. Буферизация обычно полезна, если вы читаете или записываете данные блоками, а не по одному байту.

Вот пример использования BufferedInputStream в Java для чтения файла с диска:
```java
try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream("file.txt"))) {
    byte[] buffer = new byte[1024];
    int bytesRead = 0;
    while ((bytesRead = bis.read(buffer)) != -1) {
        // обработка bytesRead байтов данных из буфера
    }
} catch (IOException ex) {
    // обработка исключения
}
```
В этом примере BufferedInputStream читает данные из файла file.txt с диска, используя буфер размером 1024 байта. Когда буфер заполнен, данные копируются в массив buffer и обрабатываются в блоке while.

Для записи данных в файл нужно использовать BufferedOutputStream. Вот пример:
```java
try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("output.txt"))) {
    byte[] data = "Hello, World!".getBytes();
    bos.write(data);
} catch (IOException ex) {
    // обработка исключения
}
```
Этот пример записывает строку "Hello, World!" в файл output.txt используяBufferedOutputStream.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 969. `Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?`

В Java для преобразования байтовых потоков в символьные и обратно, можно использовать классы InputStreamReader и OutputStreamWriter, которые предоставляют мосты между символьными и байтовыми потоками.

InputStreamReader позволяет читать символы из байтового потока, используя определенную кодировку. Пример использования:
```java
InputStream inputStream = new FileInputStream("file.txt");
InputStreamReader reader = new InputStreamReader(inputStream, "UTF-8");
```
В этом примере мы создаем InputStream для файла "file.txt" и передаем его как аргумент в конструктор InputStreamReader вместе с кодировкой UTF-8.

OutputStreamWriter, с другой стороны, используется для записи символов в выходной байтовый поток. Пример использования:
```java
OutputStream outputStream = new FileOutputStream("file.txt");
OutputStreamWriter writer = new OutputStreamWriter(outputStream, "UTF-8");
```
В этом примере мы создаем OutputStream для файла "file.txt" и передаем его как аргумент в конструктор OutputStreamWriter вместе с кодировкой UTF-8.

Эти классы являются обертками над потоками чтения и записи, и позволяют представлять данные в разных форматах, используя различные кодировки, такие как UTF-8, ISO-8859-1 и другие.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 970. `Какой класс предназначен для работы с элементами файловой системы (ЭФС)?`

В Java класс, предназначенный для работы с элементами файловой системы (эфс), называется java.nio.file.Files. Он предоставляет статические методы для манипуляции с файлами, такие как создание, копирование, перемещение, удаление, а также получение информации о файлах, такой как размер, время доступа и т.д. Например, чтобы получить размер файла, вы можете использовать метод Files.size(Path path), где path - это объект типа Path, представляющий путь к файлу. Пример:
```java
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.IOException;

public class Main {
  public static void main(String[] args) {
    Path path = Paths.get("path/to/file.txt");
    try {
      long size = Files.size(path);
      System.out.println("File size: " + size + " bytes");
    } catch (IOException e) {
      System.err.println("Failed to get file size: " + e.getMessage());
    }
  }
}
```
Замените "path/to/file.txt" на путь к файлу, с которым вы хотите работать в вашей файловой системе.

Например, чтобы создать новый файл, можно использовать следующий код:
```java
File file = new File("path/to/file.txt");
try {
    boolean success = file.createNewFile();
    if (success) {
        System.out.println("File created successfully.");
    } else {
        System.out.println("File already exists.");
    }
} catch (IOException e) {
    System.out.println("An error occurred: " + e.getMessage());
}
```
Чтобы переместить или переименовать файл, можно использовать методы renameTo() или moveTo(). Чтение содержимого файла можно выполнить с помощью FileReader, а запись с помощью FileWriter.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 971. `Какой символ является разделителем при указании пути к ЭФС?`

В Java символ, который является разделителем пути к файлам и директориям на ЭФС (файловой системе), зависит от операционной системы. Например, для Windows используется обратный слеш \, а для большинства UNIX-подобных систем используется прямой слеш /. Чтобы обеспечить переносимость между разными операционными системами, в Java есть константа File.separator, которая представляет соответствующий разделитель для текущей операционной системы. Вы можете использовать эту константу вместо жестко закодированного разделителя в своих программах Java. Например:
```java
String path = "C:" + File.separator + "mydir" + File.separator + "myfile.txt";
```
Здесь File.separator будет заменен на правильный символ разделителя в зависимости от операционной системы, на которой запущена программа Java.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 972. `Как выбрать все ЭФС определенного каталога по критерию (например, с определенным расширением)?`

Для выбора всех файлов с определенным расширением из каталога в Java можно воспользоваться методом listFiles() класса java.io.File. Сначала нужно создать объект File для нужного каталога, а затем вызвать на нем метод listFiles() и передать ему фильтр, который будет выбирать только файлы с нужным расширением. Вот пример кода:
```java
import java.io.File;

public class Main {
    public static void main(String[] args) {
        File directory = new File("/path/to/directory");
        File[] files = directory.listFiles((dir, name) -> name.endsWith(".txt"));

        for (File file : files) {
            System.out.println(file.getName());
        }
    }
}
```
В этом примере выбираются все файлы с расширением .txt. Если нужно выбрать файлы с другим расширением, то нужно изменить соответствующую часть условия в лямбда-выражении, передаваемом в качестве второго аргумента методу listFiles().



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 973. `Что вы знаете об интерфейсе FilenameFilter?`
Для фильтрации содержимого директории в Java используется интерфейс FilenameFilter. Он содержит один метод boolean accept(File dir, String name), который принимает два аргумента: объект типа File, представляющий родительскую директорию, и строку с именем файла. Метод accept() должен возвращать true, если файл должен быть включен в результаты списка, и false, если файл должен быть исключен.

Например, следующий код демонстрирует, как использовать интерфейс FilenameFilter для вывода только файлов с расширением ".txt" из директории:
```java
import java.io.*;

public class FilterFiles {

    public static void main(String[] args) {

        // указываем путь к директории
        File dir = new File("/path/to/directory");

        // создаем экземпляр класса, реализующего интерфейс FilenameFilter
        FilenameFilter txtFilter = new FilenameFilter() {
            public boolean accept(File dir, String name) {
                return name.toLowerCase().endsWith(".txt");
            }
        };

        // получаем список файлов, отфильтрованных по расширению
        File[] filesList = dir.listFiles(txtFilter);

        // выводим список файлов
        for (File file : filesList) {
            if (file.isFile()) {
                System.out.println(file.getName());
            }
        }
    }
}
```
Этот код создает объект типа FilenameFilter с помощью анонимного класса и метода accept() для фильтрации файлов с расширением .txt. Затем создается массив File[] с отфильтрованными файлами и выводятся их имена.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 974. `Что такое сериализация?`

`Сериализация` в Java - это механизм, который позволяет сохранять состояние объекта в виде последовательности байтов. Процесс сериализации используется для передачи объекта по сети или для сохранения его в файл (например, в базу данных). 

В Java для реализации сериализации объектов используется интерфейс Serializable. Этот интерфейс не содержит методов, его реализация всего лишь указывает компилятору, что объект может быть сериализован. После того, как объект сериализуется, его можно сохранить в файл или передать по сети в виде последовательности байтов. При необходимости объект можно восстановить из этой последовательности байтов (этот процесс называется десериализацией).






<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 975. `Какие классы позволяют архивировать объекты?`

Для архивирования объектов в Java можно использовать классы ObjectOutputStream и ObjectInputStream. Эти классы позволяют записывать и считывать объекты из потока данных. После записи объекта в поток, можно использовать классы ZipOutputStream или GZIPOutputStream, чтобы упаковать этот поток в архив с расширением ".zip" или ".gz". Чтобы прочитать архив, необходимо использовать классы ZipInputStream или GZIPInputStream, которые прочитают содержимое архива, а затем можно использовать ObjectInputStream, чтобы прочитать объекты из потока данных.

Пример использования:
```java
// Записываем объект в поток и упаковываем в gzip
MyObject obj = new MyObject();
try (FileOutputStream fos = new FileOutputStream("data.gz");
     GZIPOutputStream gzos = new GZIPOutputStream(fos);
     ObjectOutputStream out = new ObjectOutputStream(gzos)) {
    out.writeObject(obj);
}

// Распаковываем содержимое gzip и считываем объект из потока
try (FileInputStream fis = new FileInputStream("data.gz");
     GZIPInputStream gzis = new GZIPInputStream(fis);
     ObjectInputStream in = new ObjectInputStream(gzis)) {
    MyObject obj = (MyObject) in.readObject();
}
```
В данном примере создается объект класса MyObject, который записывается в поток данных, упаковывается в gzip-архив, записывается в файл, а затем считывается обратно из файла и извлекается объект класса MyObject.

Обратите внимание, что класс MyObject должен быть сериализуемым, то есть должен реализовывать интерфейс Serializable, чтобы его можно было записать и считать из потока объектов



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 7. Сериализация (перейти в раздел)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 976. `Что такое «сериализация»?`

`Сериализация` - это процесс преобразования объекта в последовательность байтов, которую можно сохранить в файле или передать по сети, а затем восстановить объект из этой последовательности байтов. В Java это может быть выполнено с помощью интерфейса Serializable.

Пример сериализации объекта в Java:
```java
import java.io.*;

public class SerializeDemo {
   public static void main(String[] args) {
      Employee e = new Employee();
      e.name = "John Doe";
      e.address = "123 Main St";
      e.SSN = 123456789;
      e.number = 101;
      
      try {
         FileOutputStream fileOut =
         new FileOutputStream("/tmp/employee.ser");
         ObjectOutputStream out = new ObjectOutputStream(fileOut);
         out.writeObject(e);
         out.close();
         fileOut.close();
         System.out.printf("Serialized data is saved in /tmp/employee.ser");
      } catch (IOException i) {
         i.printStackTrace();
      }
   }
}
```
Здесь объект класса Employee сериализуется в файл /tmp/employee.ser. Этот файл может быть впоследствии использован для восстановления объекта.

Пример десериализации объекта в Java:
```java
import java.io.*;

public class DeserializeDemo {
   public static void main(String[] args) {
      Employee e = null;
      try {
         FileInputStream fileIn = new FileInputStream("/tmp/employee.ser");
         ObjectInputStream in = new ObjectInputStream(fileIn);
         e = (Employee) in.readObject();
         in.close();
         fileIn.close();
      } catch (IOException i) {
         i.printStackTrace();
         return;
      } catch (ClassNotFoundException c) {
         System.out.println("Employee class not found");
         c.printStackTrace();
         return;
      }
      System.out.println("Deserialized Employee...");
      System.out.println("Name: " + e.name);
      System.out.println("Address: " + e.address);
      System.out.println("SSN: " + e.SSN);
      System.out.println("Number: " + e.number);
   }
}
```
Здесь файл /tmp/employee.ser содержит сериализованный объект класса Employee, который восстанавливается в переменную e, после чего можно получить доступ.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 977. `Какие условия “благополучной” сериализации объекта?`

Для "благополучной" сериализации Java объекта должны выполняться следующие условия:

+ Класс объекта должен быть сериализируемым (то есть должен реализовывать интерфейс Serializable).
+ Все поля объекта должны быть сериализируемыми (то есть должны быть помечены ключевым словом transient, если они не могут быть сериализованы).
+ Все недоступные поля внешних классов (если объект вложен в другой класс) должны быть помечены ключевым словом transient.
+ Если класс содержит ссылки на другие объекты, эти объекты также должны помечаться как Serializable.
+ Если в одном потоке создается несколько объектов, которые должны быть сериализованы одинаковым образом, то для каждого объекта должен использоваться тот же ObjectOutputStream.
+ Если класс содержит методы writeObject и readObject, то эти методы должны быть реализованы правильным образом.

Если все условия выполнены, то сериализация объекта должна проходить без ошибок.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 978. `Опишите процесс сериализации/десериализации с использованием Serializable.`
`
`В Java сериализация` - это процесс преобразования объекта в поток байтов для его сохранения или передачи другому месту, независимо от платформы. Интерфейс Serializable используется для обозначения класса, который может быть сериализован. Сериализация может быть использована для сохранения состояния объекта между запусками программы, для передачи состояния объекта другому приложению, и т.д.

Процесс сериализации в Java прост и автоматически обрабатывается стандартной библиотекой Java. Вот как это делается:

+ Создайте класс, который вы хотите сериализовать и сделайте его реализующим интерфейс Serializable.

+ Используйте ObjectOutputStream для записи объекта в поток байтов. Например:
```java
MyClass object = new MyClass();
FileOutputStream fileOut = new FileOutputStream("file.ser");
ObjectOutputStream out = new ObjectOutputStream(fileOut);
out.writeObject(object);
out.close();
fileOut.close();
```
+ Для десериализации объекта из потока байтов используйте ObjectInputStream. Например:
```java
FileInputStream fileIn = new FileInputStream("file.ser");
ObjectInputStream in = new ObjectInputStream(fileIn);
MyClass object = (MyClass) in.readObject();
in.close();
fileIn.close();
```
Объекты, которые сериализуются должны реализовать пустой конструктор, так как они должны быть воссозданы при десериализации.

Важно отметить, что сериализация не предназначена для безопасности и не должна использоваться для передачи чувствительных данных, таких как пароли или номера кредитных карт.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 979. `Как изменить стандартное поведение сериализации/десериализации?`

Чтобы изменить стандартное поведение сериализации/десериализации в Java, необходимо реализовать интерфейс Serializable и переопределить методы writeObject и readObject. Эти методы позволяют контролировать процесс сериализации/десериализации и включать/исключать специфические поля объекта.

Если вам нужно более тонкое управление над процессом сериализации/десериализации, например, сохранить объект в формате JSON, вы можете использовать библиотеки сериализации, такие как Jackson или Gson.

Например, вот как можно использовать библиотеку Jackson для сериализации/десериализации объекта в формат JSON:
```java
import com.fasterxml.jackson.databind.ObjectMapper;

// создать объект ObjectMapper
ObjectMapper mapper = new ObjectMapper();

// сериализовать объект в JSON
MyObject obj = new MyObject();
String json = mapper.writeValueAsString(obj);

// десериализовать JSON строку в объект
MyObject deserializedObj = mapper.readValue(json, MyObject.class);
```
Здесь MyObject - это класс, который вы хотите сериализовать в JSON. Вы также можете настроить свойства ObjectMapper, чтобы управлять процессом сериализации/десериализации более тонко.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 980. `Как исключить поля из сериализации?`

В Java для того, чтобы исключить поля из сериализации, можно использовать ключевое слово transient. Если вы отмечаете поле transient, то при сериализации объекта это поле будет пропущено, а при десериализации ему будет присвоено значение по умолчанию для его типа.

Пример:
```java
import java.io.Serializable;

public class MyClass implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name;
    private transient String password;
    //...
}
```
В этом примере поле password отмечено ключевым словом transient, так что оно будет пропущено при сериализации объекта MyClass.

Для других способов исключения полей из сериализации можно использовать аннотации @JsonIgnore и @JsonProperty из библиотеки Jackson или @Expose и @SerializedName из библиотеки Gson. Но вам необходимо их добавить как зависимости в ваш проект.

При использовании Jackson:
```java
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.ObjectMapper;

public class MyClass {
    private String name;
    @JsonIgnore
    private String password;
    //...
}
```
При использовании Gson:
```java
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;

public class MyClass {
    private String name;
    @Expose(serialize = false)
    @SerializedName("password")
    private String password;
    //...
}
```

Сериализация поля помеченного как transient будет пропущена. Кроме того, можно использовать аннотации @Transient или @JsonIgnore для исключения поля из сериализации.
```java
public class MyClass implements Serializable {
  private String field1;
  private transient String field2;
  @Transient
  private String field3;
  @JsonIgnore
  private String field4;
  // getters and setters
}
```
В данном примере field2 будет исключен из сериализации, а также field3 и field4 с помощью аннотаций. Обратите внимание, что для использования аннотации @JsonIgnore вам нужно добавить зависимость на библиотеку Jackson. Общая идея заключается в том, чтобы пометить поля, которые не должны быть сериализованы, как transient или использовать аннотации, которые сообщат маршаллеру или библиотеке сериализации, какие поля исключить.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 981. `Что обозначает ключевое слово transient?`

Ключевое слово transient в Java используется для указания, что поле класса не должно быть сериализовано при сохранении состояния объекта. Также помеченное как transient поле не будет восстановлено при десериализации объекта и его состояние будет инициализировано значением по умолчанию для данного типа. Например, если поле имеет тип int, то после десериализации оно будет равно 0.

Пример использования:
```java
import java.io.Serializable;

public class Example implements Serializable {
    private String name;
    private transient int age;

    public Example(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}
```
В данном примере поле age помечено как transient и не будет сериализовано при сохранении состояния объекта.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 982. `Какое влияние оказывают на сериализуемость модификаторы полей static и final.`

Модификаторы static и final в Java оказывают влияние на сериализуемость объектов при использовании механизма сериализации.

Поля, отмеченные модификатором transient, не сериализуются. Кроме того, поля, отмеченные модификатором static, не участвуют в процессе сериализации, то есть значения этих полей не будут сохранены в сериализованном объекте, независимо от того, были ли они инициализированы или нет.

Поля, отмеченные модификатором final, являются неизменяемыми и могут быть сериализованы и десериализованы. Если поле final не является static, его значение будет сериализовано и восстановлено при десериализации объекта.

Для того чтобы класс был сериализуемым, он должен реализовать интерфейс Serializable или Externalizable. Кроме того, все поля класса должны быть сериализуемыми, то есть должны быть Serializable или Externalizable, иначе будет возбуждено исключение NotSerializableException.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 983. `Как не допустить сериализацию?`

Для того чтобы не сериализовать определенные поля в Java, их необходимо отметить аннотацией @Transient. Это помечает поле как временное и при сериализации его значение будет игнорироваться. Кроме того, можно определить поля как static или transient, которые также не будут сериализоваться автоматически. Вот пример использования аннотации @Transient:
```java
public class MyClass implements Serializable {
    private String myField;
    @Transient
    private String myTransientField;
    // ... other fields, constructors, getters and setters
}
```
В этом примере поле myTransientField не будет сериализоваться при сохранении экземпляра MyClass.

Обратите внимание, что для того чтобы класс был сериализуемым, он должен реализовать интерфейс Serializable.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 984. `Как создать собственный протокол сериализации?`

Чтобы создать собственный протокол сериализации в Java, вы можете реализовать интерфейс Serializable или Externalizable в своем классе. Интерфейс Serializable обеспечивает реализацию сериализации по умолчанию, а интерфейс Externalizable позволяет настраивать сериализацию и десериализацию. Вот обзор того, как реализовать каждый интерфейс: 

+ `Сериализуемый`:
+ + Реализуйте интерфейс Serializable в своем классе. 
+ + Отметьте любые поля, которые вы не хотите сериализовать, с помощью ключевого слова transient. 
+ + Переопределите методы writeObject() и readObject(), если вы хотите настроить сериализацию или десериализацию.

+ `Внешний`:
+ + Реализуйте интерфейс Externalizable в своем классе. 
+ + Предоставьте общедоступный конструктор без аргументов для вашего класса. 
+ + Реализуйте методы writeExternal() и readExternal() для настройки сериализации и десериализации.

Для создания собственного протокола сериализации достаточно реализовать интерфейс Externalizable, который содержит два метода:
```java
public void writeExternal(ObjectOutput out) throws IOException;
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 985. `Какая роль поля serialVersionUID в сериализации?`

Поле serialVersionUID в Java играет ключевую роль в сериализации объектов. serialVersionUID- это статическое поле, которое нужно добавлять в классы для их сериализации. Когда объекты сериализуются, они получают свой уникальный serialVersionUID, который используется при десериализации для проверки, что версии классов совпадают и объект можно корректно восстановить. Если serialVersionUID не указан явно, то в качестве идентификатора используется хеш-код класса, что может привести к ошибкам при десериализации, если класс изменился.

Итак, если вы планируете сериализовать объекты в Java, важно явно задавать serialVersionUID для классов, которые вы сериализуете. Это поможет убедиться, что при разных запусках приложения объекты всегда будут десериализовываться корректно и предотвратит возможные ошибки.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 986. `Когда стоит изменять значение поля serialVersionUID?`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 987. `В чем проблема сериализации Singleton?`

Для решения этой проблемы можно использовать один из следующих подходов:

+ `Использовать Enum Singleton`, который уже предопределен и обеспечивает единственный экземпляр в любых условиях, в том числе и после десериализации.
+ `Объявить в классе Singleton методы readResolve() и writeReplace()`, чтобы переопределить процедуры сериализации и десериализации. Это позволит возвращать существующий экземпляр Singleton при десериализации.
+ `Организовать Singleton с помощью вложенного класса и статической инициализации`. Этот подход обеспечивает ленивую инициализацию и инстанцирование объекта Singleton.


Проблема сериализации Singleton заключается в том, что при десериализации объекта Singleton может быть создан новый экземпляр класса, что противоречит принципам Singleton (то есть гарантированного существования только одного экземпляра класса). Эту проблему можно решить, переопределив методы readResolve() и writeReplace(). Пример:
```java
public class Singleton implements Serializable {
    private static final long serialVersionUID = 1L;

    private Singleton() {
    }

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }

    protected Object readResolve() throws ObjectStreamException {
        return getInstance();
    }

    private Object writeReplace() throws ObjectStreamException {
        return getInstance();
    }
}
```
Этот подход гарантирует, что десериализованный объект будет таким же, как и объект, который был сериализован.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 988. `Какие существуют способы контроля за значениями десериализованного объекта?`

При десериализации объекта в Java можно использовать разные способы контроля за значениями. Наиболее распространенными способами являются использование модификатора transient и методов readObject() и readResolve().

+ `Модификатор transient`: если поле класса помечено модификатором transient, то оно не будет сериализоваться. Это позволяет контролировать, какие поля будут загружены при десериализации объекта.

+ `Метод readObject()`: при десериализации объекта вызывается метод readObject(), который позволяет контролировать значения загруженных полей. Этот метод должен быть определен в классе, который реализует интерфейс Serializable.
+ `Метод readResolve()`: после десериализации объекта вызывается метод readResolve(), который позволяет заменить десериализованный объект на другой объект. Этот метод также должен быть определен в классе, который реализует интерфейс Serializable.

Пример использования метода readObject():
```java
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    in.defaultReadObject();

    if (value < 0) {
        throw new InvalidObjectException("Negative value");
    }
}
```
В данном примере при десериализации объекта будет проверяться, что значение поля value не является отрицательным.

Пример использования метода readResolve():
```java
private Object readResolve() throws ObjectStreamException {
    if (this == INSTANCE) {
        return INSTANCE;
    } else {
        return new Singleton();
    }
}
```
В данном примере при десериализации объекта будет проверяться, что объект является синглтоном и, если это не так, будет создан новый объект класса Singleton.

к оглавлению


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 8. Потоки выполнения/многопоточность (перейти в раздел)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 989. `Дайте определение понятию “процесс”. Дайте определение понятию “поток”.`

В Java термин "процесс" обычно относится к отдельной программе, выполняющейся в операционной системе и имеющей свой уникальный идентификатор. Каждый процесс имеет свою собственную область оперативной памяти и запускается независимо от других процессов.

"Поток" (или "Thread") - это легковесный подпроцесс, который работает в рамках процесса и обладает своим собственным стеком вызовов и выполнением инструкций. Множество потоков может работать параллельно в рамках одного процесса и совместно использовать ресурсы, такие как память и CPU, что позволяет эффективнее использовать вычислительные ресурсы компьютера. Потоки могут работать дайнамически, т.е. создаваться и завершаться в процессе работы приложения.

В Java потоки могут быть созданы путем наследования от класса Thread или через реализацию интерфейса Runnable. При запуске потока метод run() становится активным и выполняется в отдельном потоке параллельно с другими потоками в рамках процесса.

Например, следующий код можно использовать для создания потока в Java:
```java
Thread myThread = new MyThread();
myThread.start();
```
где MyThread - пользовательский класс, унаследованный от класса Thread или реализующий интерфейс Runnable.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 990. `Дайте определение понятию “синхронизация потоков”.`

"Синхронизация потоков" - это процесс контроля над доступом к общим ресурсам между разными потоками исполнения в многопоточной среде. Это важный аспект многопоточного программирования, так как одновременный доступ к общим ресурсам может привести к проблемам безопасности и непредсказуемости работы программы.

В языке Java для синхронизации потоков используются мониторы (или блокировки), которые позволяют потокам входить в критические секции кода поочередно, в порядке очереди, чтобы избежать конфликтов при обращении к общему ресурсу. Для атомарных операций есть специальные синхронизированные методы, которые блокируют объект (или класс), чтобы гарантировать, что только один поток может выполнять код метода в любой момент времени.

Java также предоставляет ключевые слова synchronized и volatile, которые используются для синхронизации потоков. 

Ключевое слово synchronized может быть применено к методам и блокам кода, чтобы предотвратить одновременный доступ к общему ресурсу. 

Ключевое слово volatile используется для обозначения переменных, значения которых могут быть изменены другими потоками, и гарантирует, что любое изменение будет видно всем потокам.

Синхронизация потоков достигается путем использования механизмов, таких как мониторы, блокировки, условные переменные, семафоры и других. В Java для синхронизации потоков используются ключевые слова synchronized, wait, notify, notifyAll, а также классы Lock, Condition и другие.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 991. `Как взаимодействуют программы, процессы и потоки?`

Программы, процессы и потоки взаимодействуют друг с другом в Java и в других языках программирования следующим образом:

+ `Программы` - это наборы инструкций, написанных на Java или других языках программирования, которые могут выполняться на компьютере. Программы обычно состоят из одного или нескольких процессов.

+ `Процессы` - это экземпляры выполнения программы на компьютере. Каждый процесс имеет свою собственную область памяти и выполняется в отдельном потоке выполнения, независимо от других процессов на компьютере.

+ `Потоки` - это единицы выполнения внутри процесса. Каждый процесс может содержать несколько потоков, которые выполняются параллельно и совместно работают на решении задачи. Потоки внутри одного процесса имеют общую память и используют ее для обмена информацией.

Программы, процессы и потоки взаимодействуют друг с другом с помощью механизмов синхронизации и обмена информацией, таких как блокировки, семафоры и каналы. Например, процессы могут обмениваться данными, используя сокеты или механизмы межпроцессного взаимодействия, а потоки могут взаимодействовать друг с другом, используя блокировки или другие механизмы синхронизации.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 992. `В каких случаях целесообразно создавать несколько потоков?`

В Java многопоточность может быть полезна во многих случаях, включая:

+ `Улучшение производительности`: Если есть задача, которую можно легко разделить на несколько частей, то ее можно решить быстрее, используя несколько потоков. Например, можно использовать несколько потоков для обработки массивов данных или поиска в базе данных.

+ `Использование блокирующих операций`: Если задача включает блокирующие операции, такие как чтение из файла или сетевые операции, то многопоточность может помочь ускорить выполнение задачи, позволяя другим потокам выполнять вычисления в то время, как один поток блокируется.

+ `Событийный цикл`: Если нужно обрабатывать события, такие как клики мыши или нажатия клавиш в интерактивном приложении, то многопоточность может помочь избежать блокировки пользовательского интерфейса, позволяя обрабатывать события в отдельных потоках.

Однако необходимо помнить, что использование многопоточности также может привести к проблемам синхронизации и состояния гонки, поэтому важно тщательно продумывать и тестировать свой код, особенно если он работает в многопоточной среде.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 993. `Что может произойти если два потока будут выполнять один и тот же код в программе?`

Если два потока будут выполнять один и тот же код в программе на Java, то может произойти состояние гонки (race condition), когда оба потока пытаются изменять общую область памяти (например, одну и ту же переменную) в то же самое время, что может привести к непредсказуемому поведению программы.

Для предотвращения состояния гонки в Java можно использовать механизмы синхронизации, такие как ключевое слово synchronized, которое позволяет синхронизировать доступ к методу или блоку кода. Еще одним способом является использование объектов класса Lock и Condition.

Также можно использовать конструкцию volatile, чтобы гарантировать согласованность видимости переменной между потоками.

В целом, важно правильно проектировать многопоточные приложения, чтобы избежать состояний гонки и других проблем, связанных с многопоточностью.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 994. `Что вы знаете о главном потоке программы?`

В Java главный поток программы также называется "main thread" и создается автоматически при запуске программы. Этот поток является основным потоком исполнения, который выполняет все инструкции, находящиеся в методе main().

Все операции, которые должны выполняться в основном потоке, должны быть помещены в метод main() или его вызовы. В Java также существует возможность создания новых потоков исполнения с помощью класса Thread.

Например, можно создать новый поток и запустить его следующим образом:
```java
// Создание потока
Thread myThread = new Thread(new MyRunnable());

// Запуск потока
myThread.start();
```
Здесь MyRunnable - это класс , который реализует интерфейс Runnable и содержит код для выполнения в новом потоке.

Но следует помнить, что все UI-операции, такие как отрисовка на экране, должны выполняться в главном потоке программы. Если выполнить их в других потоках, то это может привести к нестабильности и ошибкам в работе приложения.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 995. `Какие есть способы создания и запуска потоков?`

В Java существует два способа создания thread:

+ `Создание с помощью класса Thread`: вы можете создать новый класс, который расширяет класс Thread, и переопределите метод run. Затем вы создаете экземпляр этого класса и вызываете его метод start(), который запускает новый поток. Например:
```java
public class MyThread extends Thread {
  public void run() {
    System.out.println("Hello from a thread!");
  }

  public static void main(String[] args) {
    MyThread thread = new MyThread();
    thread.start();
  }
}
```
+ `Реализация интерфейса Runnable`: вы можете создать класс, который реализует интерфейс Runnable, который имеет единственный метод run(). Вы создаете экземпляр класса, который реализует Runnable, затем создаете экземпляр класса Thread, передавая в качестве аргумента конструктора экземпляр вашего класса Runnable, и вызываете метод start() из созданного экземпляра Thread. Например:
```java
public class MyRunnable implements Runnable {
  public void run() {
    System.out.println("Hello from a thread!");
  }

  public static void main(String[] args) {
    Thread thread = new Thread(new MyRunnable());
    thread.start();
  }
}
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 996. `Какой метод запускает поток на выполнение?`

В Java метод start() используется для запуска потока на выполнение. Когда вы вызываете метод start() на экземпляре класса Thread, JVM вызывает метод run() в новом потоке. Метод run() содержит код, который должен выполняться в новом потоке.

Пример:
```java
Thread myThread = new Thread(){
    public void run(){
        System.out.println("Этот код выполняется в отдельном потоке");
    }
};

myThread.start();
```
Здесь мы создаем новый экземпляр Thread и переопределяем метод run() для выполнения нужного кода. Затем мы вызываем метод start() на этом экземпляре Thread, чтобы запустить новый поток выполнения.

На месте переопределения метода run() можно передавать также Runnable объект для выполнения.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 997. `Какой метод описывает действие потока во время выполнения?`

Метод run() описывает действие потока во время выполнения. Этот метод содержит код, который будет выполняться в отдельном потоке. Чтобы запустить поток, необходимо создать экземпляр объекта Thread с указанием реализации метода run(). Затем вызовите метод start() этого объекта, чтобы поток начал работать. Например, вот простой пример создания потока в Java:
```java
public class MyThread implements Runnable {
  public void run() {
    // Код, выполняемый в потоке
  }

  public static void main(String[] args) {
    Thread t = new Thread(new MyThread());
    t.start();
  }
}
```
В этом примере run() содержит код, который будет выполняться в потоке MyThread. Когда main() вызывает t.start(), MyThread.run() начнет выполняться в отдельном потоке.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 998. `Когда поток завершает свое выполнение?`
оток завершает свое выполнение, когда метод run() в потоке завершает свое выполнение. Когда метод run() завершает свое выполнение, поток переходит в состояние TERMINATED. Если вы работаете в многопоточной среде, вы можете использовать метод join() для ожидания завершения выполнения потока. Например:
```java
Thread thread = new Thread(new MyRunnable());
thread.start();
// ждем завершения выполнения потока
try {
    thread.join();
} catch (InterruptedException e) {
    // обработка исключения
}
```
Этот код запускает новый поток, ожидает его завершения и продолжает выполнение после того, как поток завершил свою работу.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 999. `Как синхронизировать метод?`

Для синхронизации методов в Java можно использовать ключевое слово synchronized. Это означает, что только один поток может выполнять этот метод в определенный момент времени. Вот пример:
```java
public class MyClass {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized void decrement() {
        count--;
    }

    public synchronized int getCount() {
        return count;
    }
}
```
В этом примере все три метода синхронизированы, поэтому только один поток может выполнить любой из них в одно время. Методы могут быть синхронизированы на уровне объекта или класса, и должны быть описаны как public synchronized. Вы также можете использовать блокировки для синхронизации кода с использованием ключевого слова synchronized.

Например, чтобы синхронизировать код, содержащийся внутри блока, можно использовать следующий синтаксис:
```java
public class MyClass {
    private int count = 0;
    private Object lock = new Object();

    public void increment() {
        synchronized (lock) {
            count++;
        }
    }

    public void decrement() {
        synchronized (lock) {
            count--;
        }
    }

    public int getCount() {
        synchronized (lock) {
            return count;
        }
    }
}
```
Здесь мы создаем объект lock, который будет использоваться для блокировки. Затем мы используем блокировку для синхронизации каждого метода.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1000. `Как принудительно остановить поток?`

Для принудительной остановки потока в Java можно использовать метод interrupt() у объекта потока(Thread). Например, чтобы прервать выполнение потока myThread, необходимо вызвать у него метод interrupt():
```java
myThread.interrupt();
```
После этого у потока будет установлен флаг прерывания(isInterrupted()), который можно использовать для принятия решений в методе run().

Вот пример:
```java
Thread myThread = new Thread(new Runnable() {
    public void run() {
        while (!Thread.currentThread().isInterrupted()) {
            // do something
        }
    }
});
myThread.start();
// ...
myThread.interrupt(); // прерывание потока
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1001. `Дайте определение понятию “поток-демон”.`

Поток-демон (daemon thread) в Java - это поток, который работает в фоновом режиме и не останавливает работу программы при завершении всех не-daemon потоков. Он может выполнять свою работу в бесконечном цикле или ждать на определенном условии (например, ожидание новых данных в очереди), и может завершиться только в случае принудительного прерывания работы всей программы.

Для того чтобы создать поток-демон, можно использовать метод setDaemon(true) на экземпляре класса Thread перед запуском потока.
```java
Thread myThread = new MyThread();
myThread.setDaemon(true);
myThread.start();
```
Обратите внимание, что поток-демон не может быть использован для выполнения критически важных операций, таких как сохранение данных. Это связано с тем, что поток-демон может быть прерван в любой момент, если все не-daemon потоки остановят свою работу.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1002. `Как создать поток-демон?`

Для создания потока-демона в Java нужно установить соответствующий флаг при создании потока при помощи метода setDaemon(true) перед запуском потока. Вот пример кода:
```java
Thread myThread = new Thread(() -> {
    // код потока
});
myThread.setDaemon(true);
myThread.start();
```
В этом коде создается новый поток с лямбда-выражением в качестве тела, устанавливается флаг демона для этого потока и запускается. После запуска этот поток будет работать в фоновом режиме и будет автоматически завершаться, когда завершится основной поток программы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1003. `Как получить текущий поток?`

Для получения текущего потока в Java можно использовать метод currentThread() класса Thread. Пример:
```java
Thread currentThread = Thread.currentThread();
```
Этот код получит текущий поток и сохранит его в переменной currentThread. Вы можете использовать методы этого объекта, такие как getName() и getId(), для получения имени и идентификатора текущего потока соответственно. Например:
```java
String threadName = currentThread.getName();
long threadId = currentThread.getId();
System.out.println("Текущий поток: " + threadName + " (ID=" + threadId + ")");
```
Этот код выведет имя и идентификатор текущего потока в консоль.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1004. `Дайте определение понятию “монитор”.`

В Java `монитор` — это механизм синхронизации, который можно использовать для обеспечения единовременного доступа к разделяемому ресурсу нескольким потокам.

В Java любой объект может быть использован в качестве монитора. Используя ключевое слово synchronized, можно ограничить доступ к критическим секциям кода только одному потоку в любой момент времени. Когда поток пытается получить доступ к методу или блоку кода, защищённым монитором, он автоматически блокируется и ждет, пока монитор освободится.

Для того, чтобы использовать монитор в Java, необходимо синхронизировать блок кода, который хочется защитить от одновременного доступа:
```java
synchronized(obj) {
  // код, который нужно защитить от доступа других потоков 
}
```
где obj - это объект монитора. Если какой-то поток уже захватил монитор obj, то другие потоки будут заблокированы при попытке захватить этот монитор.

Использование мониторов в Java позволяет предотвратить race condition, deadlock и другие проблемы, связанные с параллельным доступом к разделяемым ресурсам.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1005. `Как приостановить выполнение потока?`

Для того, чтобы приостановить выполнение потока в Java, можно использовать метод Thread.sleep(). Этот метод приостанавливает выполнение текущего потока на заданное количество миллисекунд. Вот пример его использования:
```java
try {
    Thread.sleep(1000); // Приостановить поток на 1 секунду
} catch (InterruptedException e) {
    // Обработка исключения
}
```
Также можно использовать метод wait() и notify() для передачи управления другому потоку. Вот пример использования этих методов:
```java
// Создаем объект монитора
Object monitor = new Object();

// Поток 1
Thread thread1 = new Thread(() -> {
    synchronized (monitor) {
        try {
            // Приостанавливаем выполнение потока и освобождаем монитор
            monitor.wait();
        } catch (InterruptedException e) {
            // Обработка исключения
        }
        
        // Выполняем необходимые действия после возобновления выполнения потока
    }
});

// Поток 2
Thread thread2 = new Thread(() -> {
    synchronized (monitor) {
        // Выполняем необходимые действия
        
        // Уведомляем поток 1 о том, что можно продолжить выполнение
        monitor.notify();
    }
});
```
Этот код демонстрирует, как можно передавать управление между потоками, используя методы wait() и notify(). Оба потока синхронизируются на объекте монитора, и поток 2 уведомляет поток 1 о том, что можно продолжить выполнение, вызывая метод notify(). После этого поток 1 продолжает свое выполнение и выполняет необходимые действия.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1006. `В каких состояниях может пребывать поток?`

В Java потоки могут находиться в различных состояниях, в зависимости от того, что происходит внутри потока и внешних факторов. 

Рассмотрим основные состояния потоков в Java:

+ `NEW`: поток был создан, но еще не запущен.
+ `RUNNABLE`: поток запущен и готов к выполнению, но еще не получил процессорное время.
+ `BLOCKED`: поток остановлен, поскольку ожидает освобождения локированного монитора.
+ `WAITING`: поток остановлен и ожидает события, которое может быть вызвано другим потоком.
+ `TIMED_WAITING`: поток остановлен и ожидает события, которое может быть вызвано только после таймаута.
+ `TERMINATED`: поток завершен и больше не выполняется.

Примеры перевода потока из одного состояния в другое:

+ `NEW` -> RUNNABLE: поток становится готовым к выполнению при запуске с помощью метода start().
+ `RUNNABLE` -> WAITING: поток вызывает метод wait(), чтобы ожидать события.
+ `RUNNABLE` -> TIMED_WAITING: поток вызывает метод sleep() или wait(timeout) и ожидает события с таймаутом.
+ `RUNNABLE` -> BLOCKED: поток пытается войти в секцию кода, защищенную заблокированным монитором.
+ `RUNNABLE` -> TERMINATED: поток завершает свое выполнение, когда выполняется последний оператор в методе run().




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1007. `Что является монитором при вызове нестатического и статического метода?`

В Java каждый объект имеет свой монитор, который может быть использован для синхронизации доступа к объекту из разных потоков. При вызове нестатического метода монитором будет сам объект, для которого этот метод вызван, а при вызове статического метода монитором будет класс, в котором определен этот метод. Таким образом, при вызове нестатического метода монитором будет экземпляр класса, а при вызове статического метода - класс. Для синхронизации доступа к методу можно использовать ключевое слово synchronized в объявлении метода или блоке кода. Пример:
```java
public synchronized void doSomething() {
  // код метода, который нужно синхронизировать
}
```
Также можно использовать объект монитора явно, если нужна более гибкая синхронизация. Для этого нужно получить монитор объекта с помощью ключевого слова synchronized, например:
```java
Object monitor = obj;
synchronized (monitor) {
  // блок кода, который нужно синхронизировать
}
```
Здесь obj - это объект, монитор которого будет использован для синхронизации.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1008. `Что является монитором при выполнении участка кода метода?`

В Java каждый объект имеет свой монитор, который может быть использован для синхронизации потоков при доступе к этому объекту. При выполнении участка кода метода монитором является объект, на котором вызывается метод с модификатором synchronized. Например, в следующем коде:
```java
public synchronized void doSomething() {
    // код метода
}
```
монитором будет объект, на котором вызывается метод doSomething(), т.е. this.

Также можно использовать блокировки для синхронизации:
```java
Object obj = new Object();
synchronized(obj) {
    // блок синхронизации
}
```
В этом случае монитором будет объект obj.

Нужно учитывать, что только один поток может захватить монитор объекта в определенный момент времени, и другие потоки будут ожидать освобождения монитора, чтобы получить доступ к объекту. Это гарантирует атомарность выполнения операций с объектом в многопоточной среде.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1009. `Какие методы позволяют синхронизировать выполнение потоков?`

В Java есть несколько методов, позволяющих синхронизировать выполнение потоков:

+ `synchronized блок` - позволяет выполнить блок кода только одному потоку в момент времени:
+ + `Синхронизация метода`:
```java
public synchronized void myMethod() {
  // код метода, который должен быть выполнен только одним потоком одновременно
}
```
+ + `Синхронизация блока`:
```java
synchronized(myObject) {
  // код блока, который должен быть выполнен только одним потоком одновременно
}
```
+ `wait() и notify() методы` - позволяют потокам координировать свою работу, чтобы избежать состояния гонки и других проблем с синхронизацией. Метод wait() вызывается на объекте, в который блокирующий поток хочет войти, а метод notify() вызывается на том же объекте, когда блокирующий поток должен быть разблокирован и продолжить свою работу.

+ + Метод wait() вызывается потоком, который ждет выполнения определенного условия. Он освобождает монитор объекта, который вызвал его, и приостанавливает выполнение потока, пока другой поток не вызовет метод notify() или notifyAll().

+ + Метод notify() вызывается потоком, который изменяет состояние объекта и оповещает другие потоки, которые вызвали метод wait(). Он будит только один из ожидающих потоков.

+ + Метод notifyAll() вызывается потоком, который изменяет состояние объекта и оповещает все ожидающие потоки.

+ `ReentrantLock` - позволяет потокам получать эксклюзивный доступ к критическим секциям кода, а также обеспечивает более гибкий и функциональный подход к синхронизации потоков. Включает методы lock() и unlock() для блокировки и разблокировки выполнения потоков.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1010. `Какой метод переводит поток в режим ожидания?`

Метод, который используется для перевода потока в режим ожидания в Java, называется wait(). Этот метод позволяет временно остановить выполнение потока и перевести его в ожидающее состояние, пока какое-то другое событие не произойдет. Метод wait() может быть вызван на объекте, и поток будет ожидать уведомления от другого потока, который может вызвать методы notify() или notifyAll() на том же объекте. Метод wait() также может принимать аргумент времени ожидания в миллисекундах. Если время истекло, поток продолжит выполнение. Пример использования метода wait():
```java
synchronized (obj) {
   while (condition) {
      obj.wait();
   }
   // continue with execution after notified
}
```
где obj - объект, на котором вызывается wait(), а condition - условие, которое должно выполниться, чтобы продолжить выполнение потока.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1011. `Какова функциональность методов notify и notifyAll?`

Методы notify() и notifyAll() используются в Java для управления потоками. Оба метода используются, чтобы пробудить ожидающие потоки. Разница между ними заключается в том, что метод notify() пробуждает только один из ожидающих потоков, тогда как метод notifyAll() пробуждает все ожидающие потоки.

Пример использования метода wait() и notify() для синхронизации потоков в Java:
```java
class Message {
  private String message;
  private boolean empty = true;

  public synchronized String read() {
    while(empty) {
      try {
        wait();
      } catch (InterruptedException e) {}
    }
    empty = true;
    notifyAll();
    return message;
  }

  public synchronized void write(String message) {
    while(!empty) {
      try {
        wait();
      } catch (InterruptedException e) {}
    }
    empty = false;
    this.message = message;
  }
}
```
В этом примере класс Message имеет два метода, read() и write(). Метод read() ожидает, пока не будет доступно значение сообщения, а метод write() устанавливает значение сообщения. Методы wait() и notifyAll() используются для синхронизации потоков, чтобы потоки не пытались читать сообщения, которых еще нет, или записывать сообщения, когда другой поток еще не закончил чтение текущего сообщения.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1012. `Что позволяет сделать метод join?`

`Метод join()` в Java предназначен для ожидания завершения работы потока. То есть, если вызвать метод join() на объекте потока, то программа будет ждать завершения работы этого потока перед продолжением своей работы. Это может быть полезно, например, чтобы убедиться, что поток завершил свою задачу перед тем, как продолжать работу с результатами его работы. Например:
```java
Thread t = new MyThread();
t.start(); // запускаем поток
t.join(); // ожидаем завершения работы потока
// продолжаем работу после завершения потока
```
Также стоит учитывать, что метод join() может бросить исключение InterruptedException, поэтому необходимо обрабатывать его в соответствующем блоке try-catch.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1013. `Каковы условия вызова метода wait/notify?`

`Методы wait() и notify()` в Java используются для управления выполнением потоков с помощью монитора объекта. Общие условия вызова этих методов:

+ `Методы wait() и notify()` должны вызываться внутри синхронизированного блока кода для объекта монитора.
+ `Метод wait()` является блокирующим и заставляет вызывающий поток ждать, пока другой поток не вызовет метод notify() или notifyAll() для того же самого объекта монитора.
+ `Метод notify()` разблокирует один из потоков, ожидающих того же самого объекта монитора, чтобы продолжить выполнение. Если есть несколько потоков, ожидающих, то непредсказуемо, какой из них будет разблокирован.
+ `Метод notifyAll()` разблокирует все потоки, ожидающие того же самого объекта монитора. Когда один из этих потоков получает доступ к монитору, остальные остаются заблокированными.
+ `При вызове метода wait()`, поток освобождает блокировку объекта монитора, что позволяет другим потокам использовать этот монитор.
+ `При вызове методов notify() или notifyAll()`, поток не освобождает блокировки объекта монитора.
+ `Если вызвать метод notify() или notifyAll()` до метода wait(), то сигнал будет утерян и вызванный метод останется заблокированным.

Эти методы используются для синхронизации потоков в Java, когда несколько потоков работают с общим ресурсом



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1014. `Дайте определение понятию “взаимная блокировка”.`

`Взаимная блокировка (deadlock)` в Java - это ситуация, когда две или более нити (threads) заблокированы и ждут друг друга, чтобы продолжить работу, не выполняя при этом какую-либо полезную работу. Если две нити удерживают два различных монитора, а каждая из них ждет освобождения монитора, удерживаемого другой нитью, то возникает взаимная блокировка. Решением может быть снятие блокировки одной из нитей, чтобы она могла продолжить работу и освободить ресурсы для другой нити. Для предотвращения взаимной блокировки нужно правильно использовать блокировки, не допуская ситуации, когда один поток блокирует ресурс, не отпуская его, пока не получит доступ к другому ресурсу, находящемуся в распоряжении другого потока.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1015. `Чем отличаются методы interrupt, interrupted, isInterrupted?`

+ `Метод interrupt()` прерывает выполнение потока, вызывая исключение InterruptedException. Это может возникнуть в любой точке кода, который может генерировать это исключение, такие как wait(), sleep() и join().

+ `Метод interrupted()` - это статический метод, который используется для определения состояния прерывания потока, в котором он используется. Он возвращает true, если поток был прерван, и false, если он не был прерван. Этот метод также сбрасывает флаг прерывания.

+ `Метод isInterrupted()` - это нестатический метод, который возвращает состояние прерывания потока. Он возвращает true, если поток был прерван, и false, если он не был прерван. Этот метод не сбрасывает флаг прерывания. Если его вызвать дважды подряд, то он вернет true только в том случае, если между двумя вызовами поток был прерван.

Итак, interrupt() выбрасывает исключение InterruptedException, interrupted() проверяет флаг прерывания и сбрасывает его, а isInterrupted() только проверяет флаг прерывания, не сбрасывая его.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1016. `В каком случае будет выброшено исключение InterruptedException, какие методы могут его выбросить?`

Исключение InterruptedException выбрасывается в Java в том случае, когда поток исполнения был прерван таким методом, как Thread.interrupt(), Object.wait(), Thread.sleep() или java.util.concurrent методы.

Например, если вы вызываете Thread.sleep() в потоке исполнения, который затем был прерван с помощью Thread.interrupt(), это приведет к выбросу InterruptedException.

Чтобы обработать это исключение, вы можете использовать конструкцию try-catch:
```java
try {
    // Some code that might throw InterruptedException
} catch (InterruptedException e) {
    // Handle the exception
}
```
Это позволит вам выполнить необходимые операции, когда исключение произойдет, например почистить ресурсы или выйти из потока.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1017.  `Модификаторы volatile и метод yield().`

`Ключевое слово volatile` в Java указывает, что переменная может одновременно изменяться несколькими потоками и что при доступе к ней следует использовать синхронизацию потоков. 

`Метод yield()` используется, чтобы предложить, чтобы текущий поток уступил свое процессорное время другому потоку. Это намек, хотя и не гарантия планировщику, что текущий поток готов уступить свое текущее использование процессора. Вот пример использования volatile и yield() в Java:

```java
public class Example {
    private volatile boolean flag = false;

    public void run() {
        while (!flag) {
            // do some work
            Thread.yield();
        }
        // do something else
    }

    public void stop() {
        flag = true;
    }
}

```

В этом примере переменная флага является изменчивой, поскольку она подвержена одновременным изменениям. Метод run() проверяет значение переменной флага в цикле и вызывает Thread.yield(), чтобы разрешить выполнение других потоков. Метод stop() устанавливает переменную флага в значение true, в результате чего метод run() выходит из цикла и продолжает выполнять остальной код.

Обратите внимание, что использование yield() обычно не требуется в современных Java-приложениях, поскольку планировщик потоков обычно может управлять выполнением потоков без подсказок со стороны программиста.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1018. `Пакет java.util.concurrent`

Пакет java.util.concurrent предоставляет классы, интерфейсы и другие утилиты, связанные с параллелизмом, на языке программирования Java. Он включает в себя ряд инструментов для создания и управления параллельными приложениями, такими как блокировки, семафоры, атомарные переменные, пулы потоков и многое другое.

Некоторые часто используемые классы и интерфейсы в java.util.concurrent включают:

+ `Lock`: обеспечивает более обширные операции блокировки, чем можно получить с помощью синхронизированных методов и операторов.
+ `Semaphore`: средство синхронизации, позволяющее ограниченному числу потоков одновременно обращаться к общему ресурсу. 
+ `AtomicBoolean, AtomicInteger, AtomicLong`: обеспечивают атомарный доступ к одному логическому, целочисленному или длинному значению соответственно. 
+ `CountDownLatch`: позволяет одному или нескольким потокам ожидать завершения набора операций, выполняемых в других потоках. 
+ `Executor, ThreadPoolExecutor, Executors`: предоставляют платформу для асинхронного выполнения задач с использованием пула рабочих потоков.

В целом пакет java.util.concurrent является важным пакетом Java для разработки высокопроизводительных масштабируемых параллельных приложений.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1019. `Есть некоторый метод, который исполняет операцию i++. Переменная i типа int. Предполагается, что код будет исполнятся в многопоточной среде. Следует ли синхронизировать блок?`

Для безопасного использования переменной i в многопоточной среде, необходимо синхронизировать блок кода, который увеличивает значение i. Однако, если в контексте задачи переменная i используется только в рамках одного потока, то нет необходимости в синхронизации блока.

Также стоит учитывать, что в Java тип int - это примитивный тип данных, который имеет атомарную операцию инкремента, то есть увеличение значения переменной i на 1 является неделимой операцией и не требует синхронизации в большинстве случаев.

Однако, если в задаче используется несколько операций с переменной i, которые могут быть выполнены неатомарно, то в этом случае необходимо применять синхронизацию для обеспечения безопасности операций и корректности работы приложения.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1020. `Что используется в качестве mutex, если метод объявлен static synchronized? Можно ли создавать новые экземпляры класса, пока выполняется static synchronized метод?`

В Java сам объект/класс используется как мьютекс, когда метод объявлен как статически синхронизированный. Это означает, что только один поток может одновременно выполнять метод для каждого класса. 

Что касается создания новых экземпляров класса во время выполнения статического синхронизированного метода, то это разрешено. Синхронизированная блокировка удерживается на уровне класса, а не на уровне экземпляра, поэтому во время выполнения статического синхронизированного метода может быть создано несколько экземпляров класса. Однако если в экземпляре выполняется нестатический синхронизированный метод, любая попытка выполнить статический синхронизированный метод в том же классе будет заблокирована до тех пор, пока нестатический синхронизированный метод не завершится. 

Обратите внимание, что блокировки статической синхронизации могут вызвать проблемы с производительностью, поскольку блокировка удерживается на уровне класса и потенциально может блокировать одновременный доступ нескольких потоков к другим синхронизированным методам того же класса. Поэтому важно использовать статическую синхронизацию осторожно и только тогда, когда необходимый.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1021. `Предположим в методе run возник RuntimeException, который не был пойман. Что случится с потоком? Есть ли способ узнать о том, что Exception произошел (не заключая все тело run в блок try-catch)? Есть ли способ восстановить работу потока после того как это произошло?`

Если в методе run возникает RuntimeException, который не был пойман, то поток завершится. Это может произойти, например, если в методе run будет вызван метод с ошибкой, например, вызов несуществующего метода у объекта.

Есть несколько способов узнать о том, что RuntimeException произошел, не заключая все тело run в блок try-catch. Один из таких способов - установить UncaughtExceptionHandler для потока. Например:
```java
Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        // ...
    }
});
thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        System.out.println("Exception occurred in thread " + t.getName() + ": " + e.getMessage());
    }
});
thread.start();
```
Здесь мы создали поток и установили UncaughtExceptionHandler для него. Если в потоке возникнет исключение, оно будет передано UncaughtExceptionHandler, и мы сможем обработать его.

Если поток был завершен из-за RuntimeException, то его работу восстановить не удастся. Мы можем создать новый поток и запустить его, но это будет уже новый поток, а не старый, который был завершен.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1021. `Какие стандартные инструменты Java вы бы использовали для реализации пула потоков?`

Для реализации пула потоков в Java можно использовать Executor framework. Он предоставляет высокоуровневые классы Executor, ExecutorService, ThreadPoolExecutor, ScheduledExecutorService, которые облегчают работу с потоками и позволяют запускать асинхронные задачи. Здесь приведен пример, показывающий создание пула потоков с использованием ThreadPoolExecutor:
```java
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolExample {
   public static void main(String[] args) {
      int corePoolSize = 5;
      int maxPoolSize = 10;
      long keepAliveTime = 5000;

      ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(corePoolSize);

      executor.setMaximumPoolSize(maxPoolSize);

      executor.setKeepAliveTime(keepAliveTime, TimeUnit.MILLISECONDS);

      executor.execute(new Task("Task 1"));
      executor.execute(new Task("Task 2"));
      executor.execute(new Task("Task 3"));

      executor.shutdown();
   }
}

class Task implements Runnable {
   private String name;

   public Task(String name) {
      this.name = name;
   }

   @Override
   public void run() {
      System.out.println(name + " is running. Thread id: " + Thread.currentThread().getId());
      try {
         Thread.sleep(2000);
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
   }
}
```
ThreadPoolExecutor создает пул потоков с фиксированной длиной, и все задачи, которые передаются в executor, выполняются в этих потоках. Он автоматически удаляет ненужные потоки, которые простаивают достаточно долго благодаря keepAliveTime. Количество потоков в пуле может быть настроено с помощью метода setMaximumPoolSize.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1022. `Что такое ThreadGroup и зачем он нужен?`

ThreadGroup в Java - это класс, который предоставляет удобный способ управления группами потоков в JVM. ThreadGroup используется для организации потоков в группы и позволяет управлять ими как единым целым. ThreadGroup предоставляет возможность проверять количество потоков в группе, приостанавливать и возобновлять выполнение потоков в группе и останавливать все потоки в группе одновременно.

ThreadGroup позволяет создать иерархическую структуру групп потоков. При создании новой группы потоков указывается родительская группа, которая создает связь между ними, образуя иерархическую структуру. Если поток не привязан к какой-либо группе, то он принадлежит к корневой группе, которая создается автоматически при запуске JVM.

Пример использования ThreadGroup:
```java
ThreadGroup group = new ThreadGroup("MyGroup");

Thread thread1 = new Thread(group, new MyRunnable(), "Thread 1");
Thread thread2 = new Thread(group, new MyRunnable(), "Thread 2");

// Запуск потоков
thread1.start();
thread2.start();

// Приостановка работы всех потоков в группе
group.suspend();

// Возобновление работы всех потоков в группе
group.resume();

// Завершение работы всех потоков в группе
group.interrupt();
```
Мы создаем новую группу потоков с именем "MyGroup" и запускаем два потока, каждый привязывая к этой группе. Мы можем приостановить, возобновить или прервать выполнение всех потоков в группе одновременно с помощью методов suspend(), resume(), interrupt(), соответственно.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1023. `Что такое ThreadPool и зачем он нужен?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1024. `Что такое ThreadPoolExecutor и зачем он нужен?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1025. `Что такое «атомарные типы» в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1026. `Зачем нужен класс ThreadLocal?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1027. `Что такое Executor?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1028. `Что такое ExecutorService?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1029. `Зачем нужен ScheduledExecutorService?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1030. `Расскажите о модели памяти Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1031. `Что такое «потокобезопасность»?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1032. `В чём разница между «конкуренцией» и «параллелизмом»?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1033. `Что такое «кооперативная многозадачность»? Какой тип многозадачности использует Java? Чем обусловлен этот выбор?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1034. `Что такое ordering, as-if-serial semantics, sequential consistency, visibility, atomicity, happens-before, mutual exclusion, safe publication?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1035. `Чем отличается процесс от потока?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1036. `Что такое «зелёные потоки» и есть ли они в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1037. `Каким образом можно создать поток?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1038. `Чем различаются Thread и Runnable?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1039. `В чём заключается разница между методами start() и run()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1040. `Как принудительно запустить поток?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1041. `Что такое «монитор» в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1042. `Дайте определение понятию «синхронизация».`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1043. `Какие существуют способы синхронизации в Java?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1044. `В каких состояниях может находиться поток?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1045. `Можно ли создавать новые экземпляры класса, пока выполняется static synchronized метод?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1046. `Зачем может быть нужен private мьютекс?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1047. `Как работают методы wait() и notify()/notifyAll()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1048. `В чем разница между notify() и notifyAll()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1049. `Почему методы wait() и notify() вызываются только в синхронизированном блоке?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1050. `Чем отличается работа метода wait() с параметром и без параметра?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1051. `Чем отличаются методы Thread.sleep() и Thread.yield()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1052. `Как работает метод Thread.join()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1053. `Что такое deadlock?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1054. `Что такое livelock?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1055. `Как проверить, удерживает ли поток монитор определённого ресурса?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1056. `На каком объекте происходит синхронизация при вызове static synchronized метода?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1057. `Для чего используется ключевое слово volatile, synchronized, transient, native?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1058. `В чём различия между volatile и Atomic переменными?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1059. `В чём заключаются различия между java.util.concurrent.Atomic*.compareAndSwap() и java.util.concurrent.Atomic*.weakCompareAndSwap().`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1060. `Что значит «приоритет потока»?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1061. `Что такое «потоки-демоны»?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1062. `Можно ли сделать основной поток программы демоном?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1063. `Что значит «усыпить» поток?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1064. `Чем отличаются два интерфейса Runnable и Callable?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1065. `Что такое FutureTask?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1066. `В чем заключаются различия между CyclicBarrier и CountDownLatch?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1067. `Что такое race condition?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1068. `Существует ли способ решения проблемы race condition?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1069. `Как остановить поток?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1070. `Почему не рекомендуется использовать метод Thread.stop()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1071. `Что происходит, когда в потоке выбрасывается исключение?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1072. `В чем разница между interrupted() и isInterrupted()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1073. `Что такое «пул потоков»?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1074. `Какого размера должен быть пул потоков?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1075. `Что будет, если очередь пула потоков уже заполнена, но подаётся новая задача?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1076. `В чём заключается различие между методами submit() и execute() у пула потоков?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1077. `В чем заключаются различия между cтеком (stack) и кучей (heap) с точки зрения многопоточности?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1078. `Как поделиться данными между двумя потоками?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1079. `Какой параметр запуска JVM используется для контроля размера стека потока?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1080. `Как получить дамп потока?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1081. `Что такое ThreadLocal-переменная?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1082. `Назовите различия между synchronized и ReentrantLock?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1083. `Что такое ReadWriteLock?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1084. `Что такое «блокирующий метод»?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1085. `Что такое «фреймворк Fork/Join»?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1086. `Что такое Semaphore?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1087. `Что такое double checked locking Singleton?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1088. `Как создать потокобезопасный Singleton?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1089. `Чем полезны неизменяемые объекты?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1090. `Что такое busy spin?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1091. `Перечислите принципы, которым вы следуете в многопоточном программировании?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1092. `Какое из следующих утверждений о потоках неверно?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1093. `Даны 3 потока Т1, Т2 и Т3? Как реализовать выполнение в последовательности Т1, Т2, Т3?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1094. `Напишите минимальный неблокирующий стек (всего два метода — push() и pop()).`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1095. `Напишите минимальный неблокирующий стек (всего два метода — push() и pop()) с использованием Semaphore.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1096. `Напишите минимальный неблокирующий ArrayList (всего четыре метода — add(), get(), remove(), size()). `


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1097. `Напишите потокобезопасную реализацию класса с неблокирующим методом BigInteger next(), который возвращает элементы последовательности: [1, 2, 4, 8, 16, ...].`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1098. `Напишите простейший многопоточный ограниченный буфер с использованием synchronized.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1099. `Напишите простейший многопоточный ограниченный буфер с использованием ReentrantLock.`




к оглавлению


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 9. Java 8 (перейти в раздел)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1100. `Какие нововведения, появились в Java 8 и JDK 8?`

Некоторые функции Java 8 и JDK 8:

+ `Лямбда-выражения`
+ `Функциональные интерфейсы`
+ `Stream API`
+ `Методы по умолчанию в интерфейсах`
+ `Новые методы в классе java.util.Optional`
+ `Новые методы в классе java.util.Date и java.time`
+ `Обновленный синтаксис try-with-resources`
+ `Новые методы для работы со строками в классе java.lang.String`
+ `Методы для работы с файлами в классе java.nio.file.Files`
+ `Новые методы для работы с коллекциями в классе java.util.Collection и java.util.Map`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1101. `Что такое «лямбда»? Какова структура и особенности использования лямбда-выражения?`

`Лямбда-выражения` в Java - это способ создания анонимных функций (функций без имени), которые могут использоваться для реализации функционального программирования. Лямбда-выражения представляют собой компактный способ определения функции, не требующий лишних словесных конструкций.

`Структура лямбда-выражения` в Java имеет следующий вид:
```java
(parameters) -> expression
```
Здесь параметры представляют собой список параметров функции, а expression - выражение, которое должно выполняться внутри функции.

Пример лямбда-выражения для вычисления квадрата числа:
```java
(x) -> x * x
```
Выше мы определяем анонимную функцию, которая получает на вход число x и возвращает значение x * x.

`Особенности использования лямбда-выражений в Java`:

+ `Лямбда-выражения` могут быть переданы как аргументы методов или использованы в качестве значений переменных функционального типа.
+ `Лямбда-выражения` не могут быть использованы самостоятельно, они всегда привязаны к функциональному интерфейсу.
+ `Функциональный интерфейс` определяет тип параметра лямбда-выражения и тип его результата.
+ `Лямбда-выражения` могут использовать переменные, определенные вне тела выражения. Эти переменные должны быть объявлены как final или effectively final.

Пример использования лямбда-выражений в Java:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
numbers.stream().map(x -> x * x).forEach(System.out::println);
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1102. `К каким переменным есть доступ у лямбда-выражений?`

В лямбда-выражениях в Java можно обращаться к локальным переменным, объявленным во внешнем блоке. Однако такие переменные должны быть объявлены как final или effectively final. Это значит, что значение переменной не может быть изменено после присвоения.

Например, следующий код корректен, потому что переменная i объявлена как final:
```java
final int i = 42;
Runnable r = () -> System.out.println("The answer is " + i);
```
А вот следующий код выдаст ошибку компиляции, потому что переменная i не объявлена как final:
```java
int i = 42;
Runnable r = () -> System.out.println("The answer is " + i);
i = 43; // ошибка компиляции
```
Также в лямбда-выражении можно ссылаться на static переменные класса, как и на методы этого класса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1103. `Как отсортировать список строк с помощью лямбда-выражения?`

Чтобы отсортировать список строк с помощью лямбда-выражения в Java, вы можете использовать метод sort() из класса List вместе с лямбда-выражением, которое задает порядок сортировки. Вот пример:
```java
List<String> myList = new ArrayList<String>();
myList.add("b");
myList.add("a");
myList.add("c");

myList.sort((s1, s2) -> s1.compareTo(s2));

System.out.println(myList); //[a, b, c]
```
В этом примере sort() метод вызывается для списка строк myList, а лямбда-выражение (s1, s2) -> s1.compareTo(s2) определяет порядок сортировки. Оно сравнивает две строки s1 и s2 и возвращает результат сравнения в соответствии с методом compareTo() из интерфейса Comparable.

Обратите внимание, что при сортировке строк метод compareTo() сравнивает строки в лексикографическом порядке (т. е. в алфавитном порядке). Если вы хотите сортировать строки по другому критерию, вы можете изменить лямбда-выражение.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1104. `Что такое «ссылка на метод»?`

`"Ссылка на метод" (method reference)` - это компактное выражение в языке Java, которое позволяет использовать существующий метод в качестве значения функции. Вместо использования лямбда-выражения для определения функции, можно передать ссылку на уже существующий метод, который будет использоваться в качестве функции. Это позволяет писать более лаконичный и читаемый код.


Ссылка на метод может быть создана с помощью оператора двойного двоеточия (::). Например, `System.out::println`- ссылка на статический метод println класса System.out.

Существуют три вида ссылок на методы:

+ `Ссылка на статический метод (ClassName::methodName)`.
+ `Ссылка на метод определенный в объекте (object::methodName)`.
+ `Ссылка на конструктор (ClassName::new)`.

Например, вместо того, чтобы писать лямбда-выражение для вывода строки в консоль, можно использовать ссылку на метод println класса System.out:
```java
list.forEach(System.out::println);
```
Это эквивалентно следующему лямбда-выражению:
```java
list.forEach(s -> System.out.println(s));
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1105. `Какие виды ссылок на методы вы знаете?`

В Java существуют несколько типов ссылок на методы:

+ `Ссылки на статические методы`: ContainingClass::staticMethodName
+ `Ссылки на методы экземпляра`: containingObject::instanceMethodName
+ `Ссылки на конструкторы`: ClassName::new
+ `Ссылки на методы с одним параметром, который совместим с функциональным интерфейсом`: TypeName::methodName

Например, вот как можно использовать ссылку на методы с помощью лямбда-выражения:
```java
Function<String, Integer> strLength = String::length;
int len = strLength.apply("Hello World");   // len = 11
```
В этом примере, метод String::length используется для получения длины строки, и ссылка на метод передается функциональному интерфейсу Function<String, Integer>, который принимает строку и возвращает целое число.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1106. `Объясните выражение System.out::println.`

Выражение System.out::println в Java относится к ссылке на метод. В частности, это относится к методу println объекта out класса System.

Метод println используется для вывода сообщения на консоль и добавления в конце символа новой строки. Объект System.out является экземпляром класса PrintStream и предоставляет удобные методы для записи данных на консоль. 

Когда вы используете выражение ссылки на метод System.out::println, вы, по сути, создаете ссылку на метод println, которую затем можно передать как аргумент метода или сохранить в переменной. Хотя это может выглядеть как лямбда-выражение, это не совсем то же самое. Вот пример того, как использовать ссылку на этот метод в лямбда-выражении для печати значений массива:
```java
String[] names = {"Alice", "Bob", "Charlie"};
Arrays.stream(names).forEach(System.out::println);

```
Это выведет:

```java 
Alice
Bob
Charlie
```
Метод forEach интерфейса Stream принимает лямбда-выражение, которое принимает элемент потока в качестве входных данных. В этом случае ссылка на метод System.out::println используется для вывода каждого элемента массива имен на консоль.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1107. `Что такое «функциональные интерфейсы»?`

`"Функциональные интерфейсы"` в Java - это интерфейсы, которые содержат только один абстрактный метод. Они предназначены для использования с лямбда-выражениями (lambda expressions) и методами ссылок (method references) в Java 8 и выше.

Java предоставляет несколько встроенных функциональных интерфейсов в пакете java.util.function, таких как Predicate, Consumer, Function, Supplier и другие. Каждый из этих интерфейсов представляет функцию, которую можно передать в качестве аргумента или вернуть как результат из другого метода, что делает возможным написание более конкретного кода, чем это было раньше.

Например, `Predicate` представляет функцию, которая принимает один аргумент и возвращает значение типа boolean. 

`Интерфейс Function` представляет функцию, которая принимает один аргумент и возвращает значение другого типа. `Consumer` представляет функцию, которая принимает один аргумент и ничего не возвращает, а Supplier представляет функцию, которая ничего не принимает и возвращает значение.

Использование функциональных интерфейсов вместе с лямбда-выражениями позволяет более эффективно и просто передавать функции в другие методы и создавать новые функции внутри других методов.

Пример использования интерфейса Function:
```java
import java.util.function.Function;

public class Example {
  public static void main(String[] args) {
    Function<Integer, Integer> square = x -> x * x;
    System.out.println(square.apply(5)); // выводит на экран 25
  }
}
```
Этот код создает новую функцию square, которая принимает целое число и возвращает его квадрат. Затем мы вызываем эту функцию и передаем ей число.

Еще примеры:

```java
Predicate<String> isLong = s -> s.length() > 10;
boolean result = isLong.test("This is a very long string");
System.out.println(result); // Output: true

Consumer<String> printUpperCase = s -> System.out.println(s.toUpperCase());
printUpperCase.accept("hello"); // Output: HELLO

Supplier<Double> randomDouble = () -> Math.random();
double value = randomDouble.get();
System.out.println(value); // Output: a random double value between 0.0 and 1.0


```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1108. `Для чего нужны функциональные интерфейсы Function<T,R>, DoubleFunction<R>, IntFunction<R> и LongFunction<R>?`

`Функциональные интерфейсы Function<T,R>, DoubleFunction<R>, IntFunction<R> и LongFunction<R>` предназначены для работы с лямбда-выражениями и представляют функции, которые принимают один или несколько аргументов и возвращают результат.

+ `Function<T,R>` принимает один аргумент типа T и возвращает результат типа R. Он может использоваться для преобразования объектов одного типа в объекты другого типа.
+ `DoubleFunction<R>` принимает один аргумент типа double и возвращает результат типа R.
+ `IntFunction<R>` принимает один аргумент типа int и возвращает результат типа R.
+ `LongFunction<R>` принимает один аргумент типа long и возвращает результат типа R.

Эти интерфейсы могут использоваться вместе с лямбда-выражениями для определения различных функций, например для преобразования данных, обработки числовых значений и т.д.

Пример использования Function<T,R> в лямбда-выражении:
```java
Function<Integer, Integer> multiplyByTwo = x -> x * 2;
int result = multiplyByTwo.apply(5); // результат: 10
```

Пример использования IntFunction<R> в лямбда-выражении:
```java
IntFunction<String> intToString = x -> Integer.toString(x);
String result = intToString.apply(5); // результат: "5"
```
Пример использования DoubleFunction<R> в лямбда-выражении:
```java
DoubleFunction<Integer> roundUp = x -> (int) Math.ceil(x);
int result = roundUp.apply(4.2); // результат: 5
```
Пример использования LongFunction<R> в лямбда-выражении:
```java
LongFunction<String> longToString = x -> Long.toString(x);
String result = longToString.apply(5000000000L); // результат: "5000000000"
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1109. `Для чего нужны функциональные интерфейсы UnaryOperator<T>, DoubleUnaryOperator, IntUnaryOperator и LongUnaryOperator?`

Функциональные интерфейсы UnaryOperator<T>, DoubleUnaryOperator, IntUnaryOperator и LongUnaryOperator в Java представляют функции, которые принимают один аргумент и возвращают результат того же типа, что и аргумент (за исключением DoubleUnaryOperator, который может возвращать результат другого числового типа). Они являются частью пакета java.util.function, который был представлен в Java 8 для поддержки функционального программирования.

UnaryOperator<T> принимает один аргумент типа T и возвращает значение того же типа. DoubleUnaryOperator, IntUnaryOperator и LongUnaryOperator работают аналогично, но принимают аргументы типов double, int и long соответственно.

Пример использования UnaryOperator:
```java
UnaryOperator<String> upperCase = str -> str.toUpperCase();
System.out.println(upperCase.apply("hello"));
```
Этот код создает объект UnaryOperator, который берет строку и преобразует ее в верхний регистр. Затем он вызывает метод apply() этого объекта на строке "hello", что приводит к выводу строки "HELLO".

Таким образом, эти функциональные интерфейсы позволяют передавать функции как параметры в методы, а также использовать их для создания лямбда-выражений и ссылок на методы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1110. `Для чего нужны функциональные интерфейсы BinaryOperator<T>, DoubleBinaryOperator, IntBinaryOperator и LongBinaryOperator?`

В Java функциональные интерфейсы BinaryOperator<T>, DoubleBinaryOperator, IntBinaryOperator и LongBinaryOperator используются для задания операций, принимающих два аргумента одного типа и возвращающих значение того же типа. BinaryOperator<T> применяется к обобщенному типу T, а DoubleBinaryOperator, IntBinaryOperator и LongBinaryOperator - к примитивным числовым типам double, int и long соответственно.

+ Пример использования BinaryOperator<T>:
```java
BinaryOperator<Integer> add = (x, y) -> x + y;
int result = add.apply(2, 3); // result будет равен 5
```
+ Пример использования DoubleBinaryOperator:
```java
DoubleBinaryOperator average = (x, y) -> (x + y) / 2.0;
double result = average.applyAsDouble(5.0, 7.0); // result будет равен 6.0
```
+ Пример использования IntBinaryOperator:
```java
IntBinaryOperator max = (x, y) -> x > y ? x : y;
int result = max.applyAsInt(4, 6); // result будет равен 6
```
+ Пример использования LongBinaryOperator:
```java
LongBinaryOperator multiply = (x, y) -> x * y;
long result = multiply.applyAsLong(3L, 5L); // result будет равен 15L
```
Такие функциональные интерфейсы могут быть использованы для более удобной реализации применения различных операций к элементам коллекции и для более гибкой работой с лямбда-выражениями.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1111. `Для чего нужны функциональные интерфейсы Predicate<T>, DoublePredicate, IntPredicate и LongPredicate?`

Java функциональные интерфейсы Predicate<T>, DoublePredicate, IntPredicate и LongPredicate используются для проверки условий на соответствие определенному типу данных.

Predicate<T> используется для определения условия, которое может быть применено к объекту типа T, возвращается булево значение true/false. DoublePredicate, IntPredicate и LongPredicate используются для определения условия, которое может быть применено соответственно к типам double, int и long.

+ Пример использования Predicate<T>:
```java
Predicate<String> startsWithA = (s) -> s.startsWith("A");
boolean result = startsWithA.test("Apple");
// result равен true
```
+ Пример использования IntPredicate:
```java
IntPredicate isEven = (n) -> n % 2 == 0;
boolean result = isEven.test(4);
// result равен true
```
Такие интерфейсы могут использоваться в различных операциях фильтрации, сортировки, поиске и т.д. в коллекциях.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1112. `Для чего нужны функциональные интерфейсы Consumer<T>, DoubleConsumer, IntConsumer и LongConsumer?`

Функциональные интерфейсы Consumer<T>, DoubleConsumer, IntConsumer и LongConsumer используются в Java 8 и выше для представления функций, которые принимают один или несколько аргументов и не возвращают значения (т.е. представляют "потребление" данных). Эти интерфейсы могут использоваться в простых выражениях лямбда или методов ссылки для передачи функциональных параметров, не требующих явного определения функций.

Consumer<T> используется для представления операции, которая принимает один аргумент типа T, и не возвращает результат. Например, вы можете использовать Consumer<T> для вывода списка элементов:
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.forEach(name -> System.out.println(name)); // используется Consumer<T> в качестве своего функционального параметра
```
DoubleConsumer, IntConsumer и LongConsumer представляют аналогичные операции для числовых значений с плавающей точкой, целочисленных (int) и длинных целых (long) значений соответственно. Эти функциональные интерфейсы обеспечивают более эффективную обработку примитивных переменных, чем использование Consumer<T>.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1113. `Для чего нужны функциональные интерфейсы Supplier<T>, BooleanSupplier, DoubleSupplier, IntSupplier и LongSupplier?`


В Java функциональные интерфейсы Supplier<T>, BooleanSupplier, DoubleSupplier, IntSupplier и LongSupplier используются для представления функций, которые не принимают аргументы и возвращают значения определенных типов.

+ `Supplier<T>` - функциональный интерфейс, который описывает метод get(), который принимает ноль аргументов и возвращает значение типа T. Он может использоваться в качестве поставщика значений для других функций.
+ `BooleanSupplier` - функциональный интерфейс, который описывает метод getAsBoolean(), который принимает ноль аргументов и возвращает значение типа boolean. Он может использоваться, когда нужно предоставить поставщика логических значений.
+ `DoubleSupplier` - функциональный интерфейс, который описывает метод getAsDouble(), который принимает ноль аргументов и возвращает значение типа double. Он может использоваться, когда нужно предоставить поставщика значений double.
+ `IntSupplier` - функциональный интерфейс, который описывает метод getAsInt(), который принимает ноль аргументов и возвращает значение типа int. Он может использоваться, когда нужно предоставить поставщика значений int.
+ `LongSupplier` - функциональный интерфейс, который описывает метод getAsLong(), который принимает ноль аргументов и возвращает значение типа long. Он может использоваться, когда нужно предоставить поставщика значений long.

Эти функциональные интерфейсы делают код более читабельным, позволяют избежать дублирования кода и улучшают производительность. Они также могут использоваться для передачи функций в качестве параметров в другие методы, что делает код более гибким и расширяемым.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1114. `Для чего нужен функциональный интерфейс BiConsumer<T,U>?`

В Java 8 и более поздних версиях, функциональный интерфейс BiConsumer<T,U> определяет метод accept с двумя аргументами, без возвращаемого значения, что позволяет передавать функцию, которая принимает два аргумента и выполняет какие-то действия. Это полезно, когда необходимо передать функцию для выполнения операций на парах значений.

Например, если у Вас есть коллекция, и вы хотите пройти через каждый элемент, для выполнения некоторых операций над множеством значений с помощью forEach(), можно использовать BiConsumer для выполнения операций над элементами коллекции.

Вот пример использования BiConsumer:
```java
List<String> names = Arrays.asList("Alex", "Bob", "Charlie");
BiConsumer<Integer, String> biConsumer = (index, name) -> System.out.println(index + "-" + name);
IntStream.range(0, names.size()).forEach(i -> biConsumer.accept(i, names.get(i)));
```
Этот пример выведет:
```
0-Alex
1-Bob
2-Charlie
```

где BiConsumer используется для построения значения пары, содержащего индекс элемента списка и сам элемент, а затем передается в метод forEach() для обработки.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1114. `Для чего нужен функциональный интерфейс BiFunction<T,U,R>?`

Функциональный интерфейс BiFunction<T, U, R> в Java определяет функцию, которая принимает два аргумента типов T и U и возвращает результат типа R. Этот интерфейс может использоваться для передачи функции в качестве аргумента в метод, который ожидает функцию, или как тип результата, возвращаемого из метода, который возвращает функцию. Например, можно использовать BiFunction для объединения двух коллекций в одну, где результатом является коллекция, содержащая все элементы первой и второй коллекций.

Вот пример использования BiFunction для объединения двух списков строк:
```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.BiFunction;

public class Main {
    public static void main(String[] args) {
        List<String> list1 = Arrays.asList("a", "b", "c");
        List<String> list2 = Arrays.asList("d", "e", "f");

        BiFunction<List<String>, List<String>, List<String>> mergeLists = (l1, l2) -> {
            List<String> result = new ArrayList<>(l1);
            result.addAll(l2);
            return result;
        };

        List<String> mergedList = mergeLists.apply(list1, list2);
        System.out.println(mergedList);
    }
}
```
Этот код объединяет два списка строк и выводит результат: [a, b, c, d, e, f].



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1115. `Для чего нужен функциональный интерфейс BiPredicate<T,U>?`

Функциональный интерфейс BiPredicate<T, U> в Java используется для определения метода, который принимает два аргумента типа T и U и возвращает значение типа boolean. Он широко используется для тестирования условий, которые зависят от двух значений.

Как и другие функциональные интерфейсы в Java 8, BiPredicate<T, U> можно использовать для создания лямбда-выражений. Например, приведенный ниже код использует BiPredicate для сравнения двух строк:
```java
BiPredicate<String,String> equals = (s1, s2) -> s1.equals(s2);
if(equals.test("hello","hello")){
    System.out.println("Strings are equal");
}

```
Этот код создает лямбда-выражение, которое сравнивает две строки и возвращает true, если они совпадают. Затем этот BiPredicate используется для проверки, равны ли две строки, и выводится сообщение "Strings are equal".



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1116. `Для чего нужны функциональные интерфейсы вида _To_Function?`

Функциональные интерфейсы вида _To_Function в Java представляют собой интерфейсы, которые определяют функции, которые принимают в качестве аргумента объект типа T и возвращают объект типа R. Эти интерфейсы используются в лямбда-выражениях и могут быть использованы везде, где требуется функция с заданным типом. В частности, они полезны для реализации стримовых операций, таких как отображение, фильтрация или свертка, а также для обобщения кода, улучшения его читаемости и сокращения объема кода при работе с функциями высшего порядка. Например, интерфейс DoubleToIntFunction определяет функцию, которая преобразует значение типа double в значение типа int.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1117. `Для чего нужны функциональные интерфейсы ToDoubleBiFunction<T,U>, ToIntBiFunction<T,U> и ToLongBiFunction<T,U>?`

Данные функциональные интерфейсы из пакета java.util.function используются для описания функций, которые принимают два аргумента определенных типов и возвращают результаты определенного типа.

+ `ToDoubleBiFunction<T,U>` - функция, которая принимает два аргумента типа T и U и возвращает результат типа double.

+ `ToIntBiFunction<T,U>` - функция, которая принимает два аргумента типа T и U и возвращает результат типа int.

+ `ToLongBiFunction<T,U>`- функция, которая принимает два аргумента типа T и U и возвращает результат типа long.

Эти интерфейсы могут использоваться для представления функций, которые принимают два аргумента, например, для агрегации данных или преобразования пары значений. Например, ToDoubleBiFunction может использоваться для среднего значения двух чисел типа double, ToIntBiFunction для суммирования двух чисел типа int, ToLongBiFunction для произведения двух чисел типа long. Их использование особенно удобно в лямбда-выражениях, которые можно передавать в качестве аргументов методов для обработки данных в коллекциях и потоках данных (Streams).

Классы, которые реализуют эти интерфейсы, могут использоваться для обработки данных, таких как список или массив объектов, каждый из которых имеет два свойства. Например, можно отсортировать список объектов, используя метод sorted() и передавая ему компаратор, который будет сравнивать объекты с помощью методов ToDoubleBiFunction, ToIntBiFunction или ToLongBiFunction.

Пример использования ToDoubleBiFunction<T,U>:
```java
import java.util.function.ToDoubleBiFunction;

public class Example {
    public static void main(String[] args) {
        ToDoubleBiFunction<Integer, Integer> product = (a, b) -> a * b * 1.0;
        double result = product.applyAsDouble(2, 3);
        System.out.println(result);
    }
}
```
В этом примере создается объект ToDoubleBiFunction, который перемножает два целых числа и возвращает результат в виде дробного числа. Затем этот объект используется для вычисления произведения двух чисел (2 и 3) и результат выводится на консоль.

Аналогичным образом можно использовать ToIntBiFunction и ToLongBiFunction, чтобы выполнить операции с целочисленными и длинными целыми числами.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1118. `Для чего нужны функциональные интерфейсы ToDoubleFunction<T>, ToIntFunction<T> и ToLongFunction<T>?`

Функциональные интерфейсы ToDoubleFunction<T>, ToIntFunction<T> и ToLongFunction<T> являются частями пакета java.util.function в Java 8 и позже, и используются в лямбда-выражениях для преобразования значений типа T в значения типа double, int и long соответственно. Каждый из этих функциональных интерфейсов определяет только один метод, принимающий входное значение типа T и возвращающий преобразованное значение типа double, int или long. Например, ToDoubleFunction<T> имеет метод applyAsDouble(T t), который принимает значение типа T и возвращает преобразованное значение типа double.

Пример использования ToDoubleFunction<T>:
```java
ToDoubleFunction<Integer> square = i -> i * i * 1.0;
double result = square.applyAsDouble(5); // result = 25.0
```
Здесь лямбда-выражение i -> i * i * 1.0 принимает значение типа Integer, возвращает его квадрат, умноженный на 1.0, чтобы получить результат типа double.

Использование ToIntFunction<T> и ToLongFunction<T> аналогичны. Они часто используются при обработке больших наборов данных в функциональном стиле кодирования.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1119. `Для чего нужны функциональные интерфейсы ObjDoubleConsumer<T>, ObjIntConsumer<T> и ObjLongConsumer<T>?`

Функциональные интерфейсы ObjDoubleConsumer<T>, ObjIntConsumer<T> и ObjLongConsumer<T> в Java предназначены для передачи функций с двумя аргументами типа double, int и long соответственно. Эти интерфейсы обеспечивают типизированный доступ к методам, принимающим два аргумента.

Например, можно использовать интерфейс ObjIntConsumer<T> для передачи функции, которая принимает объект типа T и целочисленное значение, и выполняет некоторые действия над ними. Подобным образом для произвольных типов данных можно использовать ObjDoubleConsumer<T> и ObjLongConsumer<T>.

Эти функциональные интерфейсы входят в состав пакета java.util.function в Java 8 и выше. Они предоставляют средства для работы с лямбда-выражениями и методами ссылки, позволяя удобно и эффективно использовать функциональное программирование в Java.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1120. `Что такое StringJoiner?`

`StringJoiner` - это класс в Java, который был добавлен в Java 8 для создания строки, объединяя элементы с использованием разделителя и опционального префикса и суффикса.

Он имеет конструктор, который может принимать разделитель, префикс и суффикс, а также методы add() для добавления элементов в строку и toString() для получения окончательной строки.

Вот пример использования класса StringJoiner в Java:
```java
StringJoiner sj = new StringJoiner(", ", "{", "}");
sj.add("John")
  .add("Doe")
  .add("Jane");
String result = sj.toString(); // "{John, Doe, Jane}"
```
В этом примере мы создаем объект StringJoiner с разделителем ", ", префиксом "{" и суффиксом "}". Затем мы добавляем три элемента ("John", "Doe" и "Jane") с помощью метода add(), а затем используем метод toString() для получения окончательной строки.

Еще примры:
```java
StringJoiner joiner = new StringJoiner(",");
joiner.add("apple");
joiner.add("orange");
joiner.add("banana");
String joined = joiner.toString(); // "apple,orange,banana"

```

Важно отметить, что StringJoiner внутри использует StringBuilder для объединения строк, что делает его более оптимальным по скорости выполнения, чем использование конкатенации строк с помощью оператора "+".



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1120. `Что такое default методы интрефейса?`

Методы по умолчанию в интерфейсах Java были введены в Java 8 и позволяют интерфейсам предоставлять реализации для своих методов. Это означает, что интерфейсы теперь могут иметь конкретные методы в дополнение к абстрактным методам, что было невозможно до Java 8. 

С помощью методов по умолчанию вы можете добавлять новые методы в интерфейс, не нарушая существующие реализации этого интерфейса в классах, которые его реализуют. Это связано с тем, что метод по умолчанию предоставляет реализацию по умолчанию, которую при необходимости можно переопределить в классе реализации. Вот пример интерфейса с методом по умолчанию:


```java 
public interface MyInterface {
    void myMethod();
    
    default void myDefaultMethod() {
        // default implementation
    }
}

```
Классы, реализующие этот интерфейс, автоматически наследуют реализацию myDefaultMethod по умолчанию. Если они хотят предоставить альтернативную реализацию, они могут просто переопределить ее в классе. 

Методы по умолчанию особенно полезны при работе с унаследованным кодом, поскольку они позволяют добавлять новые функции в интерфейсы без необходимости изменять существующие конкретные реализации этих интерфейсов.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1121. `Как вызывать default метод интерфейса в реализующем этот интерфейс классе?`

В Java default методы интерфейса предоставляют реализацию по умолчанию, которую можно использовать в классе, который реализует этот интерфейс или переопределить, если необходимо.

Для вызова default метода интерфейса в классе необходимо использовать его объект, так как метод не является статическим. Например, если у нас есть интерфейс с default методом, как показано ниже:
```java
public interface MyInterface {
    default void myMethod() {
        System.out.println("Default method");
    }
}
```
Мы можем реализовать этот интерфейс в классе следующим образом:
```java
public class MyClass implements MyInterface {
    public void myOtherMethod() {
        // вызов default метода интерфейса
        MyInterface.super.myMethod();
    }
}
```
В этом примере мы используем ключевое слово super для вызова default метода из интерфейса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1122. `Что такое static метод интерфейса?`

В Java вы можете объявлять статические методы в интерфейсах с помощью ключевого слова static. Статические методы в интерфейсах автономны, что означает, что они не работают ни с одним экземпляром интерфейса и не привязаны к реализующему классу. Вот пример того, как объявить статический метод в интерфейсе:

```java 
public interface MyInterface {
   static void myStaticMethod() {
      System.out.println("This is a static method in an interface");
   }
}
```
Чтобы вызвать этот статический метод, вы можете просто использовать имя интерфейса:

```java
MyInterface.myStaticMethod();
```
Статические методы в интерфейсах могут быть полезны в служебных классах, где требуется метод, не привязанный к экземпляру класса, но логически связанный с классом. Кроме того, они могут помочь с организацией кода и сделать код более кратким и читабельным.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1123. `Как вызывать static метод интерфейса?`

Чтобы вызвать статический метод в интерфейсе Java, вы можете использовать имя интерфейса, за которым следует имя метода, например:

```java
public interface MyInterface {
  static void myStaticMethod() {
    System.out.println("Hello from static method!");
  }
}

class MyClass {
  public static void main(String[] args) {
    MyInterface.myStaticMethod(); // call static method
  }
}

```
В этом примере MyInterface — это имя интерфейса, а myStaticMethod() — имя статического метода, определенного в интерфейсе. Чтобы вызвать статический метод, мы используем имя интерфейса, за которым следует имя метода, разделенное точкой (.). Обратите внимание, что вам не нужен экземпляр интерфейса для вызова статического метода, так как он принадлежит самому интерфейсу.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1124. `Что такое Optional?`

`Optional` является классом в Java, который может содержать значение или отсутствовать (быть null). Это предназначено для борьбы с NullPointerException, что может произойти, когда вы пытаетесь использовать значение null. Вместо этого вы можете использовать Optional, чтобы проверить, содержит ли объект значение, и если это так, получить это значение. Например, вы можете использовать Optional для получения значения из HashMap, при условии, что ключ существует в карте. Пример использования Java Optional:
```java
Optional<String> fullName = Optional.ofNullable(null);
System.out.println("Full Name is set? " + fullName.isPresent());
System.out.println("Full Name: " + fullName.orElseGet(() -> "[none]"));   
System.out.println(fullName.map(s -> "Hey " + s + "!").orElse("Hey Stranger!"));
```
Этот пример проверяет, есть ли значение в Optional fullName, и если нет, выводит "none" с помощью orElseGet(). Затем он использует map(), чтобы добавить "Hey" к имени, если значение существует, и затем выводит приветствие.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1125. `Что такое Stream?`
В Java 8 был добавлен новый интерфейс java.util.stream.Stream, который представляет собой поток элементов с возможностью выполнения составных операций над ними. Java Stream API позволяет использовать функциональное программирование для обработки коллекций, массивов и других источников данных.

Java Stream API включает в себя множество методов для выполнения различных операций над элементами потока, таких как фильтрация, сортировка, сведение, группировка и т.д. Также API поддерживает параллельную обработку элементов потоков, что позволяет эффективно использовать многоядерные процессоры.

Пример использования Stream API для фильтрации списка строк по длине:
```java
List<String> list = Arrays.asList("apple", "orange", "banana", "pear");
List<String> filteredList = list.stream()
                                 .filter(s -> s.length() > 5)
                                 .collect(Collectors.toList());
```
В данном примере создается поток элементов из исходного списка, после чего выполняется операция фильтрации по длине строки, чтобы оставить только те элементы, которые содержат более 5 символов. Результат операции коллекционируется в новый список filteredList.

Одна из особенностей Stream API - ленивые вычисления: код, описывающий операции над потоком, не выполняется сразу, а только при вызове терминальной операции, например, метода collect(). Это позволяет минимизировать накладные расходы при выполнении операций, поскольку фактические вычисления выполняются только в тот момент, когда они действительно необходимы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1126. `Какие существуют способы создания стрима?`

Для создания Stream в Java 8 и выше есть несколько способов:

+ `Создание стрима из коллекции с помощью метода stream()`:
```java
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream = list.stream();
```
+ `Создание стрима из массива с помощью Arrays.stream()`:
```java
String[] array = { "a", "b", "c" };
Stream<String> stream = Arrays.stream(array);
```
+ `Создание пустого стрима с помощью метода Stream.empty()`:
```java
Stream<String> stream = Stream.empty();
```
+ `Создание стрима из заданных значений с помощью Stream.of()`:
```java
Stream<String> stream = Stream.of("a", "b", "c");
```
+ `Создание стрима с помощью IntStream.range() для последовательности чисел`:
```java
IntStream stream = IntStream.range(0, 10);
```
+ `Создание стрима с помощью методов Stream.generate() или Stream.iterate(), чтобы генерировать бесконечные потоки`:
```java
Stream<Integer> stream = Stream.generate(() -> 1);
Stream<Integer> stream = Stream.iterate(0, n -> n + 2);
```
+ `Из значений`: можно создать стрим из явно заданных элементов используя метод 
```java
Stream.of(value1, value2, ...)

Stream<String> stream = Stream.of("one", "two", "three");
```
+ `Из файла`: можно создать стрим из строк в файле используя метод Files.lines(Path path):
```
Stream<String> stream = Files.lines(Paths.get("file.txt"));
```
Это не полный список методов для создания Stream. В зависимости от задачи, можно выбрать подходящий метод для создания Stream.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1127. `В чем разница между Collection и Stream?`

Коллекции (Collection) и потоки (Stream) являются частями Java Collections Framework и используются для хранения и манипулирования набором элементов.

Коллекции используются для хранения элементов в памяти и предоставляют различные методы для добавления, удаления, поиска и т.д. Коллекции в Java могут быть реализованы в виде списков (List), множеств (Set) и списков ключей-значений (Map), а также других типов.

Потоки (Stream) используются для выполнения операций на элементах коллекций и других типов данных, например, на массивах. Потоки позволяют осуществлять операции над элементами в функциональном стиле, включая фильтрацию, отображение, сортировку, группировку и т.д. Каждая операция создает новый поток, который можно использовать для выполнения следующей операции.

Основное отличие между коллекциями и потоками заключается в том, что коллекции используются для хранения элементов в памяти, а потоки выполняют операции над элементами на лету.

Кроме того, потоки могут использоваться для выполнения операций параллельно, в то время как коллекции выполняют операции только последовательно.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1128.  `Для чего нужен метод collect() в стримах?`

`Метод collect()` в Stream API используется для преобразования элементов потока в какую-то коллекцию или другой объект, например, массив или строку. Метод collect() принимает в себя объект класса Collector, который описывает, как элементы потока должны быть собраны в коллекцию. Класс Collector предоставляет ряд фабричных методов, таких как toList(), toSet(), toMap() и многие другие, которые позволяют создать различные типы коллекций.

Пример использования метода collect():
```java
List<String> resultList = names.stream()
                               .filter(s -> s.startsWith("A"))
                               .collect(Collectors.toList());
```
В этом примере мы фильтруем имена, начинающиеся с буквы "A", из потока и используем метод collect() для сбора отфильтрованных элементов в новый список resultList.

Также метод collect() может использоваться для сбора элементов потока в объект другого типа. Например, вы можете использовать метод collect() для сбора элементов потока в строку, используя фабричный метод Collectors.joining():
```java
String resultString = names.stream()
                            .collect(Collectors.joining(", "));
```
В этом примере мы используем метод collect() для сбора всех строк из потока в одну строку с разделителем ", ".

Например, если нам нужно преобразовать список строк в Set строк, мы можем использовать метод collect() следующим образом:
```java
List<String> list = Arrays.asList("a", "b", "c");
Set<String> set = list.stream().collect(Collectors.toSet());
```
Метод collect() также может быть использован для агрегации элементов стрима в один объект. Например, мы можем использовать его для нахождения суммы элементов числового стрима:
```java
IntStream stream = IntStream.of(1, 2, 3, 4, 5);
int sum = stream.collect(Collectors.summingInt(i -> i));
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1129. `Для чего в стримах применяются методы forEach() и forEachOrdered()?`

Методы forEach() и forEachOrdered() применяются для выполнения некоторой операции для каждого элемента в потоке. Оба метода принимают в качестве аргумента объект типа Consumer, который представляет собой операцию, которая будет выполнена для каждого элемента потока. Однако, есть разница в том, как эти методы обрабатывают элементы потока.

`Метод forEach()` может обрабатывать элементы параллельно, что может привести к неопределенному порядку обработки элементов. То есть порядок обработки элементов может отличаться каждый раз при запуске программы. Этот метод хорошо подходит, если порядок обработки не имеет значения.

`Метод forEachOrdered()` гарантирует, что элементы будут обработаны в том порядке, в котором они находятся в потоке. Он также может быть использован в параллельных потоках, но в таком случае потеряется преимущество параллельной обработки.

Например, следующий код применяет метод forEach() к потоку списка строк, который выводит каждую строку на консоль:
```java
List<String> strings = Arrays.asList("a", "b", "c");
strings.stream().forEach(System.out::println);
```
А следующий код применяет метод forEachOrdered() к тому же потоку:
```java
List<String> strings = Arrays.asList("a", "b", "c");
strings.stream().forEachOrdered(System.out::println);
```
Оба примера должны вывести строку "a", затем "b", затем "c", но в первом примере порядок может быть случайным.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1130. `Для чего в стримах предназначены методы map() и mapToInt(), mapToDouble(), mapToLong()?`

`Методы map() и mapToInt(), mapToDouble(), mapToLong()` в Java Stream API предназначены для трансформации элементов потока в другие значения. map() позволяет применить заданную функцию к каждому элементу потока и получить новый поток с результатами этой функции. Например, можно использовать map() для преобразования списка строк в список длин этих строк.

`mapToInt(), mapToDouble() и mapToLong()` используются для выполнения той же функции, но к элементам потока применяются специализированные функции, которые возвращают значения соответствующего примитивного типа данных. Эти методы могут быть полезны, если вы хотите произвести операции, которые работают только с конкретным типом данных.

Пример использования метода map() для преобразования списка строк в список длин этих строк:
```java
List<String> myList = Arrays.asList("Java", "Stream", "API", "example");
List<Integer> result = myList.stream()
                               .map(x -> x.length())
                               .collect(Collectors.toList());
```
В результате получим список длин строк:
```
[4, 6, 3, 7]
```
Пример использования метода mapToInt() для преобразования списка чисел с плавающей точкой в список целых чисел:
```java
List<Double> myList = Arrays.asList(3.14, 2.7, 1.618, 0.0);
List<Integer> result = myList.stream()
                              .mapToInt(Double::intValue)
                              .boxed()
                              .collect(Collectors.toList());
```
В результате получим список целых чисел:
```
[3, 2, 1, 0]
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1131. `Какова цель метода filter() в стримах`

`Метод filter()` в Java Stream API используется для фильтрации элементов в стриме. Он принимает в качестве аргумента предикат, который определяет, оставлять элемент в стриме или удалить его. Предикат - это функция, которая принимает элемент стрима в качестве аргумента и возвращает булево значение, указывающее, оставлять элемент или удалить его.

Например, если у нас есть стрим целых чисел и мы хотим оставить только четные числа, мы можем использовать метод filter() следующим образом:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
Stream<Integer> stream = numbers.stream();

// Оставляем только четные числа
Stream<Integer> evenNumbersStream = stream.filter(n -> n % 2 == 0);

// Собираем результат в список
List<Integer> evenNumbersList = evenNumbersStream.collect(Collectors.toList());

System.out.println(evenNumbersList); // Выводит: [2, 4, 6]
```
Как видно из примера, метод filter() возвращает новый стрим, содержащий только элементы, для которых предикат возвращает true. Этот новый стрим можно использовать для дальнейшей обработки данных.

Например, в следующем коде мы создаем список чисел и фильтруем его, чтобы оставить только нечетные числа:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

List<Integer> oddNumbers = numbers.stream()
    .filter(n -> n % 2 != 0)
    .collect(Collectors.toList());

System.out.println(oddNumbers); //  Выводит: [1, 3, 5, 7, 9]
```
В этом примере мы используем метод stream(), чтобы получить стрим из списка чисел, затем используем метод filter() для отбора только нечетных чисел, и наконец используем метод collect() для преобразования результата обратно в список.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1132. `Для чего в стримах предназначен метод limit()?`

`Метод limit()` в Java Stream API используется для ограничения количества элементов в стриме. Он принимает целочисленный аргумент, который задает максимальное количество элементов, которые должны быть доступны в стриме. Например, если вы хотите получить только первые 10 элементов из стрима, вы можете использовать следующий код:
```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
List<Integer> limitedList = list.stream()
                                 .limit(10)
                                 .collect(Collectors.toList());
```
Здесь list - это список чисел, а limitedList - это список, содержащий только первые 10 элементов из исходного списка.

Этот метод может быть очень полезен, если вам не нужны все элементы в стриме, а только небольшое подмножество из него. Он также может увеличить производительность вашего кода, поскольку не нужно обрабатывать все элементы из стрима.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1133. `Для чего в стримах предназначен метод sorted()?`

`Метод sorted()` в потоках (streams) Java предназначен для сортировки элементов потока. Этот метод может принимать один аргумент - компаратор (comparator), который определяет порядок сортировки. Если компаратор не указан, то элементы сортируются в естественном порядке исходного типа элементов.

Например, если у нас есть поток целых чисел, мы можем отсортировать его таким образом:
```java
List<Integer> list = Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5);
list.stream()
    .sorted()
    .forEach(System.out::println);
```
Это выведет отсортированный список чисел.

Также, если у нас есть поток объектов, мы можем использовать компаратор для сортировки по нескольким полям объекта:
```java
List<Person> people = Arrays.asList(
    new Person("John", 20),
    new Person("Jane", 23),
    new Person("John", 40),
    new Person("Jane", 30)
);
people.stream()
    .sorted(Comparator.comparing(Person::getName).thenComparing(Person::getAge))
    .forEach(System.out::println);
```
Это отсортирует список людей сначала по имени, а затем по возрасту.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1134. `Для чего в стримах предназначены методы flatMap(), flatMapToInt(), flatMapToDouble(), flatMapToLong()?`

`Методы flatMap(), flatMapToInt(), flatMapToDouble(), flatMapToLong()` в Java Stream API используются для выполнения операций преобразования элементов стрима в новый стрим и объединения результатов в один выходной стрим.

В частности, метод flatMap() может быть использован для преобразования каждого элемента стрима в другой стрим, после чего результаты объединяются в единый выходной стрим. Это может быть полезно, когда у вас есть коллекция объектов, каждый из которых может содержать несколько элементов, и вы хотите обрабатывать все элементы, независимо от количества элементов в каждом объекте.

Например, предположим, что у вас есть коллекция списков чисел, и вы хотите получить новый стрим, содержащий все числа из всех списков. Вы можете сделать это, используя метод flatMap() следующим образом:
```java
List<List<Integer>> numbers = Arrays.asList(
    Arrays.asList(1, 2, 3),
    Arrays.asList(4, 5, 6),
    Arrays.asList(7, 8, 9)
);

List<Integer> allNumbers = numbers.stream()
    .flatMap(List::stream)
    .collect(Collectors.toList());

// allNumbers now contains [1, 2, 3, 4, 5, 6, 7, 8, 9]
```
Методы flatMapToInt(), flatMapToDouble(), и flatMapToLong() работают аналогично, но возвращают специализированные стримы для каждого типа данных соответственно: IntStream, DoubleStream, и LongStream.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1135.`Расскажите о параллельной обработке в Java 8.`

В Java 8 была введена возможность использовать параллельную обработку в Stream API. Это означает, что различные операции с элементами потока могут быть выполнены параллельно, что может привести к более быстрой обработке данных, особенно на больших наборах данных.

Например, чтобы обработать большой поток данных в несколько потоков, вы можете использовать метод parallelStream() вместо stream() для получения параллельного потока. Затем вы можете использовать методы, такие как map() и filter(), чтобы обработать каждый элемент потока параллельно.

Вот простой пример, показывающий, как использовать параллельную обработку в Java 8:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

long sum = numbers.parallelStream()
                .filter(n -> n % 2 == 0)
                .mapToInt(Integer::intValue)
                .sum();

System.out.println("Sum of even numbers: " + sum);
```
Этот код создает список целых чисел, а затем использует параллельный поток для фильтрации только четных чисел и подсчета их суммы.

Например, можно создать поток из списка строк и выполнить фильтрацию элементов, оставив только те строки, которые содержат определенный символ, параллельно следующим образом:
```java
List<String> strings = ...;
strings.parallelStream()
    .filter(s -> s.contains("a"))
    .forEach(System.out::println);
```
Важно заметить, что использование параллельной обработки подходит только тогда, когда операции над элементами достаточно сложные и их выполнение занимает много времени. В противном случае, использование параллельной обработки может только замедлить выполнение программы из-за дополнительных затрат на создание и управление потоками.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1136. `Какие конечные методы работы со стримами вы знаете?`

На Java 8, Stream API предоставляет много конечных методов, таких как:

+ `forEach()`: применяет заданное действие к каждому элементу стрима.
+ `count()`: возвращает количество элементов в стриме.
+ `min()`: возвращает наименьший элемент в стриме с использованием заданного компаратора, если он задан.
+ `max()`: возвращает наибольший элемент в стриме с использованием заданного компаратора, если он задан.
+ `reduce()`: выполняет последовательное сокращение стрима с помощью заданной функции.
+ `collect()`: выполняет накопление элементов стрима в некоторый контейнер или объект.
+ `findFirst()`: возвращает первый элемент в стриме.
+ `findAny()`: возвращает любой элемент в стриме, если он существует.
+ `toArray()` - возвращает массив элементов стрима;
+ `anyMatch() / allMatch() / noneMatch()` - проверяют, удовлетворяет ли хотя бы один / все / ни один из элементов стрима заданному предикату.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1137. `Какие промежуточные методы работы со стримами вы знаете?`

В Java 8 Stream API есть множество методов для промежуточной обработки данных в потоке. Некоторые из этих методов включают в себя:

+ `filter(Predicate<T> predicate)` - выбирает только те элементы потока , которые удовлетворяют предикату
+ `map(Function<T, R> mapper)` - применяет функцию к каждому элементу потока и возвращает поток, состоящий из результатов
+ `flatMap(Function<T, Stream<R>> mapper)` - применяет функцию к каждому элементу потока и получает поток из каждого результата, а затем объединяет все полученные потоки в один выходной поток
+ `distinct() `- удаляет дубликаты элементов в потоке
+ `sorted()` - сортирует элементы потока по их естественному порядку
+ `peek(Consumer<T> action)` - выполняет заданный action для каждого элемента потока, сохраняя при этом элементы в потоке
+ `skip()`: пропускает первые n элементов стрима.

Вот пример с использованием некоторых промежуточных методов:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * 2)
    .distinct()
    .collect(Collectors.toList());
```
Этот код создает список чисел, затем создает поток из списка чисел и фильтрует только четные числа, умножает их на 2, удаляет любые дубликаты и сохраняет результаты в новом списке.

Вот пример чтобы отфильтровать элементы списка list по условию, можно использовать метод filter() следующим образом:
```java
List<Integer> filteredList = list.stream()
                                 .filter(num -> num > 5)
                                 .collect(Collectors.toList());
Этот код создает стрим элементов списка list, фильтрует элементы, оставляя только те, которые больше 5, и сохраняет результат в новый список filteredList.
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1138. `Как вывести на экран 10 случайных чисел, используя forEach()?`

Чтобы сгенерировать 10 случайных чисел с помощью потоков Java и forEach(), вы можете сначала использовать класс IntStream из пакета java.util.stream для генерации потока случайных целых чисел. Затем вы можете использовать метод limit(), чтобы указать, что вам нужны только 10 случайных чисел, и, наконец, использовать forEach() для вывода каждого из случайных чисел на консоль. Вот пример фрагмента кода, который демонстрирует, как это сделать:
```java 
import java.util.Random;
import java.util.stream.IntStream;

public class RandomNumbers {
    public static void main(String[] args) {
        Random random = new Random();
        IntStream randomNumbers = random.ints().limit(10);
        randomNumbers.forEach(System.out::println);
    }
}

```
Этот код сгенерирует 10 случайных целых чисел и выведет их на консоль с помощью метода forEach(). Обратите внимание, что мы используем ссылку на метод System.out::println в качестве аргумента для метода forEach(). Это эквивалентно x -> System.out.println(x) и позволяет нам писать более лаконичный код.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1139. `Как можно вывести на экран уникальные квадраты чисел используя метод map()?`

Чтобы напечатать уникальные квадраты чисел с помощью метода map() в потоках Java, вы можете сначала использовать метод map() для получения квадратов чисел, а затем использовать метод distinct() для получения только уникальных квадратов. Вот пример фрагмента кода:

```java
List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 3, 3);

numbers.stream()
       .map(n -> n * n)
       .distinct()
       .forEach(System.out::println);

```
Этот код выведет уникальные квадраты чисел в списке чисел: 1, 4, 9. Обратите внимание, что необходимо вызвать метод distinct() для фильтрации дубликатов, чтобы получить только уникальные квадраты.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1140. `Как вывести на экран количество пустых строк с помощью метода filter()?`

Чтобы вывести количество пустых строк с помощью метода filter() в Java Stream, вы можете сделать что-то вроде этого:

```java
List<String> stringList = Arrays.asList("a", "", "b", "", "", "c");
long count = stringList.stream()
                  .filter(str -> str.isEmpty())
                  .count();
System.out.println("Number of empty strings: " + count);

```

В этом примере у меня есть список строк, и я использую метод stream() класса List для создания потока. Затем я использую метод filter() для фильтрации всех пустых строк в списке. str -> str.isEmpty() — это лямбда-выражение, которое возвращает true, если строка пуста. Метод count() возвращает количество элементов в потоке после операции фильтрации. Наконец, я вывожу счет на консоль. Этот код выведет: Количество пустых строк: 3.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1141. `Как вывести на экран 10 случайных чисел в порядке возрастания?`

Чтобы вывести 10 случайных чисел в порядке возрастания с использованием потоков Java, вы можете использовать метод sorted() после генерации чисел с использованием метода limit() и Random.ints(). Вот пример фрагмента кода:
```java
import java.util.Random;

public class Main {
  public static void main(String[] args) {
    Random random = new Random();
    random.ints(10)
      .limit(10)
      .sorted()
      .forEach(System.out::println);
  }
}


```

Этот код использует метод ints() класса Random для генерации потока случайных целых чисел, а затем применяет limit(10) для ограничения размера потока до 10 элементов и sorted() для сортировки оставшихся элементов в порядке возрастания. Наконец, forEach() используется для печати элементов.


Чтобы сгенерировать 10 случайных чисел и распечатать их в порядке убывания с помощью Java Stream API, вы можете использовать следующий код:

```java
import java.util.stream.*;
import java.util.*;

public class RandomNumbers {
    public static void main(String[] args) {
        Random random = new Random();
        IntStream.generate(random::nextInt)
                 .limit(10)
                 .boxed()
                 .sorted(Comparator.reverseOrder())
                 .forEach(System.out::println);
    }
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1142. `Как найти максимальное число в наборе?`

Для поиска максимального числа в наборе с помощью Stream API в Java 8 можно использовать метод max() с помощью оператора lambda, который сравнивает элементы. Пример:
```java
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] nums = {2, 8, 1, 6, 10};
        int maxNum = Arrays.stream(nums)
                           .max()
                           .getAsInt();
        System.out.println("Максимальное число: " + maxNum);
    }
}
```
Результат выполнения программы будет следующим:
```
Максимальное число: 10
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1143. `Как найти минимальное число в наборе?`

Для того, чтобы найти минимальное число в наборе с помощью Stream API в Java, можно использовать метод min():
```java
int[] numbers = {5, 8, 3, 12, 9};
int min = Arrays.stream(numbers).min().getAsInt();
System.out.println(min);
```
В этом примере мы создаем массив numbers, затем используем метод Arrays.stream() для создания потока чисел из массива. Метод min() возвращает минимальное значение в потоке, а метод getAsInt() преобразует результат в примитивный тип int. Метод println() выводит результат на экран.

Если элементы в потоке являются объектами, а не примитивами, то можно также использовать метод Comparator.comparing() для указания функции сравнения, по которой будет определяться порядок. Например:
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "Dave");
String shortestName = names.stream()
    .min(Comparator.comparing(String::length))
    .orElse("");
System.out.println(shortestName);
```
В этом примере мы создаем список names, затем используем метод stream() для создания потока строк из списка. Метод min() принимает функцию сравнения, которая сравнивает длину строк, а метод orElse() возвращает пустую строку в случае, если поток пустой. Метод println() выводит результат на экран.

Можно использовать также метод .reduce() чтобы получить минимальное значение в потоке. Например:
```java
int[] numbers = {5, 8, 3, 12, 9};
int min = Arrays.stream(numbers).reduce(Integer.MAX_VALUE, (a, b) -> Integer.min(a, b));
System.out.println(min);
```
В этом примере мы используем метод reduce() для свертки потока в единое значение. Метод Integer.min() используется для сравнения двух чисел и возврата минимального из них.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1144. `Как получить сумму всех чисел в наборе?`

Для получения суммы всех чисел в наборе при использовании Java Stream API можно использовать метод sum() после промежуточной операции mapToInt().

Вот пример кода:
```java
int sum = IntStream.of(1, 2, 3, 4, 5)
                   .sum();
System.out.println(sum); // Вывод: 15
```
Если количество элементов в потоке больше, то можно использовать метод reduce() вместе с оператором суммирования +, как показано ниже:
```java
int sum = IntStream.rangeClosed(1, 10)
                   .reduce(0, Integer::sum);
System.out.println(sum); // Вывод: 55
```
Здесь метод rangeClosed() создает поток целых чисел от 1 до 10 включительно, а метод reduce() выполняет операцию суммирования начиная с элемента нейтрального значения 0.

Эти же методы могут быть использованы и с другими типами данных, например, LongStream или DoubleStream, в зависимости от требований вашего кода.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1145. `Как получить среднее значение всех чисел?`

Для получения среднего значения всех чисел в Java Stream можно использовать метод average() после вызова stream() на коллекции чисел. Например:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
double average = numbers.stream()
                        .mapToDouble(val -> val) // преобразуем Integer в double
                        .average()
                        .orElse(Double.NaN);
System.out.println("Среднее значение: " + average);
```
Этот код выведет:
```
Среднее значение: 3.0
```
Обратите внимание на использование orElse(Double.NaN) после вызова average() . Это нужно для того, чтобы получить значение среднего, даже если коллекция пуста. Если коллекция пуста, метод average() вернет пустой OptionalDouble, и мы используем orElse для получения значения NaN.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1146. `Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8`

В Java 8 для работы с ассоциативными массивами (maps) был добавлен ряд дополнительных методов:
+ `forEach()` - позволяет выполнять заданное действие для каждой пары ключ-значение в мапе.
+ `replace(key, oldValue, newValue)` - заменяет значение oldValue на newValue для заданного ключа key, только если oldValue соответствует текущему значению ключа.
+ `replaceAll()` - заменяет каждое значение в мапе используя определенную функцию.
+ `compute()` - позволяет вычислить новое значение для заданного ключа, и заменить старое значением новым вычисленным значением.
+ `computeIfAbsent()` - позволяет вычислить новое значение для заданного ключа, только если заданный ключ отсутствует в мапе.
+ `computeIfPresent()` - позволяет вычислить новое значение для заданного ключа, только если заданный ключ присутствует в мапе.
+ `merge()` - выполняет объединение двух мап с определенной функцией, когда ключ встречается в двух мапах.

Пример использования методов для Map в Java 8:
```java
Map<String, Integer> map = new HashMap<>();
map.put("key1", 1);
map.put("key2", 2);

// forEach method
map.forEach((key, value) -> System.out.println(key + " " + value));

// replace method
map.replace("key1", 1, 100);

// replaceAll method
map.replaceAll((key, oldValue) -> oldValue + 10);

// compute method
map.compute("key2", (key, value) -> value * 2);

// computeIfAbsent method
map.computeIfAbsent("key3", key -> 3);

// computeIfPresent method
map.computeIfPresent("key2", (key, value) -> value * 2);
```




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1147. `Что такое LocalDateTime?`

`LocalDateTime` — это класс в пакете java.time, представленный в Java 8, который представляет дату и время без часового пояса, например 2023-05-17T09:24:13. Он сочетает в себе дату и время суток. Это наиболее часто используемый класс для представления и управления значениями даты и времени в Java.

Вот пример того, как использовать LocalDateTime для создания нового экземпляра, представляющего текущую дату и время:

```java 
import java.time.LocalDateTime;

LocalDateTime now = LocalDateTime.now();

System.out.println(now);


```
Это выведет текущую дату и время, как в примере, упомянутом ранее: 2023-05-17T09:24:13. Кроме того, вы можете использовать метод of() для создания объекта LocalDateTime, передавая значения года, месяца, дня, часа, минуты и секунды. Например:
```java
LocalDateTime dateTime = LocalDateTime.of(2023, 5, 17, 9, 30, 0);

```
Это создаст объект LocalDateTime, представляющий 17 мая 2023 года в 9:30. Имейте в виду, что LocalDateTime представляет только дату и время без часового пояса. Если вам нужно работать с часовыми поясами, вы можете использовать класс ZonedDateTime.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1148. `Что такое ZonedDateTime?`

ZonedDateTime — это класс в пакете java.time, представленный в Java 8 для представления даты и времени с часовым поясом в календарной системе ISO-8601, например «2007-12-03T10:15:30+01:00[ Европа/Париж]. 

Он представляет собой точку на временной шкале, обычно представляемую как год-месяц-день-час-минута-секунда-наносекунда, с часовым поясом. Часовой пояс имеет решающее значение для определения фактической точки на глобальной временной шкале. DateTimeKind также поддерживается для совместимости с другими системами.

Этот класс обеспечивает неизменное представление даты и времени с часовым поясом. Он похож на OffsetDateTime, но включает часовой пояс. Его можно использовать для представления определенного момента времени или для преобразования между часовыми поясами.

Вот пример того, как создать экземпляр ZonedDateTime в Java, используя текущее системное время и класс ZoneId для указания идентификатора зоны:

```java
import java.time.ZonedDateTime;
import java.time.ZoneId;

ZonedDateTime zonedDateTime = ZonedDateTime.now(ZoneId.of("Europe/Paris"));

```

Это создает ZonedDateTime, представляющий текущую дату и время в часовом поясе Европы/Парижа.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1149. `Как получить текущую дату с использованием Date Time API из Java 8?`

В Java 8 можно использовать класс java.time.LocalDateTime для получения текущей даты и времени. Метод now() этого класса возвращает текущую дату и временные значения. Например, так можно получить текущую дату и время в формате ISO:
```java
import java.time.LocalDateTime;

...

LocalDateTime currentDateTime = LocalDateTime.now();
System.out.println(currentDateTime);
```
Этот код выведет текущую дату и время в формате ISO, например: `2023-05-17T10:58:20.804`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1150. `Как добавить 1 неделю, 1 месяц, 1 год, 10 лет к текущей дате с использованием Date Time API?`

Для добавления определенного количества времени к текущей дате в Java с использованием Date Time API можно использовать методы класса LocalDate. Например, чтобы добавить 1 неделю, 1 месяц, 1 год и 10 лет, можно использовать следующий код:
```java
import java.time.LocalDate;

public class Main {
    public static void main(String[] args) {
        // Получаем текущую дату
        LocalDate currentDate = LocalDate.now();
        
        // Добавляем 1 неделю
        LocalDate nextWeek = currentDate.plusWeeks(1);
        
        // Добавляем 1 месяц
        LocalDate nextMonth = currentDate.plusMonths(1);
        
        // Добавляем 1 год
        LocalDate nextYear = currentDate.plusYears(1);
        
        // Добавляем 10 лет
        LocalDate tenYearsLater = currentDate.plusYears(10);
        
        // Выводим результат
        System.out.println("Текущая дата: " + currentDate);
        System.out.println("Дата через 1 неделю: " + nextWeek);
        System.out.println("Дата через 1 месяц: " + nextMonth);
        System.out.println("Дата через 1 год: " + nextYear);
        System.out.println("Дата через 10 лет: " + tenYearsLater);
    }
}
```
Этот код создает объекты LocalDate, представляющие текущую дату, дату через 1 неделю, 1 месяц, 1 год и 10 лет. Метод plusWeeks(), plusMonths(), plusYears() используются здесь для добавления соответствующей временной единицы к дате.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1151. `Как получить следующий вторник используя Date Time API?`

В Java 8 и более поздних версиях вы можете использовать классы java.time для работы с датами и временем. Чтобы получить следующий вторник, можно использовать метод with(TemporalAdjuster), передавая экземпляр класса TemporalAdjusters.next(DayOfWeek.TUESDAY) в качестве параметра. Вот пример кода:
```java
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.temporal.TemporalAdjusters;

public class Main {
    public static void main(String[] args) {
        LocalDate date = LocalDate.now();
        LocalDate nextTuesday = date.with(TemporalAdjusters.next(DayOfWeek.TUESDAY));
        System.out.println("Next Tuesday is: " + nextTuesday);
    }
}
```
Этот код создает объект LocalDate, который представляет сегодняшнюю дату, а затем использует метод with(TemporalAdjuster), чтобы получить следующий вторник. Затем он просто выводит эту дату на экран.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1152. `Как получить вторую субботу текущего месяца используя Date Time API?`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1153. `Как получить текущее время с точностью до миллисекунд используя Date Time API?`

В Java 8 и более поздних версиях можно использовать класс Instant и метод now() для получения текущего момента времени с точностью до миллисекунд. Вот пример:
```java
import java.time.Instant;

Instant now = Instant.now();
System.out.println(now);
```
Это выведет на экран текущий момент времени в формате ISO-8601, включая день, время и миллисекунды в формате UTC.

Если вам нужно представить время в другом формате, например, в часах, минутах и секундах, вы можете использовать класс LocalDateTime и метод now():
```java
import java.time.LocalDateTime;

LocalDateTime now = LocalDateTime.now();
System.out.println(now);
```
Это выведет на экран текущее время в формате ```2023-05-20T12:30:45.123```.

Обратите внимание, что в Java 8 и более поздних версиях классы Date и Calendar считаются устаревшими, и рекомендуется использовать новые классы из пакета java.time для работы с датами и временем.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1154. `Как получить текущее время по местному времени с точностью до миллисекунд используя Date Time API?`

В Java 8 и выше для получения текущего времени с точностью до миллисекунд рекомендуется использовать класс LocalDateTime из java.time пакета (Date Time API):
```java
import java.time.LocalDateTime;

LocalDateTime time = LocalDateTime.now();
System.out.println(time);
```
Это выведет текущее локальное время в формате по умолчанию, например: ```2023-05-18T09:16:37.124```.

Вы также можете использовать DateTimeFormatter для форматирования времени в строку с нужным форматом. Например, чтобы получить время в формате "HH:mm:ss.SSS", вы можете сделать так:
```java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

LocalDateTime time = LocalDateTime.now();
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss.SSS");
String formattedTime = time.format(formatter);
System.out.println(formattedTime);
```
Это выведет текущее время в формате `"часы:минуты:секунды.миллисекунды"`, например: `09:16:37.124`.

Обратите внимание, что для установки часового пояса используйте метод atZone или atOffset.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1155. `Как определить повторяемую аннотацию?`

Для того чтобы создать повторяемую аннотацию в Java, необходимо использовать аннотацию @Repeatable, которая в качестве параметра принимает класс-контейнер, содержащий одну или несколько аннотаций необходимого типа.

Пример объявления повторяемой аннотации:
```java
@Repeatable(MyAnnotations.class)
public @interface MyAnnotation {
    String value();
}
```
где MyAnnotations - это класс-контейнер, содержащий одну или несколько аннотаций @MyAnnotation.

Пример использования повторяемой аннотации:
```java
@MyAnnotation("value1")
@MyAnnotation("value2")
public class MyClass {
    // Код класса
}
```
где аннотации @MyAnnotation("value1") и @MyAnnotation("value2") могут быть сгруппированы в одну аннотацию-контейнер @MyAnnotations.

Для получения всех аннотаций-контейнеров необходимо использовать метод getAnnotationsByType(Class<T> annotationClass) класса Class. Например:
```java
MyAnnotation[] annotations = MyClass.class.getAnnotationsByType(MyAnnotation.class);
```
Кроме того, в Java 8 был добавлен интерфейс java.lang.annotation.Repeatable, который позволяет объявлять повторяемые аннотации без явного использования класса-контейнера. Пример использования данного интерфейса аналогичен примеру выше.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1156. `Что такое jjs?`

`jjs` — это инструмент командной строки, входящий в комплект Java Development Kit (JDK), начиная с версии 8. Он позволяет выполнять код JavaScript из командной строки с доступом к классам и методам Java. Инструмент jjs основан на движке Nashorn JavaScript. Его можно использовать для тестирования, автоматизации и других целей, требующих интеграции JavaScript и Java. С помощью jjs вы можете выполнять код JavaScript из файла или непосредственно из командной строки. Вы также можете интерактивно запускать код JavaScript с помощью оболочки jjs.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1157. `Какой класс появился в Java 8 для кодирования/декодирования данных?`

В Java 8 был добавлен класс Base64 в пакет java.util для кодирования и декодирования данных в формате Base64. Этот класс содержит два статических класса - Encoder для кодирования данных и Decoder для декодирования данных. Для использования необходимо импортировать класс Base64 использованием директивы импорта: import java.util.Base64;.

Пример кодирования и декодирования данных в Base64 в Java 8 с использованием класса Base64:
```java
import java.util.Base64;

public class Main {
    public static void main(String[] args) {
        String originalString = "Hello, world!";
        
        // Encoding a string to Base64
        String encodedString = Base64.getEncoder().encodeToString(originalString.getBytes());
        System.out.println("Encoded string: " + encodedString);
        
        // Decoding a Base64 string
        byte[] decodedBytes = Base64.getDecoder().decode(encodedString);
        String decodedString = new String(decodedBytes);
        System.out.println("Decoded string: " + decodedString);    
    }
}
```
Вывод программы:

```
Encoded string: SGVsbG8sIHdvcmxkIQ==
Decoded string: Hello, world!
```

Например, чтобы закодировать массив байтов в строку Base64, можно использовать следующий код:
```java
byte[] byteArray = {1, 2, 3};
Base64.Encoder encoder = Base64.getEncoder();
String encodedString = encoder.encodeToString(byteArray);
```
А чтобы декодировать строку Base64 обратно в массив байтов, можно использовать следующий код:
```java
Base64.Decoder decoder = Base64.getDecoder();
byte[] decodedByteArray = decoder.decode(encodedString);
```
Для этих операций также можно использовать статические методы класса java.util.Base64, например, для кодирования:
```java
byte[] byteArray = {1, 2, 3};
String encodedString = Base64.getEncoder().encodeToString(byteArray);
```
и для декодирования:
```java
byte[] decodedByteArray = Base64.getDecoder().decode(encodedString);
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1158. `Как создать Base64 кодировщик и декодировщик?`

Для создания кодировщика и декодировщика Base64 на Java, можно использовать классы Base64 и Base64.Decoder / Base64.Encoder, доступные в Java 8 и выше. Вот примеры:

+ `Кодировщик`:
```java
import java.util.Base64;

String originalInput = "hello world";
String encodedString = Base64.getEncoder().encodeToString(originalInput.getBytes());
System.out.println("Encoded string: " + encodedString);
```
Это создаст закодированную строку "hello world" в Base64.

+ `Декодировщик`:
```java
import java.util.Base64;

String encodedString = "aGVsbG8gd29ybGQ=";
byte[] decodedBytes = Base64.getDecoder().decode(encodedString);
String decodedString = new String(decodedBytes);
System.out.println("Decoded string: " + decodedString);
```
Это декодирует закодированную строку "aGVsbG8gd29ybGQ=" обратно в исходную строку "hello world".

Обратите внимание, что классы Base64 и Base64.Decoder / Base64.Encoder доступны только в Java 8 и выше.


к оглавлению


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 10. Java Core (перейти в раздел)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1159. `Чем различаются JRE, JVM и JDK?`

В языке программирования Java JRE, JVM и JDK - это различные компоненты, которые предоставляют среду выполнения, в которой работают Java-приложения.

`JRE (Java Runtime Environment)` - это среда выполнения Java , которая включает в себя Java Virtual Machine (JVM) и библиотеки классов Java. JRE нужна для запуска уже скомпилированных Java-приложений. JRE не включает в себя никаких инструментов разработки.

`JVM (Java Virtual Machine)` - это виртуальная машина , которая запускает Java-приложения, представленные в виде байт-кода. Байт-код - это машинно-независимый код, который может быть скомпилирован на любой платформе. JVM интерпретирует байт-код и выполняет Java-приложения.

`JDK (Java Development Kit)` - это комплект разработчика Java , который включает в себя JRE, компилятор Java (javac), различные инструменты разработки (например, дебаггер) и библиотеки классов Java. JDK используется, когда вы хотите разрабатывать Java-приложения.

Итак, JRE используется для запуска Java-приложений, JVM - для выполнения Java-приложений, а JDK - для разработки Java-приложений.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1160. `Какие существуют модификаторы доступа?`

В Java есть четыре модификатора доступа, которые определяют, как другие классы и модули могут получить доступ к полям и методам класса:

`public` - поля и методы, помеченные как public, могут быть доступны из любого класса или модуля.

`private` - поля и методы, помеченные как private, могут быть использованы только внутри класса, в котором они были определены.

`protected` - поля и методы, помеченные как protected, могут быть использованы внутри класса, в котором они были определены, и в подклассах этого класса.

`По умолчанию` - поля и методы, которые не помечены явным модификатором доступа, могут быть использованы только внутри того же класса и пакета, в котором они были определены.

Пример использования модификаторов доступа в Java:
```java
public class MyClass {
    public int publicField;
    private int privateField;
    protected int protectedField;
    int defaultField;
    
    public void publicMethod() {
        // Код метода
    }
    
    private void privateMethod() {
        // Код метода
    }
    
    protected void protectedMethod() {
        // Код метода
    }
    
    void defaultMethod() {
        // Код метода
    }
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1161. `О чем говорит ключевое слово final?`

Ключевое слово final в Java используется для обозначения, что значение переменной или ссылки на объект не может быть изменено после инициализации.

Если переменная объявлена с ключевым словом final, она должна быть проинициализирована при объявлении или в конструкторе объекта, и ее значение не может быть изменено. Кроме того, ключевое слово final может быть использовано для объявления констант класса.

Ключевое слово final также может использоваться для стабилизации поведения методов, так что они не могут быть переопределены в подклассах.

В целом, ключевое слово final позволяет заблокировать позицию в памяти, которую занимает переменная или константа, и гарантировать, что ее значение не изменится.

Некоторые из возможных использований ключевого слова final:

+ Декларация констант
+ Декларация локальных переменных
+ Аргументы методов
+ Декларация полей классов
+ Декларация классов

например:
```java
public class Example {
    public static final int CONSTANT_VALUE = 100;
    private final String immutableField;

    public Example(String value) {
        this.immutableField = value;
    }

    public final void finalMethod() {
        // method logic here
    }
}
```
В этом примере, CONSTANT_VALUE является константой (final static field), immutableField является изменяемым final полем (final instance field), finalMethod является final методом и не может быть переопределен в подклассах.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1162. `Какими значениями инициализируются переменные по умолчанию?`

В Java переменные класса (статические переменные) и переменные экземпляра (не статические переменные) инициализируются автоматически значениями по умолчанию, если им не присвоено явное начальное значение. Значения по умолчанию зависят от типа переменной. Вот некоторые замечания о значениях по умолчанию в Java:

+ Целочисленные типы (byte, short, int, long) инициализируются нулём (0).
+ Числа с плавающей точкой (float, double) инициализируются нулём, но это специфично для Java 8 и выше.
+ Логические типы (boolean) инициализируются значением false.
+ Ссылочные типы (Object, массивы, строки и т. д.) инициализируются значением null.

Например, такие переменные без явно заданного начального значения будут иметь значения по умолчанию:
```java
public class MyClass {
    // Переменные экземпляра
    int myInt;
    String myString;
    
    // Переменные класса
    static boolean myBoolean;

    public static void main(String[] args) {
        MyClass obj = new MyClass();
        System.out.println(obj.myInt); // Выводит 0
        System.out.println(obj.myString); // Выводит null
        System.out.println(MyClass.myBoolean); // Выводит false
    }
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1163. `Что вы знаете о функции main()?`

Функция main() является точкой входа в программу на языке Java. Это означает, что код внутри функции main() начинает выполняться при запуске программы.

Функция main() должна быть объявлена в классе, который определяет основную логику приложения. Обычно этот класс называется Main или App, например:
```java
public class Main {
    public static void main(String[] args) {
        // your code here
    }
}
```
Функция main() принимает аргументы командной строки в виде массива строк . Эти аргументы используются для передачи входных данных в программу при ее запуске. Например, чтобы передать аргументы arg1 и arg2 при запуске программы, нужно ввести следующую команду в консоли:
```java
java Main arg1 arg2
```
Функция main() возвращает тип void, то есть ничего не возвращает. Она просто выполняет код внутри себя и завершает программу.

Наличие функции main() является обязательным для запуска программы на языке Java.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1164. `Какие логические операции и операторы вы знаете?`

В Java есть несколько логических операций и операторов:

+ `&& (логическое И)` - возвращает true, если оба операнда являются true
+ `|| (логическое ИЛИ)` - возвращает true, если хотя бы один операнд является true
+ `! (логическое НЕ)` - инвертирует значение операнда (если значение true, то результат будет false, и наоборот)

Этот список не является исчерпывающим, и также могут быть использованы операторы сравнения (>, <, ==, != и т.д.) вместе с логическими операциями.

Примеры использования:
```java
boolean a = true;
boolean b = false;

System.out.println(a && b); // false

System.out.println(a || b); // true

System.out.println(!a); // false
```
Этот код выводит результаты логических операций между переменными a и b, а также результат инвертирования значения переменной a.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1165. `Что такое тернарный оператор выбора?`

Тернарный оператор выбора (Ternary Operator) в Java - это сокращенная форма записи оператора if-else. Он позволяет записывать условную операцию в одну строку, что может сделать код более читабельным и экономить место.

Синтаксис тернарного оператора выбора:
```java
variable = (condition) ? expressionTrue : expressionFalse;
```
Если condition является истиной, то expressionTrue будет возвращено, иначе expressionFalse.

Пример использования тернарного оператора выбора:
```java
int age = 20;
String message = age >= 18 ? "Взрослый" : "Ребенок";
System.out.println(message);
```
Этот код проверяет, является ли age больше или равным 18, и в зависимости от результата присваивает переменной message значение "Взрослый" или "Ребенок". Если age равен 20, то будет выведено "Взрослый".

Но следует использовать тернарный оператор выбора с умом, так как его чрезмерное использование может сделать код сложным и трудным для понимания, особенно при использовании вложенных тернарных операторов выбора.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1166. `Какие побитовые операции вы знаете?`

В Java доступны следующие побитовые операции:

+ Побитовое "и" - &
+ Побитовое "или" - |
+ Побитовое "исключающее или" - ^
+ Побитовый сдвиг вправо - >>
+ Побитовый сдвиг вправо с заполнением старших бит нулями - >>>
+ Побитовый сдвиг влево - <<
+ Побитовое отрицание - ~

Примеры использования:
```java
int a = 5; // 101 в двоичной системе
int b = 3; // 011 в двоичной системе

int c = a & b; // побитовое "и" - 001 в двоичной системе (1 в десятичной системе)
int d = a | b; // побитовое "или" - 111 в двоичной системе (7 в десятичной системе)
int e = a ^ b; // побитовое "исключающее или" - 110 в двоичной системе (6 в десятичной системе)
int f = a >> 1; // побитовый сдвиг вправо на 1 бит - 010 в двоичной системе (2 в десятичной системе)
int g = a << 2; // побитовый сдвиг влево на 2 бита - 10100 в двоичной системе (20 в десятичной системе)
int h = ~a; // побитовое отрицание - 111...111010 в двоичной системе (-6 в десятичной системе)
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1167. `Где и для чего используется модификатор abstract?`

Модификатор abstract в Java применяется для создания абстрактных классов и методов. Абстрактный класс - это класс, который не может быть создан напрямую, а должен быть унаследован другим классом, который реализует все его абстрактные методы. Абстрактный метод не имеет реализации, но обычно содержит только объявление метода, указывающее тип возвращаемого значения, имя метода и список параметров.

Использование abstract является частью концепции наследования в ООП, позволяя создавать классы с общими методами, которые могут быть дополнены и переопределены в дочерних классах. Абстрактные классы и методы также могут быть использованы для определения интерфейсов и даже применения полиморфизма.

Пример создания абстрактного класса в Java:
```java
abstract class MyAbstractClass {
   // абстрактный метод
   public abstract void myAbstractMethod();

   // обычный метод
   public void myMethod() {
      System.out.println("Это обычный метод в абстрактном классе.");
   }
}
```
Обратите внимание, что абстрактный класс содержит один абстрактный метод и один обычный метод. Дочерние классы, которые наследуются от этого класса, должны реализовать абстрактный метод.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1168. `Дайте определение понятию «интерфейс». Какие модификаторы по умолчанию имеют поля и методы интерфейсов?`

В Java интерфейс - это абстрактный тип, который содержит только абстрактные методы или константы (final static поля). Он описывает набор методов, которые должен реализовать любой класс, который реализует этот интерфейс.

Модификаторы доступа по умолчанию для полей и методов в интерфейсах - это public. Это означает, что методы и поля доступны из любого места в программе. Константы в интерфейсах являются неизменяемыми (immutable).

Пример определения интерфейса в Java:
```java
public interface MyInterface {
  // объявление константы
  int MAX_COUNT = 100;

  // объявление абстрактного метода
  void doSomething();

  // объявление метода с реализацией по умолчанию
  default void doSomethingElse() {
    // реализация метода
  }
}

```
Этот интерфейс определяет два абстрактных метода, которые должен реализовать любой класс, который реализует этот интерфейс. Методы имеют модификатор доступа public по умолчанию.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1169. `Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?`

Абстрактный класс и интерфейс - это два механизма, которые позволяют определять абстрактные типы данных и описывать методы, которые должны быть доступны в классах, реализующих эти интерфейсы или расширяющих эти абстрактные классы.


`Абстрактный класс` - это класс, который определяет хотя бы один абстрактный метод. Абстрактные методы - это методы без тела, которые должны быть переопределены в подклассах, чтобы дать им конкретную реализацию. Кроме того, абстрактный класс может иметь и конкретные методы с телом.

`Интерфейс` - это коллекция абстрактных методов, которая определяет действия (методы), которые реализующий класс обязуется поддерживать. В интерфейсах все методы по умолчанию абстрактные и не имеют тела. Кроме того, интерфейс может определять константы.

`Основное отличие между абстрактным классом и интерфейсом заключается в том, что абстрактный класс может содержать реализацию методов, а интерфейс может иметь только абстрактные методы - т.е. методы без тела. Кроме того, класс может расширять только один абстрактный класс, но он может реализовывать несколько интерфейсов.`

Когда следует использовать абстрактный класс, а когда интерфейс, зависит от конкретной ситуации. Если вы хотите определить классы с общей функциональностью, используйте абстрактный класс. Если же вам нужно определить только набор методов, которые должны быть реализованы, используйте интерфейс. Кроме того, если вам нужно добавить общую функциональность в существующие классы, лучше использовать абстрактный класс, а если вам нужно добавить новые методы, лучше использовать интерфейс.

Например, если вы хотите определить общую функциональность для всех классов, являющихся фигурами (например, периметр или площадь), то вы можете определить абстрактный класс Figure, который будет содержать реализацию некоторых методов и сигнатуры других методов, которые будут обязательны для реализации в классах,



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1170. `Почему в некоторых интерфейсах вообще не определяют методов?`

В Java есть такой концепт как "маркерный интерфейс" (marker interface). Это интерфейс, который не имеет методов. Его основное предназначение - помечать классы, чтобы это имело какой-то эффект на уровне компиляции или рантайма.

Например, маркерный интерфейс java.io.Serializable не определяет методов, он просто указывает компилятору и JVM, что класс, который его реализует, может быть сериализован (т.е. его объекты могут быть преобразованы в поток байтов и обратно), и нужно выполнить некоторые действия в рантайме, чтобы это было возможно.

Это может быть полезным для некоторых шаблонов проектирования, например, паттерн "Наблюдатель" может использовать маркерный интерфейс для определения, что классы подписчиков могут быть уведомлены об изменениях в издателе.

В целом, использование маркерных интерфейсов - это выбор дизайнера API, и они не обязательны для всех случаев. Маркерный интерфейс может быть полезен, если вам нужно указать наличие некоторого свойства или функции у класса или объекта, не давая им реальной реализации.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1171. `Почему нельзя объявить метод интерфейса с модификатором final?`

Модификатор final означает, что значение переменной не может изменяться после инициализации. В интерфейсах все поля неявно являются public, static и final. Таким образом, в интерфейсах все переменные уже являются константами и не могут изменять свои значения после инициализации.

Методы интерфейсов, с другой стороны, не могут иметь тела и не могут содержать код. Они просто определяют сигнатуру метода, который должен быть реализован в классе, который реализует интерфейс. Не имеет смысла объявлять методы интерфейса с модификатором final потому, что они не могут быть реализованы в интерфейсе и должны быть реализованы в классе, который реализует этот интерфейс.

Итак, объявление метода интерфейса как final не имеет смысла и не разрешено в Java.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1172. `Что имеет более высокий уровень абстракции - класс, абстрактный класс или интерфейс?`

Интерфейс имеет более высокий уровень абстракции, чем абстрактный класс и класс в Java. В интерфейсе нет реализации методов, только их объявления, тогда как абстрактный класс может иметь как абстрактные методы, так и методы с реализацией. Обычный класс в Java имеет полную реализацию методов и может создавать объекты, тогда как интерфейс и абстрактный класс не могут. Интерфейс также может наследовать от других интерфейсов и классов, что делает его еще более гибким в использовании.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1173. `Может ли объект получить доступ к члену класса, объявленному как private? Если да, то каким образом?`

В Java объект не имеет доступа к члену класса, объявленному как private. Только члены класса могут иметь доступ к такому приватному члену, кроме случаев, когда метод класса делает его общедоступным (public) или доступным в рамках пакета (package-private).

Однако, можно создать public метод в классе, который будет использовать приватный член класса в своей реализации, и тогда объекты этого класса будут иметь доступ к приватному члену через этот public метод. Например:
```java
public class MyClass {
  private int privateField;
  
  public void setPrivateField(int value) {
    this.privateField = value;
  }
  
  public int getPrivateField() {
    return this.privateField;
  }
}
```
В этом примере поле privateField объявлено как private, но есть два public метода setPrivateField и getPrivateField, которые работают с этим приватным полем и позволяют устанавливать и получать его значение извне.

Также следует отметить, что внутри класса можно создавать объект другого класса, у которого есть приватные поля и методы, и работать с ними. Однако доступ к таким членам класса будет закрыт при попытке вызова их извне, вне класса, где они объявлены.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1174. `Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?`

При создании экземпляра объекта в Java, конструкторы и блоки инициализации выполняются в определенном порядке, который зависит от иерархии классов и типа блока инициализации.

Порядок инициализации объекта следующий:
+ `Статические блоки инициализации базового класса`
+ `Статические блоки инициализации производного класса`
+ `Не статические блоки инициализации базового класса`
+ `Конструктор базового класса`
+ `Не статические блоки инициализации производного класса`
+ `Конструктор производного класса`

Пример иерархии классов и порядка инициализации:
```java
class Base {
    static {
        System.out.println("Static initialization block of Base");
    }

    {
        System.out.println("Instance initialization block of Base");
    }

    Base() {
        System.out.println("Constructor of Base");
    }
}

class Derived extends Base {
    static {
        System.out.println("Static initialization block of Derived");
    }

    {
        System.out.println("Instance initialization block of Derived");
    }

    Derived() {
        System.out.println("Constructor of Derived");
    }
}

public class Main {
    public static void main(String[] args) {
        new Derived();
    }
}
```
Результат выполнения кода:
```
Static initialization block of Base
Static initialization block of Derived
Instance initialization block of Base
Constructor of Base
Instance initialization block of Derived
Constructor of Derived
```
Таким образом, статические блоки инициализации выполняются первыми, затем не статические блоки инициализации, а затем конструкторы. При этом порядок выполнения блоков инициализации и конструкторов определяется иерархией классов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1175. `Зачем нужны и какие бывают блоки инициализации?`

Блоки инициализации (initialization blocks) в Java используются для инициализации переменных класса и других статических компонентов, в том числе для установки значений по умолчанию, создания экземпляров класса, вызова методов и работы с исключениями. Бывают два типа блоков инициализации: статические (static) и нестатические (instance).

`Статические блоки инициализации` выполняются при загрузке класса в JVM (Java Virtual Machine), до создания его объектов. Они используются для инициализации статических полей класса.

`Нестатические блоки инициализации` выполняются при создании объекта класса, перед выполнением конструктора. Они используются для присваивания начальных значений полей объекта, которые не могут быть установлены при объявлении поля.

Вот пример, демонстрирующий использование статических и нестатических блоков инициализации в Java:
```java
public class MyClass {
    static int staticVar;
    int instanceVar;

    static {
        // статический блок инициализации
        staticVar = 10;
        System.out.println("Static initialization block");
    }

    {
        // нестатический блок инициализации
        instanceVar = 20;
        System.out.println("Instance initialization block");
    }

    public MyClass() {
        // конструктор
        System.out.println("Constructor");
    }
}

// создание объекта класса
MyClass obj = new MyClass();
```
При выполнении этого кода будет выведено:
```
Static initialization block
Instance initialization block
Constructor
```
Это означает, что сначала был выполнен статический блок инициализации для инициализации статической переменной staticVar, затем нестатический блок инициализации для и



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1176. `К каким конструкциям Java применим модификатор static?`

Модификатор static в Java можно применять к полям (переменным класса), методам и вложенным классам. Когда static применяется к полю класса, это означает, что это поле общее для всех экземпляров этого класса, и оно существует независимо от конкретного экземпляра. Когда static применяется к методу, это означает, что метод принадлежит классу, а не экземпляру класса, и поэтому вызывается через имя класса, а не через экземпляр класса. При использовании static для вложенного класса он становится static-вложенным классом.

Например:
```java
public class MyClass {
    public static int myStaticField;
    public int myInstanceField;

    public static void myStaticMethod() {
        // ...
    }

    public void myInstanceMethod() {
        // ...
    }

    public static class MyStaticNestedClass {
        // ...
    }
}
```
Здесь мы имеем статическое поле myStaticField, статический метод myStaticMethod, нестатическое (экземплярное) поле myInstanceField, нестатический метод myInstanceMethod и статический вложенный класс MyStaticNestedClass.

Модификатор static в Java может быть применен к переменным, методам и блокам кода внутри класса, чтобы указать, что они являются статическими. Статические переменные и методы связаны с классом, а не с экземплярами класса, и могут быть вызваны без создания экземпляра.

Пример использования модификатора static в Java для переменной:
```java
public class MyClass {
    static int x = 5;
    public static void main(String[] args) {
        System.out.println(x); // output: 5
    }
}
```
Пример использования модификатора static в Java для метода:
```java
public class MyClass {
    static void myStaticMethod() {
        System.out.println("Static methods can be called without creating objects");
    }
    public static void main(String[] args) {
        myStaticMethod(); // Call the static method
    }
}
```
Пример использования модификатора static в Java для блока кода:
```java
public class MyClass {
    static {
        System.out.println("This is a static block");
    }
    public static void main(String[] args) {
        // The static block is executed when the class is loaded
    }
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1177. `Для чего в Java используются статические блоки инициализации?`


В Java статические блоки инициализации используются для выполнения каких-либо действий при загрузке класса в память. Эти блоки выполняются только один раз и до вызова любых методов класса или создания экземпляров класса. Таким образом, они могут использоваться для инициализации статических переменных или выполнения сложных вычислений при загрузке класса в память.

Вот пример использования статического блока инициализации в Java:
```java
public class Example {
  static int x;

  static {
    x = 42;
    // выполняем другие действия при загрузке класса
  }
}
```
В этом примере статический блок инициализации устанавливает значение переменной x равным 42 при загрузке класса Example в память. Это гарантирует, что переменная x будет инициализирована до использования в каких-либо методах класса Example.

Одним из преимуществ использования статических блоков инициализации является то, что они позволяют создавать классы со сложной логикой инициализации без необходимости создавать отдельный метод и вызывать его при создании экземпляра класса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1178. `Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?`


Если в блоке инициализации возникнет исключительная ситуация, то объект не будет создан, и исключение будет выброшено. Блок инициализации выполняется перед конструктором объекта, и если в нем возникнет исключительная ситуация, конструктор не будет вызван, и объект не будет создан.

Например, рассмотрим следующий код:
```java
public class MyClass {
  static {
    // Блок инициализации, в котором возникает исключение
    int a = 1 / 0; // Арифметическая ошибка: деление на ноль
  }
  
  public MyClass() {
    // Конструктор объекта
  }
}
```
В этом примере при создании объекта класса MyClass первым делом будет выполнен статический блок инициализации. Однако, в этом блоке возникает исключительная ситуация из-за деления на ноль, и конструктор объекта не будет вызван, так как объект не будет создан.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1179. `Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?`

В Java, если происходит ошибка в блоке инициализации класса (static блок), выбрасывается исключение ExceptionInInitializerError. Это исключение генерируется, когда инициализация класса невозможна, потому что произошла необработанная исключительная ситуация во время выполнения блока инициализации. Если в блоке инициализации было брошено исключение, оно будет вложено в этот ExceptionInInitializerError.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1180. `Может ли статический метод быть переопределён или перегружен?`

Статический метод не может быть переопределен, поскольку переопределение предполагает изменение метода в классе-наследнике. В Java статические методы принадлежат классу, а не объекту, поэтому методы не могут быть переопределены. Однако статический метод может быть перегружен, то есть в классе могут быть определены другие статические методы с тем же именем, но с разными параметрами. Перегрузка методов - это одна из особенностей полиморфизма в Java.

Пример перегрузки статического метода:
```java
public class Example {
    public static void print(String str) {
        System.out.println(str);
    }

    public static void print(int num) {
        System.out.println(num);
    }
}
```
В этом примере класс Example содержит два статических метода print, один для строковых значений и один для целых чисел. Оба метода имеют одно и то же имя, но разные параметры.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1181. `Могут ли нестатические методы перегрузить статические?`

Нестатические методы не могут перегрузить статические методы в Java. Это происходит потому, что статические методы принадлежат классу, а не объекту, в то время как нестатические методы принадлежат объекту. В Java перегрузка методов определяется на основе имени метода и списка его параметров. Поскольку статические методы и нестатические методы имеют разные области видимости и не могут быть вызваны с использованием одного и того же синтаксиса, они не могут быть перегружены друг другом.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1182. `Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?`

Да, в Java при переопределении метода можно сузить доступ. Это означает, что тип возвращаемого значения может быть сужен до типа, производного от типа возвращаемого значения в методе, объявленном в суперклассе.

Например, пусть у нас есть суперкласс A и подкласс B, который наследуется от A. Суперкласс A имеет метод foo(), который возвращает объект типа A. Если в подклассе B переопределить метод foo() и изменить тип возвращаемого значения на B, то это будет допустимо, так как B является производным от типа, который возвращается в суперклассе.
```java
class A {
    public A foo() {
        return new A();
    }
}

class B extends A {
    @Override
    public B foo() {
        return new B();
    }
}
```
Таким образом, в классе B, метод foo() возвращает объект типа B, который является производным от типа, возвращаемого в методе foo() класса A.

Отметим, что при этом уровень доступа не должен быть сужен (к примеру, с public на protected или private).


1183. `Возможно ли при переопределении метода изменить: модификатор доступа, возвращаемый тип, тип аргумента или их количество, имена аргументов или их порядок; убирать, добавлять, изменять порядок следования элементов секции throws?`


При переопределении метода в Java нельзя уменьшать уровень доступа, этот метод должен быть как минимум такого же уровня, что и в родительском классе. Однако вы можете увеличивать уровень доступа. Вы также можете изменять возвращаемый тип, тип аргумента и количество аргументов, но вы должны сохранить сигнатуру метода, чтобы переопределение работало правильно. Вы не можете изменять имена аргументов или их порядок. Что касается секции throws, то при переопределении вы можете добавлять новые исключения, относящиеся к секции throws, но вы не можете убирать их или изменять порядок.

Вот пример переопределения метода с изменением возвращаемого типа:
```java
class Animal {
    public void makeSound() {
        System.out.println("The animal makes a sound");
    }
}

class Dog extends Animal {
    public String makeSound() {
        return "Woof";
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        String sound = myDog.makeSound();
        System.out.println(sound); // Outputs "Woof"
    }
}
```
В этом примере метод makeSound переопределен в классе Dog, и возвращаемый тип изменен на String. Однако, важно помнить, что вызывая makeSound на объекте Animal, мы все равно получим ожидаемый результат.

1184. `Как получить доступ к переопределенным методам родительского класса?`

В Java, чтобы получить доступ к переопределенным методам родительского класса из дочернего класса, можно использовать ключевое слово "super". Вы можете использовать синтаксис "super.method()" для вызова переопределенного метода родительского класса.

Например, если у вас есть класс "Родитель" с методом "print()", который затем переопределяется в дочернем классе "Дочерний", то вы можете вызвать родительский метод "print()" из дочернего класса вот так:


```java
class Родитель {
  public void print() {
    System.out.println("Родительский метод print()");
  }
}

class Дочерний extends Родитель {
  @Override
  public void print() {
    super.print(); // вызов родительского метода print()
    System.out.println("Дочерний метод print()");
  }
}

Дочерний d = new Дочерний();
d.print();

// Output:
// Родительский метод print()
// Дочерний метод print()

```
В этом примере, когда мы вызываем метод print() у объекта класса Дочерний, переопределенный метод print() класса Дочерний вызывает родительский метод print() с помощью super.print(). Затем делает что-то свое. Как результат, оба метода выводивша строки на экран.

1185. `Можно ли объявить метод абстрактным и статическим одновременно?`

Нет, в Java нельзя объявить метод как абстрактный и статический одновременно. Модификатор abstract указывает на то, что метод должен быть реализован в подклассах, тогда как static указывает на то, что метод принадлежит классу, а не экземпляру.

Если вы попытаетесь объявить метод абстрактным и статическим, вы получите ошибку компиляции: Illegal combination of modifiers: 'abstract' and 'static'.

Заметьте , что абстрактный метод не может быть привязан к какому-либо экземпляру класса, и поэтому не может быть объявлен статическим.


1186. `В чем разница между членом экземпляра класса и статическим членом класса?`

Член экземпляра класса и статический член класса - это два разных типа членов класса в Java.

Член экземпляра класса относится к конкретному экземпляру класса. Это означает, что каждый экземпляр класса имеет свой собственный набор членов экземпляра класса. Член экземпляра класса доступен только через экземпляр класса и не может быть использован без него.

Статический член класса, напротив, относится к классу в целом, а не к конкретному экземпляру класса. Это означает, что только одна копия статического члена класса существует независимо от количества созданных экземпляров класса. Статический член класса может быть использован без создания экземпляра класса.

Использование статического члена класса может иногда приводить к проблемам с потокобезопасностью, так как статический член класса доступен для всех экземпляров класса. Однако, если вам нужно, чтобы метод или переменная принадлежали всем экземплярам класса, статические члены класса могут предоставить лучший способ реализации этого функционала.

Таким образом, разница между членом экземпляра класса и статическим членом класса заключается в том, что члены экземпляра ассоциируются с конкретными экземплярами класса и доступны только через ссылки на них, тогда как статические члены ассоциируются с классом в целом и доступны через имя класса.

1187. `Где разрешена инициализация статических/нестатических полей?`


Инициализацию как статических, так и нестатических полей в Java можно выполнять внутри конструктора, блока инициализации и при объявлении переменной.

Инициализация статических полей также может быть выполнена в блоке статической инициализации класса.

Примеры:

+ `Инициализация нестатического поля в конструкторе`:
```java
public class MyClass {
   private int myField;
   
   public MyClass(int myField) {
       this.myField = myField;
   }
}
```
+ `Инициализация статического поля в блоке статической инициализации класса`:
```java
public class MyClass {
   private static final String MY_CONSTANT;
   
   static {
       MY_CONSTANT = "Hello, world!";
   }
}
```
+ `Инициализация нестатического поля при объявлении переменной`:
```java
public class MyClass {
   private int myField = 10;
}
```
+ `Инициализация нестатического поля в блоке инициализации`:
```java
public class MyClass {
   private int myField;

   {
       myField = 10;
   }
}
```
Это лишь несколько примеров инициализации полей в Java.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1188.` Какие типы классов бывают в java?

В Java существует несколько типов классов:

+ `Обычные классы (Regular classes)` - это классы, которые не имеют никаких особых ключевых слов или модификаторов. Они просто содержат переменные и методы, и могут быть использованы для описания любой сущности в вашей программе.
+ `Абстрактные классы (Abstract classes)` - это классы, которые имеют ключевое слово abstract в своем определении. Они не могут быть использованы для создания объектов напрямую, но могут содержать абстрактные методы (методы без тела), которые должны быть реализованы в любом классе-наследнике.
+ `Интерфейсы (Interfaces)` - это классы, которые описывают только подписи методов, но не содержат саму реализацию. Они используются для определения общего контракта между классами и часто используются для создания полиморфных конструкций в программе.
+ `Финальные классы (Final classes)` - это классы, которые не могут быть наследованы. Они могут использоваться для создания безопасных или неизменяемых классов, которые не могут быть изменены в процессе выполнения программы.
+ `Вложенные классы (Nested classes)` - это классы, которые определены внутри другого класса. В Java существует четыре типа вложенных классов: статические вложенные классы (Static nested classes), нестатические вложенные классы (Inner classes), локальные классы (Local classes) и анонимные классы (Anonymous classes).
+ `Энумерация` - специальный тип класса, который используется для представления конечного списка значений.
+ `Локальный класс` - класс, который объявлен внутри метода или блока кода и имеет доступ к локальным переменным и параметрам внешнего метода или блока.
+ `Anonymous inner class (анонимный класс)`. Объявляется без имени как подкласс другого класса или реализация интерфейса.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1189. `Расскажите про вложенные классы. В каких случаях они применяются?`

В Java есть 4 типа вложенных классов: статические вложенные классы, нестатические вложенные классы (обычные inner class), анонимные классы и локальные классы.

+ `Статические вложенные классы, или статические вложения`, это классы, которые определены внутри другого класса как статические члены. Они могут быть использованы без создания объекта внешнего класса, что позволяет обернуть связанный класс в другой класс для более логического разделения кода.
+ `Нестатические вложенные классы, или обычные inner class`, это классы, которые определены внутри другого класса без ключевого слова static. Они имеют доступ к полям и методам внешнего класса и могут быть использованы только после создания объекта внешнего класса.
+ `Анонимные классы` создаются без определения имени класса и используются только для одного экземпляра. Они могут быть использованы для реализации интерфейсов или абстрактных классов, а также для простой реализации обработчиков событий.
+ `Локальные классы` определены внутри блока кода, такого как метод, и могут иметь доступ к локальным переменным этого блока.

Использование вложенных классов обычно осуществляется для логического группирование классов и контроля доступа к полям и методам внешнего класса. Они также могут быть использованы для улучшения чтения/понимания кода, ограничения области видимости и создания анонимных классов, например для реализации обработчиков событий.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1190. `Что такое «статический класс»?`

Статический класс в Java - это класс, который объявлен с модификатором static. Он может использоваться без создания экземпляра внешнего класса и имеет доступ к статическим полям и методам этого внешнего класса. Также статический класс может быть вложенным в другой класс.

Статические классы обычно используются в тех случаях, когда нужно создать утилиты или вспомогательные классы, которые не связаны напрямую с другими классами в приложении.

Пример объявления статического вложенного класса в Java:
```java
public class MainClass {
  // статический вложенный класс
  static class StaticNestedClass {
    public void printMessage() {
      System.out.println("This is a static nested class");
    }
  }

  public static void main(String[] args) {
    StaticNestedClass nestedObj = new StaticNestedClass();
    nestedObj.printMessage();
  }
}
```
Здесь StaticNestedClass - это статический вложенный класс, который может быть использован без создания экземпляра MainClass. Метод printMessage() в этом классе печатает строку на консоль. В методе main() создается объект StaticNestedClass и вызывается его метод printMessage().



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1191. `Какие существуют особенности использования вложенных классов: статических и внутренних? В чем заключается разница между ними?`


В Java существуют два типа вложенных классов: статические и внутренние.

Статические вложенные классы являются статическими членами внешнего класса и могут быть созданы без создания экземпляра внешнего класса. Они обычно используются для связывания классов, которые связаны, но не зависят от состояния экземпляров внешнего класса. Статические вложенные классы не могут использовать нестатические члены внешнего класса.

Внутренние классы – это нестатические классы, создаваемые внутри другого класса. Они могут использовать любые члены внешнего класса, включая частные, и могут обращаться к ним напрямую. Они могут быть использованы для реализации сложных структур данных или для решения проблем с областью видимости и доступом к данным.

Разница между статическими и внутренними вложенными классами в том, что статические классы не имеют доступа к нестатическим членам внешнего класса, а внутренние классы могут использовать любые члены внешнего класса. Выбор того, какой тип вложенного класса использовать, зависит от того, какой функционал требуется для данного класса.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1192. `Что такое «локальный класс»? Каковы его особенности?`

"Локальный класс" в Java - это класс, объявленный внутри метода, конструктора или блока. Он доступен только в пределах области видимости, в которой был объявлен. Локальный класс имеет доступ ко всем полям и методам внешнего класса, в том числе к закрытым и защищенным (protected). Кроме того, локальный класс может реализовывать интерфейсы и наследоваться от классов, как и обычные классы.

Особенностью локальных классов является то, что они позволяют создавать классы, специализированные для определенных задач внутри метода. Это может упростить код и улучшить его читаемость. Локальный класс также может использоваться для реализации простых интерфейсов или абстрактных классов на месте.

Вот пример объявления и использования локального класса:
```java
public class Outer {
    private int outerField = 100;

    public void someMethod() {
        int localVariable = 42;

        class LocalInner {
            public void innerMethod() {
                System.out.println("Outer field value: " + outerField);
                System.out.println("Local variable value: " + localVariable);
            }
        }

        LocalInner li = new LocalInner();
        li.innerMethod();
    }
}
```
В этом примере создается локальный класс LocalInner, который имеет доступ к полю outerField внешнего класса Outer и локальной переменной localVariable в методе someMethod(). Затем создается экземпляр LocalInner и вызывается его метод innerMethod().

Нужно учесть, что локальный класс не должен использовать локальные переменные, если они объявлены без модификатора final.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1193. `Что такое «анонимные классы»? Где они применяются?`

Иногда, в процессе написания кода, возникает потребность в создании класса, который будет использоваться только в одном месте и не будет иметь имени. Для таких случаев в языке Java есть так называемые анонимные классы.

Анонимный класс представляет собой класс, созданный без указания имени класса. Он объявляется и создается одновременно в месте, где он используется. Внешне анонимный класс выглядит как обычный класс, но без имени.

Анонимные классы обычно используются для создания объектов, которые реализуют какой-то интерфейс или унаследованы от какого-то класса. Они позволяют писать компактный и выразительный код, так как не требуют создания отдельного класса только для одного использования.

Вот пример анонимного класса, который реализует интерфейс Runnable и запускает побочный поток:
```java
new Thread(new Runnable() {
    public void run() {
        System.out.println("Running in a new thread");
    }
}).start();
```
В этом примере создается анонимный класс, который реализует интерфейс Runnable и переопределяет метод run(). Класс передается в конструктор класса Thread, который запускает побочный поток. Обратите внимание на фигурные скобки вокруг определения класса - они нужны для создания анонимного класса.

Анонимные классы также могут использоваться для создания обработчиков событий в Swing-приложениях, а также в различных фреймворках и библиотеках Java.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1194. `Каким образом из вложенного класса получить доступ к полю внешнего класса?`

Для доступа к полю внешнего класса из вложенного класса в Java используйте имя внешнего класса, за которым следует ключевое слово this и имя поля. Например, если внешний класс называется OuterClass, и вы хотите получить доступ к полю outerField, то вы можете использовать следующий код во вложенном классе:

```java
class InnerClass {
    void someMethod() {
        // получаем доступ к outerField из вложенного класса
        int fieldValue = OuterClass.this.outerField;
    }
}
```
Здесь мы используем ключевое слово this для получения экземпляра внешнего класса, а затем доступным становится его поле outerField. Обратите внимание, что OuterClass.this - это способ указать на экземпляр внешнего класса, к которому принадлежит вложенный класс.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1195. `Для чего используется оператор assert?`

Оператор assert в Java используется для проверки инвариантов в коде. Это позволяет убедиться в правильности предположений, которые сделал программист при написании кода, и помогает предотвратить ошибки во время выполнения. Оператор assert будет проверять заданное булевое выражение и, если оно равно false, выбросит исключение AssertionError.

Пример использования оператора assert:
```java
public double calculateAverage(int[] numbers) {
  assert numbers.length > 0 : "The provided array must not be empty";
  int sum = 0;
  for (int number : numbers) {
    sum += number;
  }
  return sum / (double) numbers.length;
}

```
В этом примере оператор assert проверяет, что длина массива numbers больше нуля, иначе вызывает AssertionError с сообщением "The provided array must not be empty".

Важно отметить, что по умолчанию оператор assert отключен в Java. Чтобы включить его, нужно запустить программу с флагом -ea или -enableassertions.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1196. `Что такое Heap и Stack память в Java? Какая разница между ними?`

В Java есть два основных типа памяти: stack и heap. Stack используется для хранения локальных переменных и временных параметров, которые создаются при вызове методов, а heap используется для хранения объектов и массивов.

Разница между ними заключается в том, что данные, хранящиеся на stack, удаляются автоматически после окончания работы метода, который их создал, в то время как данные, хранящиеся на heap, сохраняются до тех пор, пока на них есть ссылки. Кроме того, размер стека часто ограничен, в то время как размер heap ограничен только ресурсами, доступными в системе.

Как правило, примитивные типы данных, такие как int или boolean, хранятся на stack, а объекты и массивы хранятся на heap. Однако ссылки на объекты и массивы также могут храниться на stack.

Разница между stack и heap памятью имеет важное значение при проектировании и оптимизации Java-приложений. Важно понимать, как работать с памятью, чтобы избежать утечек памяти и обеспечить эффективную работу приложения.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1197. `Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?`

Да, верно. В Java примитивные типы данных (int, double, boolean и т.д.) всегда хранятся в стеке, а экземпляры объектов - в куче. При объявлении переменной примитивного типа в стеке выделяется место под значение самой переменной, а при создании объекта в куче выделяется место под сам объект и ссылка на него сохраняется в стеке. Другие переменные, которые ссылаются на этот объект, также содержат ссылки на этот же объект в куче.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1198. `Каким образом передаются переменные в методы, по значению или по ссылке?`

В Java переменные могут передаваться в методы как по значению (pass-by-value), так и по ссылке (pass-by-reference).

При передаче переменных примитивных типов данных (таких как int, double, boolean и т.д.) в методы, они передаются по значению, то есть копия значения переменной (без самой переменной) передается в метод. Изменения значения внутри метода не влияют на значение переменной, переданной при вызове метода.

При передаче объектов в методы, передается ссылка (адрес объекта в памяти), а не сам объект. Следовательно, при изменении объекта внутри метода, изменения будут отражены на самом объекте.

Если нужно передать копию объекта в метод, то следует создать новый объект с такими же полями и передать его в метод.

Например, если у нас есть метод, который изменяет значение поля объекта класса:
```java
public void incrementCounter(Counter c) {
    c.setValue(c.getValue() + 1);
}
```
Чтобы воспользоваться методом, мы можем создать объект Counter и вызвать метод:
```java
Counter myCounter = new Counter();
myCounter.setValue(0);
incrementCounter(myCounter);
System.out.println(myCounter.getValue()); // Выводит 1
```
Здесь при вызове метода передается ссылка на myCounter, и метод изменяет значение поля в этом объекте, отражая изменения на переменной myCounter в методе, где он был вызван.

Но если переменная является ссылкой на объект, то копия этой ссылки передается в метод, что позволяет изменять состояние объекта, на который ссылается переменная. Но сама ссылка на объект не меняется.

Вот пример передачи аргументов по значению в Java:
```java
public class Example {
    public static void main(String[] args) {
        int x = 5;
        changeValue(x);
        System.out.println(x); // Output: 5
    }

    public static void changeValue(int num) {
        num = 10;
    }
}
```
В этом примере переменная x передается методу changeValue по значению. Когда изменяется значение num, это не влияет на значение переменной x.

А вот пример передачи ссылки на объект в Java:
```java
public class Example {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder("Hello");
        changeValue(sb);
        System.out.println(sb.toString()); // Output: "Hello World"
    }

    public static void changeValue(StringBuilder str) {
        str.append(" World");
    }
}
```
В этом примере переменная sb является ссылкой на объект StringBuilder, и эта ссылка передается методу changeValue. Когда вызывается метод append для объекта str, который ссылается на тот же самый объект StringBuilder, на который ссылается sb, это изменяет состояние объекта, и значение, возвращаемое методом toString, становится "Hello World".





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1199. `Для чего нужен сборщик мусора?`

В Java сборщик мусора - это механизм автоматического освобождения памяти от объектов, которые больше не используются программой. Сборщик мусора следит за тем, какие объекты создаются в программе и удаляет те, которые больше не нужны. Это здесь для удобства программиста и чтобы избежать необходимости вручную управлять памятью для каждого объекта.

Большинство современных JVM (в том числе HotSpot JVM, которая входит в состав OpenJDK и является стандартной виртуальной машиной Java) используют сборщики мусора, которые используют алгоритмы, основанные на определенных паттернах использования памяти и не блокирующие выполнение программы для проведения сборки мусора.

Есть несколько различных типов сборщиков мусора в Java, каждый со своими преимуществами и недостатками. Некоторые из наиболее распространенных, доступных в JDK, включают следующие:

+ Serial Collector
+ Parallel Collector
+ Concurrent Mark Sweep (CMS) Collector
+ Garbage First (G1) Collector

Каждый тип сборщика мусора работает по-разному и имеет свои собственные параметры настройки, которые могут быть использованы для оптимизации производительности приложения в различных сценариях использования.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1200. `Как работает сборщик мусора?`

В Java есть сборщик мусора (garbage collector), который автоматически освобождает память, занятую объектами, которые больше не используются вашим приложением. Сборка мусора происходит периодически и зависит от того, сколько памяти используется вашим приложением.

Виртуальная машина Java (JVM) отслеживает все объекты, которые создаются в вашем приложении, и отслеживает, когда они больше не используются. Когда JVM обнаруживает, что объект больше не нужен, он помечает его как "кандидат на удаление". Затем сборщик мусора освобождает память, занятую объектом, когда он больше не нужен вашему приложению.


JVM использует различные алгоритмы сборки мусора, такие как:

+ `Алгоритм Mark-and-Sweep`, который проходится по всем объектам в памяти и отмечает те, которые ещё нужны, а затем освобождает память, занятую неотмеченными объектами.
+ `Алгоритм Copying`, который разделяет всю память на две равные части и перемещает все живые объекты из одной части памяти в другую, оставляя за собой только живые объекты в одной части памяти.
+ `Алгоритм Generational`, который разделяет память на несколько поколений и делает предположение, что большая часть объектов удаляется сразу после создания, что позволяет сократить количество объектов, которые нужно проходить при каждой сборке мусора.

Каждый алгоритм имеет свои преимущества и недостатки, и используется в зависимости от конкретных условий.






<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1201. `Какие разновидности сборщиков мусора реализованы в виртуальной машине HotSpot?`

Виртуальная машина HotSpot реализует несколько разновидностей сборщиков мусора, включая:

+ `Сборщик мусора CMS (Concurrent Mark Sweep)` - это сборщик, который выполняет сборку мусора параллельно с приложением и имеет целью максимально сократить паузы приложения, вызванные сборкой мусора.
+ `Сборщик мусора G1 (Garbage First)` - это сборщик мусора нового поколения, который предназначен для приложений с большим объемом памяти и высокой степенью параллельности. Он пытается уменьшить паузы приложения, вызванные сборкой мусора.
+ `Сборщик мусора Serial` - это сборщик мусора, который выполняет сборку мусора последовательно, поэтому он не подходит для больших приложений с высокой степенью параллельности.
+ `Сборщик мусора Parallel` - это сборщик мусора, который выполняет сборку мусора параллельно на нескольких ядрах процессора, что может увеличить производительность в определенных случаях.
+ `Z Garbage Collector` - это сборщик мусора, который поставляется с JDK 11 и предназначен для работоспособности с большим объемом памяти. Он также использует алгоритмы, которые позволяют ему уменьшить длительность пауз приложения, вызванных сборкой мусора.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1202. `Опишите алгоритм работы какого-нибудь сборщика мусора, реализованного в виртуальной машине HotSpot.`

`Сборщик мусора Serial` - это сборщик мусора, который выполняет сборку мусора последовательно, поэтому он не подходит для больших приложений с высокой степенью параллельности.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1203. `Что такое «пул строк»?

`"Пул строк" (String Pool)` в Java - это механизм оптимизации памяти, где строки, созданные в коде, хранятся в специальном "пуле" строк в памяти, чтобы можно было повторно использовать одну и ту же строку в разных частях программы, вместо создания новой каждый раз.

Когда мы создаем строку в Java через литерал (например, "hello"), JVM ищет эту строку в "пуле строк". Если строка уже находится в "пуле", JVM возвращает ссылку на существующую строку, если нет, то создает новую строку и помещает ее в "пул".

Использование "пула строк" позволяет избежать создания множества ненужных копий строк, что может привести к неэффективному использованию памяти. Однако, создание большого количества строк с помощью литералов может также привести к переполнению "пула строк" и утечкам памяти. Чтобы избежать этого, можно использовать конструкторы строк или метод intern(), чтобы явно поместить строки в "пул".



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1204. `Что такое finalize()? Зачем он нужен?`

В Java `finalize()` - это метод, который вызывается при удалении объекта из памяти. Он может быть переопределен в классе, чтобы выполнить некоторые операции по очистке памяти или освобождению ресурсов, например, закрытие открытого файла или соединения с базой данных.

Метод finalize() вызывается автоматически сборщиком мусора (Garbage Collector), который удаляет объекты, которые больше не используются в программе. Однако, не рекомендуется полагаться на finalize() для освобождения ресурсов, так как время вызова может быть неопределенным и не гарантированно.

Вместо этого лучше использовать конструкцию try-finally или блок try-with-resources для явного освобождения ресурсов после использования.

Важно помнить, что метод finalize() может быть вызван только один раз для каждого объекта, поэтому любые дополнительные операции, которые он выполняет, должны быть корректно реализованы и не должны вызывать ошибки или исключения.

Начиная с JDK 9, этот метод помечен как устаревший и может быть удален в будущем.

Пример переопределения метода finalize() в классе:
```java
class MyClass {
  // ...
  
  @Override
  protected void finalize() throws Throwable {
    try {
      // освобождение ресурсов, например, закрытие файла или соединения с базой данных
    } finally {
      super.finalize();
    }
  }
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1205. `Что произойдет со сборщиком мусора, если выполнение метода finalize() требует ощутимо много времени, или в процессе выполнения будет выброшено исключение?`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1206. `Чем отличаются final, finally и finalize()?`

`Kлючевое слово final`используется для объявления переменной, которая не может быть изменена, класса, который не может быть наследован, или метода, который не может быть переопределен.

`Ключевое слово finally` используется в блоке обработки исключений и позволяет выполнить код после блока try/catch, независимо от того, было ли исключение выброшено или нет.

`Метод finalize()` является методом, который вызывается сборщиком мусора при удалении объекта. Он позволяет определенным объектам освободить системные ресурсы или выполнить другие действия перед удалением.

Таким образом, ключевое слово final ограничивает изменяемость переменных, классов и методов, finally используется в блоке обработки исключений для выполнения кода после блока try/catch, а finalize() используется в методе объекта для выполнения определенных действий перед удалением объекта.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1207. `Расскажите про приведение типов. Что такое понижение и повышение типа?`

В Java приведение типов (type casting) означает преобразование значения переменной из одного типа в другой тип. Оно может быть понижающим и повышающим.

`Понижающее приведение (narrowing conversion)` используется, когда переменной присваивается значение, которое не может поместиться в текущий тип переменной. Например, при присваивании числа с плавающей точкой типа double целочисленной переменной типа int, происходит отбрасывание дробной части числа. Понижающее приведение может привести к потере точности или внесению ошибок в значения переменных.

Пример понижающего приведения:
```java
double d = 3.14159;
int i = (int) d; // i будет равно 3
```
`Повышающее приведение (widening conversion)` используется, когда переменной присваивается значение меньшего типа, чем ее текущий тип. Например, при присваивании целочисленного значения переменной типа с плавающей точкой, вещественная переменная будет автоматически продлена до типа double. Повышающее приведение не приводит к потере точности или ошибкам в значениях переменных.

Пример повышающего приведения:
```java
int i = 42;
double d = i; // d будет равно 42.0
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1208. `Когда в приложении может быть выброшено исключение ClassCastException`

Исключение ClassCastException может быть выброшено в Java приложении, когда происходит попытка выполнить приведение типов, которое невозможно из-за несовместимости типов. Такое исключение может быть вызвано, когда вы пытаетесь преобразовать объект в тип, который он не может принять. К примеру, если попытаться выполнить приведение типа String к типу Integer, будет выброшено исключение ClassCastException, поскольку эти типы не совместимы друг с другом.

Исключение ClassCastException может возникнуть в любой части Java приложения, но чаще всего оно возникает при работе с коллекциями, в которых хранятся объекты несовместимых типов.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1209. `Что такое литералы?`

Литералы в Java - это способ записи значений констант в исходном коде программы. Литералы могут быть использованы для представления чисел, строк, символов, логических значений и т.д.

Например, следующие строки являются примерами литералов в Java:
```java
int number = 42;       // литерал целочисленного типа
double value = 3.14;   // литерал числа с плавающей точкой
String message = "Hello, world!";  // литерал строки
char ch = 'a';         // литерал символа
boolean flag = true;   // литерал логического значения
```
Кроме того, в Java существуют специальные символы для представления особых значений, например, null для обозначения отсутствующего значения и '\n' для обозначения символа перевода строки.

Надеюсь, это поможет вам понять, что такое литералы в Java! Если у вас есть дополнительные вопросы, не стесняйтесь спрашивать.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1210. `Что такое autoboxing («автоупаковка») в Java и каковы правила упаковки примитивных типов в классы-обертки?`

Autoboxing («автоупаковка») в Java - это процесс автоматического преобразования примитивных типов данных в соответствующие классы-обертки, и наоборот, в процессе компиляции или выполнения программы.

В Java примитивные типы данных, такие как int, char, float и другие, не являются объектами, и поэтому не могут использовать методы и свойства объектов. Однако в некоторых случаях требуется использовать объекты, например, когда нужно сохранить значение примитивного типа в коллекцию или передать его в метод, который принимает только объекты.

В этом случае Java автоматически преобразует значение примитивного типа в соответствующий объект класса-обертки. Например, следующий код демонстрирует автоупаковку для типа int:
```java
Integer i = 42; // автоупаковка
int j = i; // автораспаковка
```
В первой строке переменной i автоматически присваивается объект Integer, созданный из значения 42. А во второй строке переменной j автоматически присваивается значение типа int, полученное из объекта Integer.

При этом автоупаковка и автораспаковка могут происходить как при компиляции, так и при выполнении программы, что может привести к некоторым неожиданным результатам и производительностным проблемам. Поэтому в некоторых случаях рекомендуется явно выполнять упаковку и распаковку значений, используя классы-обертки и методы преобразования типов, такие как Integer.valueOf() и Integer.parseInt().



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1211. `Какие есть особенности класса String?`

`Класс String` - это класс в Java, который представляет последовательность символов. Он имеет несколько особенностей:

`String` - это неизменяемый класс. Это означает, что после создания объекта String, его значение не может быть изменено. Если вы, например, хотите изменить строку, необходимо создать новый объект String.

Метод String intern() используется для возвращения канонического представления для строк. При вызове метода intern() для строки он всегда возвращает ссылку на строку в пуле строк. Это может быть полезно, если вам нужно сравнить две строки на равенство.

Объект String может быть создан несколькими способами, например, можно создать объект String из массива символов или из массива байтов, используя заданную кодировку.

String - это класс, который наследуется от класса Object. Он имеет множество методов, таких как length(), substring(), indexOf(), которые позволяют работать со строками.

Класс String в Java имеет несколько способов сравнения строк, включая equals(), equalsIgnoreCase(), compareTo() и compareToIgnoreCase(). Эти методы могут использоваться для сравнения строк и проверки на равенство.

Класс String в Java также предоставляет множество методов для манипулирования строками, включая методы split(), replace(), substring(), toLowerCase() и toUpperCase(). Эти методы могут использоваться для менее простых преобразований и манипуляций со строками.


Некоторые из особенностей класса String в Java включают:

+ Неизменяемость: объекты класса String не могут быть изменены после создания. Когда создается новая строка, она занимает новое место в памяти, а не изменяет существующую строку.
+ Возможность создания строк из массивов символов: Вы можете создавать строки в Java из массивов символов с помощью конструктора класса String.
+ Конкатенация строк: Вы можете объединять строки в Java с помощью оператора "+" или метода concat ().
+ Проверка на пустую строку: Вы можете проверить, содержит ли строка какой-либо текст, с помощью метода isEmpty ().
+ Поиск в строке: Вы можете искать подстроки в строке с помощью метода indexOf ().
+ Разделение строки на подстроки: Вы можете разбить строку на подстроки с помощью метода split ().
+ Форматирование строк: Вы можете форматировать строки в Java с помощью метода format ().
+ Сравнение строк: Вы можете сравнивать строки в Java с помощью операторов "==" или "equals ()".



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1212. `Почему String неизменяемый и финализированный класс?`

Строки в Java являются неизменяемыми и финализированными классами. Это означает, что после создания экземпляр строки не может быть изменен. Когда вы изменяете строку, Java создает новый экземпляр строки, вместо того, чтобы менять текущий экземпляр строки. Эта особенность обеспечивает безопасность и предотвращает необходимость создания дополнительных копий объектов строки. Также, поскольку строки финализированы, то они не могут быть расширены или подвергнуты наследованию. Эта особенность строк в Java обеспечивает безопасность, поскольку не позволяет изменять данные, когда они однажды созданы, что может привести к ошибкам и неожиданному поведению программы. Также это позволяет сократить количество неиспользуемых объектов в памяти и способствует повышению производительности при работе с большим количеством строк.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1213. `Почему char[] предпочтительнее String для хранения пароля?`

Хранение пароля в char[] в Java рекомендуется вместо хранения в String, потому что char[] можно явно очистить после использования, в то время как String остается в памяти до тех пор, пока не соберется сборщиком мусора, что может создавать уязвимости в безопасности.

Хранение пароля в строке String не рекомендуется, так как String является неизменяемым типом данных, и тем не менее, когда пароль сохраняется в строке, он сохраняется в пуле строк, который представляет собой область памяти, которая может быть нахолдиться в памяти до тех пор, пока не будет произведено некое очистка памяти. Более того, строки, хранящие пароли, могут быть "случайно" выведены в журналы, файлы или другие места, что может привести к утечке паролей и другим потенциальным уязвимостям в безопасности.

С другой стороны, массивы char[] можно явно очистить после использования, что увеличивает безопасность. После использования пароля, можно произвести его очистку, установив каждый символ в массиве char[] в '\0', чтобы предотвратить возможность дальнейшего чтения пароля из памяти.

Например, для очистки масссива char[] можно использовать следующий код:
```java
Arrays.fill(charArray, ‘\u0000’);
```
Он устанавливает каждый элемент в массиве в символ '\0', который представлен как '\u0000'.

Таким образом, для безопасного хранения пароля в Java рекомендуется использовать массивы char[] вместо строк `String



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1214. `Почему строка является популярным ключом в HashMap в Java?`

Строки являются популярным ключом в HashMap в Java, потому что они имеют хорошо определенный hashCode и могут быть быстро сравнены с другими строками. В Java, каждый объект имеет свой hashCode, который используется для быстрого поиска объекта в HashMap. Когда вы кладете строку в HashMap, Java использует хеш-код строки, чтобы быстро найти соответствующее значение. Кроме того, сравнение строк легко реализуется с помощью метода equals(). Эффективность поисковой операции в HashMap должна быть O(1), если у вас хорошо распределенные ключи, т.е. коллизий должно быть мало.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1215. `Что делает метод intern() в классе String?.`

Метод intern() в классе String позволяет добавить строку в пул строк и вернуть ссылку на эквивалентную строку из пула. Если в пуле уже содержится строка эквивалентная текущей, то метод intern() возвращает ссылку на эту строку из пула вместо создания новой строки. Это позволяет эффективно использовать память и сравнивать строки с помощью оператора ==, потому что для эквивалентных строк == возвращает true. Вот простой пример использования метода intern():
```java
String s1 = "hello";
String s2 = new String("hello");

if (s1 == s2) {
  // Этот блок кода не будет выполнен, потому что s1 и s2 имеют разные ссылки
}

String s3 = s2.intern();

if (s1 == s3) {
  // Этот блок кода будет выполнен, потому что s3 содержит ссылку на строку "hello" из пула строк
}
```

В этом примере s1 и s2 содержат эквивалентные строки, но имеют разные ссылки, поэтому оператор == не сработает для сравнения этих строк. Однако, после вызова intern() для s2, s3 содержит ссылку на ту же самую строку "hello" из пула строк, что и s1, поэтому оператор == будет возвращать true для этих переменных.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1216. `Можно ли использовать строки в конструкции switch?`

Да, в Java можно использовать строки в конструкции switch. Вот пример кода:
```java
String color = "green";

switch(color) {
  case "red":
    System.out.println("Color is red");
    break;
  case "green":
    System.out.println("Color is green");
    break;
  case "blue":
    System.out.println("Color is blue");
    break;
  default:
    System.out.println("Color is not red, green or blue");
    break;
}
```
Этот код будет выводить "Color is green", так как значение переменной color равно "green". Важно помнить, что при сравнении строк в конструкции switch используется метод equals(), а не оператор ==. Это связано с тем, что строки в Java - это объекты, а не примитивные типы данных.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1217. `Какая основная разница между String, StringBuffer, StringBuilder?`

В Java основная разница между классами String, StringBuffer и StringBuilder заключается в том, как они обрабатывают изменения в строках.

`Класс String` является неизменяемым (immutable), что означает, что все операции модификации строки, такие как объединение строк или замена подстроки, фактически создают новую строку в памяти, а не изменяют исходную.

`Классы StringBuffer и StringBuilder` предоставляют изменяемые (mutable) аналоги строк, которые могут изменять свое содержимое без необходимости создавать новые объекты строки.

`Разница между StringBuffer и StringBuilder` заключается в том, что StringBuffer является потокобезопасным (thread-safe) и можте использоваться в многопоточной среде, в то время как StringBuilder не является потокобезопасным и не может использоваться в многопоточной среде.

В общем случае, если вы работаете с изменяемыми строками в однопоточной среде, лучше использовать StringBuilder, а если вы работаете с изменяемыми строками в многопоточной среде, лучше использовать StringBuffer.

Пример работы с классом StringBuilder:
```java
StringBuilder sb = new StringBuilder("Hello");
sb.append(" world!");
String result = sb.toString(); // "Hello world!"
```
Здесь мы создаем объект StringBuilder и используем метод append для добавления слова "world!" в конец строки. Затем мы используем метод toString для получения результирующей строки.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1218. `Что такое класс Object? Какие в нем есть методы?`

Класс Object является корневым классом в иерархии классов Java. Все классы в языке Java наследуются от него напрямую или косвенно. В классе Object определены следующие методы:

equals(Object obj) – позволяет сравнивать текущий объект с другим объектом на равенство;

+ `toString()` – возвращает строковое представление объекта;
+ `hashCode()` – возвращает хеш-код объекта;
+ `getClass()` – возвращает объект класса, к которому принадлежит текущий объект;
+ `finalize()` – вызывается перед тем, как сборщик мусора уничтожит объект;
+ `clone()` – создает копию объекта;
+ `wait()` – заставляет текущий поток ожидать до тех пор, пока другой поток не уведомит его о том, что произошло определенное событие;
+ `notify()` – разблокирует один из потоков, ожидающих на текущем объекте;
+ `notifyAll()` – разблокирует все потоки, ожидающие на текущем объекте.

Эти методы могут быть переопределены в классах-наследниках для более конкретного их поведения в соответствии с нуждами программы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1219. `Дайте определение понятию «конструктор».`

Конструктор - это метод класса в Java, который вызывается при создании нового объекта этого класса. Он используется для инициализации полей объекта и может принимать параметры. Конструктор имеет тот же имя, что и класс, и не имеет возвращаемого значения. Например, вот пример класса Person с конструктором:
```java
public class Person {
    private String name;
    private int age;
    
    // Конструктор класса Person
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // Геттеры и сеттеры для полей name и age
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}
```
Конструктор Person принимает два параметра - name и age, и устанавливает их значения для нового объекта Person. Можно создать новый объект Person следующим образом:
```java
Person person = new Person("Alice", 25);
```
В этом примере вызывается конструктор Person с параметрами "Alice" и 25, и создается новый объект типа Person с именем Alice и возрастом 25 лет.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1220. `Что такое «конструктор по умолчанию»?`

"Конструктор по умолчанию" (default constructor) - это конструктор, который имеет набор параметров по умолчанию. В Java, если вы не определяете никаких конструкторов, компилятор автоматически создаст такой конструктор без параметров. Этот конструктор пустой и не выполняет никаких действий при создании нового объекта. Например, следующий код создает экземпляр класса "Person" с использованием конструктора по умолчанию:
```java
public class Person {
    private String name;
    private int age;

    // Конструктор по умолчанию
    public Person() {
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}

Person person = new Person();
```
В данном случае, конструктор по умолчанию создается автоматически, и никаких дополнительных параметров не требуется.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1220. `Чем отличаются конструктор по-умолчанию, конструктор копирования и конструктор с параметрами?`

В Java конструктор по умолчанию создается автоматически, если не определять явно конструктор класса. Он используется для создания объекта класса со значениями по умолчанию или без параметров.

Конструктор копирования создает новый объект, который является точной копией существующего объекта. Он используется для создания нового объекта, который имеет те же значения полей, что и старый объект.

Конструктор с параметрами предназначен для инициализации полей объекта при его создании. Он определяется пользователем и принимает параметры, значения которых используются для инициализации соответствующих полей объекта.

Важно отметить, что если в классе определен конструктор, то конструктор по умолчанию автоматически не создается. Конструктор по умолчанию не передает никаких параметров и может не выполнять никаких действий. Если класс определяет только конструкторы с параметрами, то в этом классе создание объекта без передачи параметров будет вызывать ошибку компиляции.

Пример создания конструкторов:
```java
public class MyClass {
    private int num;
    private String str;

    // конструктор по умолчанию
    public MyClass() {
        num = 0;
        str = "";
    }

    // конструктор с параметрами
    public MyClass(int num, String str) {
        this.num = num;
        this.str = str;
    }

    // конструктор копирования
    public MyClass(MyClass obj) {
        num = obj.num;
        str = obj.str;
    }
}
```
В примере выше класс MyClass определяет три конструктора: конструктор по умолчанию, конструктор с параметрами и конструктор копирования. Конструктор с параметрами инициализирует поля объекта переданными параметрами при создании объекта, а конструктор копирования создает новый объект, который является точ
ной копией существующего объекта.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1221. `Где и как вы можете использовать приватный конструктор?`

В Java приватный конструктор может быть использован для различных целей, например:

+ Создание утилитного класса, который не предполагает создание экземпляров объектов, а содержит только статические методы. Приватный конструктор делает невозможным создание новых экземпляров класса снаружи.
+ Работа с шаблонами проектирования, такими как синглтон, фабрика и т. д. В таких случаях приватный конструктор используется для того, чтобы предотвратить создание экземпляров класса снаружи, а создание объектов происходит только внутри класса.
+ Работа с классом, который не должен иметь наследников. Приватный конструкторделает наследование невозможным, так как производный класс не сможет вызвать конструктор родительского класса.
+ Работа с классом, который должен быть доступен только внутри своего пакета. Приватный конструктор делает невозможным создание экземпляров класса в других пакетах.


В Java вы можете использовать приватный конструктор для создания синглтона (singleton) или для создания утилитарного класса (utility class), который не должен иметь экземпляров, но может содержать только статические методы. Утилитарные классы часто используются для группировки связанных методов в одном месте без необходимости создания экземпляров. Синглтоны, с другой стороны, ограничивают количество экземпляров класса до одного и обеспечивают глобальный доступ к экземпляру. В обоих случаях приватный конструктор предотвращает создание экземпляров класса извне.

Пример утилитарного класса с приватным конструктором:
```java
public final class StringUtils {
    private StringUtils() { // приватный конструктор
        throw new AssertionError(); // предотвращает создание экземпляров класса извне
    }
    public static boolean isNullOrEmpty(String str) {
        return str == null || str.isEmpty();
    }
    // другие статические методы
}
```
Использование этого класса:

```java
if (StringUtils.isNullOrEmpty(myString)) {
    // делайте что-то, если myString пустая или равна null
}
```
Пример синглтона с приватным конструктором:
```java
public class Singleton {
    private static final Singleton INSTANCE = new Singleton(); // создание единственного экземпляра

    private Singleton() { // приватный конструктор
    }

    public static Singleton getInstance() { // метод, для получения единственного экземпляра
        return INSTANCE;
    }

    // другие методы и переменные экземпляра
}
```
Использование синглтона:

```java
Singleton singleton = Singleton.getInstance(); // получение экземпляра
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1222. `Расскажите про классы-загрузчики и про динамическую загрузку классов.`

В Java классы-загрузчики используются для загрузки классов в память JVM (Java Virtual Machine) при выполнении программы. Классы-загрузчики взаимодействуют с классами JVM и загружают только те классы, которые нужны в текущий момент. Это позволяет программам экономить на использовании памяти и ускорять загрузку программы.

Существует три типа классов-загрузчиков:

+ `Bootstrap ClassLoader`: загружает системные классы JDK, такие как java.lang.Object и java.util.ArrayList.
+ `Extension ClassLoader`: загружает расширения Java, находящиеся в $JAVA_HOME/lib/ext.
+ `System ClassLoader`: загружает классы пользователя, указанные в переменной CLASSPATH.

Динамическая загрузка классов позволяет программисту загружать новые классы в программу во время выполнения. Это может быть полезно в тех случаях, когда часть программы должна быть загружена только по мере необходимости, или когда пользователь может выбрать, какую часть программы загрузить.

В Java динамическую загрузку классов можно осуществить с помощью Class.forName() или ClassLoader.loadClass(). Пример:
```java
ClassLoader classLoader = MyClassLoader.getInstance();
Class myClass = classLoader.loadClass("com.example.MyClass");
```
Здесь MyClassLoader - это пользовательский класс-загрузчик, который загружает класс MyClass. Это может быть полезно, если вы хотите загрузить классы из файла или другого источника, который не поддерживается стандартными методами Java загрузки классов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1223. `Что такое Reflection?`

Reflection это возможность в языке Java, которая позволяет программе получать информацию о себе во время выполнения. Она дает возможность изучать классы, интерфейсы, объекты и их параметры во время выполнения программы.

Reflection API позволяет создавать классы, объекты, вызывать методы и получать информацию о классах и их свойствах, даже если это скрытая информация. Reflection API предоставляет некоторые классы, такие как Class, Method, Constructor и Field, которые можно использовать для получения информации о классе и его свойствах.

Reflection может использоваться в различных ситуациях, например, в библиотеках, которые должны быть написаны для работы с любыми классами, в инструментах для отладки, где можно исследовать состояние приложения во время выполнения, и во многих других задачах.

Пример использования Reflection API:
```java
import java.lang.reflect.*;

public class MyClass {
  private String name;

  public MyClass(String name) {
    this.name = name;
  }

  public void printName() {
    System.out.println("Name: " + name);
  }

  public static void main(String[] args) throws Exception {
    Class<MyClass> clazz = MyClass.class;
    Constructor<MyClass> constructor = clazz.getConstructor(String.class);
    MyClass obj = constructor.newInstance("John Doe");
    Method method = clazz.getMethod("printName");
    method.invoke(obj);
  }
}
```
В этом примере мы используем Reflection API, чтобы получить класс MyClass, создать объект этого класса, вызвать его метод и вывести его имя на консоль.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1224. `Зачем нужен equals(). Чем он отличается от операции ==?`

В Java операция == используется для сравнения примитивных типов данных (int, float, boolean и т. д.) и для сравнения ссылок на объекты. Операция equals() же используется для сравнения содержимого (значений) объектов.

По умолчанию метод equals() в Java также выполняет сравнение ссылок на объекты, но этот метод можно переопределить в своем собственном классе, чтобы определить, каким образом должно производиться сравнение двух экземпляров этого класса (например, по полям класса).

Важно знать, что если вы переопределили метод equals(), то также рекомендуется переопределить метод hashCode(), чтобы обеспечить корректное поведение объектов в хеш-таблицах.

Вот пример того, как мог бы выглядеть переопределенный метод equals() и hashCode() в классе Person:
```java
public class Person {
    private String name;
    private int age;
    // constructors, getters, setters, etc.

    @Override
    public boolean equals(Object obj) {
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        Person person = (Person) obj;
        return age == person.age && Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```
В этом примере метод equals() сравнивает объекты Person по полям name и age. Метод hashCode() использует метод Objects.hash(), чтобы вычислить хеш-код на основе тех же полей. Переопределение hashCode() гарантирует, что два экземпляра класса, которые равны с помощью equals(), также будут иметь одинаковые хеш-коды.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1225. `Если вы хотите переопределить equals(), какие условия должны выполняться?`

Если вы хотите переопределить метод equals() в Java, то должны выполняться следующие условия:

+ `Рефлексивность`: a.equals(a) всегда должно возвращать true, где a - это объект любого класса.
+ `Симметричность`: Если a.equals(b) возвращает true, то b.equals(a) также должно возвращать true.
+ `Транзитивность`: Если a.equals(b) и b.equals(c) возвращают true, то a.equals(c) также должно возвращать true.
+ `Консистентность`: Повторный вызов a.equals(b) должен возвращать один и тот же результат, при условии, что ни a ни b не изменяются.
+ `Неудовлетворение null`: a.equals(null) должен всегда возвращать false, где a - это объект любого класса.

Пример переопределения метода equals() для класса Person:
```java
public class Person {
  private String name;
  private int age;
  
  // Constructors, getters, setters
  
  @Override
  public boolean equals(Object obj) {
    if (obj == this) return true;
    if (!(obj instanceof Person)) return false;
    Person other = (Person) obj;
    return this.name.equals(other.getName()) && this.age == other.getAge();
  }
}
```
Этот метод проверяет, являются ли два объекта Person равными, сравнивая их имя и возраст.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1226. `Какими свойствами обладает порождаемое equals() отношение эквивалентности?`

В Java метод equals() является отношением эквивалентности и обладает следующими свойствами:

+ `Рефлексивность`: объект должен быть равен самому себе. То есть a.equals(a) должно вернуть true.
+ `Симметричность`: если объект a равен объекту b, то объект b должен быть равен объекту a. То есть если a.equals(b) возвращает true, то и b.equals(a) должен вернуть true.
+ `Транзитивность`: если объект a равен объекту b, и объект b равен объекту c, то объект a должен быть равен объекту c. То есть если a.equals(b) и b.equals(c) возвращают true, то и a.equals(c) должно вернуть true.
+ `Согласованность`: если объект a не изменился, то вызов a.equals(b) должен всегда возвращать одинаковый результат, пока объект b не изменился.
+ `Не равенство с null`: метод equals() должен возвращать false, если объект b равен null.

Кроме того, для правильной реализации метода equals() требуется переопределить метод hashCode(). Метод hashCode() возвращает целочисленное значение, которое является "хэш-кодом" объекта и используется внутри HashMap и HashSet для оптимизации поиска и обеспечения уникальности элементов.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1227. `Правила переопределения метода Object.equals().`

Правила переопределения метода equals() из класса Object в Java:

+ Метод должен принимать на вход объект типа Object.
+ Метод должен проверить, является ли переданный объект ссылкой на тот же объект, что и текущий объект, и если да, вернуть true.
+ Метод должен проверить, является ли переданный объект экземпляром того же класса, что и текущий объект.
+ Метод должен проверить, что все поля текущего объекта и переданного объекта совпадают.
+ Если все условия проверки выполнились успешно, метод должен вернуть true, иначе - false.

Пример переопределения метода equals() в классе User:
```java
public class User {
    private String name;
    private int age;
 
    //конструктор класса
 
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof User)) return false;
 
        User user = (User) o;
 
        if (age != user.age) return false;
        return name.equals(user.name);
    }
 
   //геттеры и сеттеры
}
```
В этом примере мы проверяем , что переданный объект является экземпляром класса User, и сравниваем все поля класса в соответствии с логикой нашей программы. Если поля совпадают, метод возвращает true, иначе - false.

Не забывайте, что если переопределение метода equals() требуется в вашем классе, то, вероятно, вам также нужно переопределить метод hashCode(). Это связано с тем, что при использовании объектов в качестве ключей для хеш-таблиц необходимо, чтобы у двух объектов, которые были бы равными по equals(), был одинаковый hashCode().



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1228. `Какая связь между hashCode() и equals()?`

В Java `hashCode() и equals()` — это два метода, которые связаны со сравнением объектов и часто используются вместе. Метод equals() используется для проверки того, логически ли два объекта равны друг другу, а метод hashCode() используется для получения уникального целочисленного значения для объекта, которое можно использовать для идентификации объекта в HashMap или другом коллекции. В общем, при реализации метода equals() рекомендуется также реализовать метод hashCode(), чтобы два логически равных объекта имели одинаковый хеш-код. Причина этого в том, что метод equals() используется для проверки равенства двух объектов, а коллекции Java, такие как HashMap, используют хэш-код объекта для определения места его хранения.
Таким образом, если два объекта равны, они должны иметь одинаковый хеш-код, а если они не равны, они могут иметь одинаковые или разные хеш-коды. 
Если вы переопределяете метод equals(), вы также должны переопределить метод hashCode(), чтобы гарантировать правильное поведение объектов. правильно в сборниках. Вот пример того, как реализовать эти методы в Java:
```java
public class Person {
    private String name;
    private int age;

    // constructor
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // equals() method
    public boolean equals(Object obj) {
        if (obj == this) return true;
        if (!(obj instanceof Person)) return false;
        Person person = (Person) obj;
        return person.name.equals(name) && person.age == age;
    }

    // hashCode() method
    public int hashCode() {
        int result = 17;
        result = 31 * result + name.hashCode();
        result = 31 * result + age;
        return result;
    }
}
```
В этом примере метод equals() проверяет, имеют ли два объекта Person одинаковое имя и возраст. Метод hashCode() вычисляет хеш-код на основе имени и возраста человека по формуле 31 * результат + field.hashCode(). Обратите внимание, что в этой формуле часто используется простое число 31, поскольку оно обеспечивает хорошее распределение хэш-кодов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1229. `Если equals() переопределен, есть ли какие-либо другие методы, которые следует переопределить?`

Когда вы переопределяете метод equals() в Java, часто вам также нужно переопределить метод hashCode(). Оба метода связаны друг с другом и работают вместе во многих алгоритмах, таких, например, как использование объектов в качестве ключей в HashMap.

Также вам может потребоваться переопределить метод toString(), чтобы удобно выводить информацию о вашем объекте при отладке или логгировании.

Кроме того, зависит от вашего класса и того, какие дополнительные методы и функциональность он предоставляет. Однако обычно переопределение equals(), hashCode() и toString() достаточно для большинства классов.

Однако, если вы реализуете интерфейс Comparable, переопределение метода compareTo() тоже может понадобиться. Это позволит вашему классу сортироваться по умолчанию, например, при использовании метода Collections.sort().

Также, если ваш класс имеет подклассы, вы можете захотеть сделать его методы equals(), hashCode() и toString() доступными для перекрытия в подклассах, сделав их protected.

В целом, следует рассмотреть все методы вашего класса и решить, какие из них должны быть переопределены для достижения нужного поведения и функциональности.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1230. `Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?`

Если переопределить метод equals() без переопределения метода hashCode() в классе Java, то это может привести к проблемам при использовании объектов этого класса в коллекциях, основанных на хеш-функциях, таких как HashSet, HashMap и Hashtable.

Это связано с тем, что метод hashCode() возвращает целочисленное значение, которое используется хеш-таблицами для быстрого поиска элементов. Если hashCode() не переопределен, то хеш-значение объекта будет вычислено на основании его адреса в памяти, что может привести к проблемам с производительностью и корректностью работы хеш-таблиц.

Когда equals() переопределен, объекты, которые равны друг другу, должны иметь одинаковый хеш-код, чтобы хеш-функция могла правильно сгруппировать их в хеш-таблице. Если hashCode() не переопределен и не соответствует реализации equals(), то объекты могут иметь разные хеш-коды, что может привести к неправильной работе хеш-таблиц.

Поэтому при переопределении метода equals() обязательно следует также переопределить метод hashCode(), чтобы обеспечить корректную работу хеш-таблиц. Кроме того, реализация хорошего метода hashCode() помогает уменьшить количество коллизий в хеш-таблицах и повысить их эффективность.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1231. `Каким образом реализованы методы hashCode() и equals() в классе Object?`

Методы hashCode() и equals() в классе Object определены таким образом:

+ `equals()`: Этот метод принимает в качестве аргумента ссылку на другой объект. Он проверяет, равен ли текущий объект переданному объекту, и возвращает true, если они равны, и false в противном случае. По умолчанию, метод equals() реализует сравнение ссылок на объекты; он возвращает true только в том случае, если обе ссылки указывают на один и тот же объект.

+ `hashCode()`: Этот метод возвращает хэш-код для объекта. Хэш-код это целое число, представляющее собой сокращенное описание объекта. Хэш-коды обычно используются для оптимизации работы с коллекциями, такими как HashMap и HashSet. Хэш-код является уникальным для каждого объекта в пределах текущего запуска программы.

По умолчанию, метод hashCode() возвращает уникальное целое число для каждого объекта, а метод equals() возвращает true, только если ссылки указывают на один и тот же объект. Если вы создаете собственный класс, то вы можете переопределить эти методы в соответствии с вашими потребностями. Если вы переопределяете метод equals(), то обычно вам нужно также переопределить метод hashCode(), чтобы он возвращал одно и то же значение для объектов, которые равны с точки зрения equals().



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1232. `Для чего нужен метод hashCode()?`

В Java метод hashCode() используется для получения числового значения, которое можно использовать в качестве индекса в хэш-таблицах и других структурах данных. Метод hashCode() определен в классе Object, от которого наследуются все остальные классы в Java.

Классы, которые переопределяют метод equals(), также должны переопределить метод hashCode(), чтобы гарантировать, что два объекта, которые считаются равными согласно методу equals(), будут иметь одинаковое значение hashCode(). Это необходимо для того, чтобы объекты можно было использовать в качестве ключей в хэш-таблицах и других коллекциях, где производится поиск по хэш-коду объекта.

Например, если вы хотите использовать объект вашего собственного класса в качестве ключа в хэш-таблице, вам нужно будет переопределить методы equals() и hashCode(), чтобы гарантировать, что они работают должным образом. В противном случае, вы можете получить непредсказуемые результаты при поиске и извлечении элементов из коллекции.

Некоторые классы в стандартной библиотеке Java, такие как HashMap и HashSet, используют хэш-коды объектов для эффективного поиска, добавления и удаления элементов. Поэтому переопределение методов equals() и hashCode() особенно важно при работе со стандартными коллекциями в Java.

Метод hashCode() в Java используется для получения числового значения (хэш-кода) объекта. Хэш-код может быть использован для быстрого определения равенства двух объектов, а также для хранения объектов в хэш-таблицах. Чтобы гарантировать корректную работу хэш-таблиц, необходимо переопределить и метод equals(), чтобы он проверял только те поля объекта, которые также используются в вычислении хэш-кода.

Например, если вы создаете класс Person с полями name, age и id, то для корректной работы хэш-таблиц необходимо переопределить методы hashCode() и equals() следующим образом:
```java
public class Person {
  String name;
  int age;
  int id;

  public int hashCode() {
    return Objects.hash(name, age, id);
  }

  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof Person)) {
      return false;
    }
    Person other = (Person) obj;
    return Objects.equals(name, other.name) &&
           age == other.age &&
           id == other.id;
  }
}
```
Внутренний метод Objects.hash() вычисляет хэш-код объекта на основе переданных ему значений, а метод Objects.equals() сравнивает объекты на равенство, проверяя равенство их полей name, age и id.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1233. `Каковы правила переопределения метода Object.hashCode()?`

Когда вы создаете свой собственный класс в Java, вам может потребоваться определить метод hashCode() для этого класса. Метод hashCode() используется для вычисления хеш-кода (некоторого уникального числового значения) объекта, который может быть использован, например, в качестве ключа в хеш-таблице.

Правила переопределения метода hashCode() следующие:

+ Если метод equals() возвращает true для двух объектов, то у них должны быть одинаковые хеш-коды.
+ Если вы переопределяете метод hashCode(), то вы должны переопределить метод equals().
+ Если два объекта равны (equals() возвращает true), то их хеш-коды также должны быть равны.
+ Хеш-код должен быть вычисляемым за константное время и не изменяться в течение жизненного цикла объекта, если только какое-либо из его полей не изменится.

Кроме того, для уменьшения коллизий хеш-код должен быть равномерно распределен в пределах диапазона возможных значений (обычно int).

Пример корректного переопределения методов hashCode() и equals():
```java
public class MyClass {
    private int id;
    private String name;

    // constructors, getters, setters, etc.

    @Override
    public int hashCode() {
        int result = 17;
        result = 31 * result + id;
        result = 31 * result + (name != null ? name.hashCode() : 0);
        return result;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof MyClass)) return false;
        MyClass c = (MyClass) o;
        return id == c.id && (name == null ? c.name == null : name.equals(c.name));
    }
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1234. `Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?`

В Java есть несколько правил, которые полезно учитывать при написании метода hashCode() для своих объектов:

+ Если два объекта равны (в соответствии с методом equals()), то их hashCode() должен возвращать одинаковое значение.
+ Следует использовать те же поля объекта при вычислении hashCode(), которые используются в методе equals().
+ Если изменяемое поле объекта влияет на результат работы метода equals(), то его также следует использовать при вычислении hashCode().
+ При вычислении hashCode() лучше использовать числа простые.

Вот пример реализации метода hashCode() для простого класса Person, у которого есть поля name, age и id:
```java
public class Person {
    private String name;
    private int age;
    private long id;
    
    @Override
    public int hashCode() {
        int result = 17; // начальное значение

        result = 31 * result + name.hashCode(); // умножаем на простое число, чтобы получить более случайное число
        result = 31 * result + age;
        result = 31 * result + (int) (id ^ (id >>> 32)); // для long используем такой способ, чтобы отчасти сохранить случайность
        
        return result;
    }

    // реализация equals() здесь
}
```
В этом примере мы используем простые числа 17 и 31, чтобы получить более "случайный" результат, а также включаем в вычисление идентификатор объекта типа long с помощью применения к нему побитовых операций.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1235. `Могут ли у разных объектов быть одинаковые hashCode()?`

Да, у разных объектов могут быть одинаковые значения hashCode(). Это называется коллизией хеша. Метод hashCode() в Java предназначен для создания хеш-кода объектов, который используется в хеш-таблицах и других структурах данных для обеспечения быстрого доступа к данным. Использование метода hashCode() обычно не гарантирует уникальность значений, поэтому для уравновешивания коллизий и обеспечения корректного функционирования структуры данных требуется переопределить метод equals(). Обычно, если два объекта считаются равными с помощью метода equals(), они должны иметь одинаковые хеш-коды, но не наоборот. Из-за этого можно реализовать метод hashCode() таким образом, чтобы он выдавал одинаковый результат для всех объектов, что иногда используется для упрощения кода.

Да, у разных объектов могут быть одинаковые значения hashCode() в Java. Однако, в идеале хорошо бы, чтобы коллизии, то есть ситуации, когда у разных объектов совпадает hashCode(), были бы минимальными, так как это может повлиять на производительность многих структур данных, например HashMap или HashSet. Чтобы уменьшить количество коллизий, можно переопределить метод hashCode() в вашем классе. Хэш-функция должна быть реализована таким образом, чтобы с большой вероятностью различные объекты давали разные хэш-коды. Кроме того, если два объекта имеют одинаковый хэш-код, то необходимо переопределить еще метод equals() для корректного сравнения объектов по значениям их полей.

Вот пример переопределения метода hashCode() в классе Person:
```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + age;
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        return result;
    }
}

```
Здесь мы используем метод hashCode() из класса String для получения хэш-кода поля name и добавляем его к результату. Поле age просто складываем с сдвинутой на 5 позиций налево константой 31. Примечание, что использовать слишком простые хэш-функции может приводить к увеличению количества коллизий, а избыточно сложные могут з



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1236. `Если у класса Point{int x, y;} реализовать метод equals(Object that) {(return this.x == that.x && this.y == that.y)}, но сделать хэш код в виде int hashCode() {return x;}, то будут ли корректно такие точки помещаться и извлекаться из HashSet?`

Если реализовать метод equals(Object that) таким образом: (return this.x == that.x && this.y == that.y) , а метод hashCode() вернуть только одно значение x, то вероятность коллизий в HashSet будет высокой. Это потому, что HashSet использует метод hashCode() для размещения элементов в таблице. При такой реализации две точки (x1, y1) и (x2, y2) будут помещаться в таблицу HashSet в одно и то же место (в одну и ту же ячейку), если их координаты по оси X совпадают:
```java
new Point(1, 2).hashCode() == new Point(1, 5).hashCode() // true
```
Таким образом, необходимо обеспечить уникальный хэш для каждой точки, чтобы избежать коллизий. Один из способов сделать это - использовать хэш-функцию, которая учитывает обе координаты точки:
```java
public int hashCode() {
    return Objects.hash(x, y);
}
```

Такая реализация гарантирует уникальный хэш для каждой точки и позволит корректно помещать и извлекать точки из HashSet.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1237. `Могут ли у разных объектов (ref0 != ref1) быть ref0.equals(ref1) == true?`

Да, это возможно. Метод equals() определяет, равен ли один объект другому, и он может быть переопределен в Java классах пользовательского интерфейса. Если два объекта равны, их хэш-коды должны быть равными. Однако, если хэш-коды равны, объекты могут не быть равными.

Итак, (ref0 != ref1) является проверкой на несоответствие ссылок на два разных объекта, а ref0.equals(ref1) == true означает, что содержимое этих объектов равны друг другу по сравнению методом equals().



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1238. `Могут ли у разных ссылок на один объект (ref0 == ref1) быть ref0.equals(ref1) == false?`

Да, у разных ссылок на один объект (ref0 == ref1) может быть ref0.equals(ref1) == false. Метод equals() определяет, равны ли два объекта с точки зрения их значений. Однако == сравнивает ссылки на объекты. Если у двух ссылок разные адреса, то при сравнении с помощью equals() они будут считаться неравными. Например, для двух разных объектов String с одинаковыми значениями "hello" и "hello", метод equals() вернет true, но при сравнении ссылок с помощью оператора ==, они будут не равными.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1239. `Можно ли так реализовать метод equals(Object that) {return this.hashCode() == that.hashCode()}?`

Хотя технически возможно реализовать метод equals(Object that) путем сравнения хэш-кодов, обычно не рекомендуется полагаться на хэш-коды для сравнения объектов на равенство. Это связано с тем, что хэш-коды не обязательно будут уникальными и могут конфликтовать между разными объектами.

Лучшим подходом является сравнение фактических полей или атрибутов двух объектов, чтобы определить, равны ли они. Это можно сделать, переопределив метод equals и затем сравнив соответствующие поля или атрибуты двух объектов.

Вот пример того, как переопределить метод equals с помощью оператора instanceof, чтобы проверить, относится ли другой объект к тому же классу, а затем сравнить соответствующие поля или атрибуты:

```java 
public class MyClass {
  private int value;

  @Override
  public boolean equals(Object other) {
    if (other == this) {
      return true;
    }
    if (!(other instanceof MyClass)) {
      return false;
    }
    MyClass that = (MyClass) other;
    return this.value == that.value;
  }

  // other methods and constructors...
}

```

В этом примере метод equals сначала проверяет, является ли другой объект тем же самым объектом, что и this, используя ссылочное равенство (other == this). Если это правда, то объекты равны, поэтому возвращается true. В противном случае он проверяет, является ли другой объект экземпляром MyClass, используя оператор instanceof. Если это не экземпляр MyClass, он возвращает false. Если это экземпляр MyClass, он приводит другой объект к MyClass, а затем сравнивает поле значения, чтобы определить равенство.


Обратите внимание, что при переопределении равенства вы также должны переопределить метод hashCode, чтобы гарантировать, что одинаковые объекты имеют одинаковый хэш-код. Это важно при использовании объектов в качестве ключей в структурах данных на основе хэшей, таких как HashMap. 

В общем, рекомендуется определять равенство таким образом, который согласуется с поведением идентификатора объекта (==). Например, два объекта, которые равны по своим полям, также должны быть равны при сравнении с использованием ==.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1240. `В equals() требуется проверять, что аргумент equals(Object that) такого же типа что и сам объект. В чем разница между this.getClass() == that.getClass() и that instanceof MyClass?`

В методе equals(Object that) требуется проверять, что аргумент that является объектом того же класса, что и сам объект. Это делается для того, чтобы убедиться, что сравниваемые объекты имеют одинаковые поля и свойства, и могут быть считаны эквивалентными.

Существуют два способа проверки, что аргумент that является объектом того же класса. Первый способ - это сравнение классов объекта и аргумента сравнения с помощью оператора ==. Код для этого выглядит так: this.getClass() == that.getClass(). Второй способ - это использование оператора instanceof, что позволяет проверить, является ли аргумент объектом того же класса или производного класса, что и сам объект. Код для этого выглядит так: that instanceof MyClass.

Оба способа можно использовать в качестве проверки на соответствие типа сравниваемых объектов. Однако, предпочтительнее использовать оператор instanceof, так как он охватывает более широкий диапазон объектов. Также, оператор instanceof используется, когда требуется проверить, является ли аргумент членом определенного класса или его наследника.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1241. `Можно ли реализовать метод equals() класса MyClass вот так: class MyClass {public boolean equals(MyClass that) {return this == that;}}?`

Да, метод equals() класса MyClass можно реализовать следующим образом:

```java 
class MyClass {
    public boolean equals(MyClass that) {
        return this == that;
    }
}

```
Однако эта реализация проверяет только, являются ли оба объекта идентичными экземплярами, а это означает, что два объекта должны занимать одну и ту же ячейку памяти. Эта реализация не проверяет, совпадают ли значения свойств двух объектов.

В большинстве случаев метод equals() используется для определения того, имеют ли два объекта одинаковое состояние, а не для того, чтобы определить, являются ли объекты одним и тем же экземпляром. Для проверки равного состояния обычно переопределяют метод equals() и проверяют свойства двух объектов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1242. `Есть класс Point{int x, y;}. Почему хэш код в виде 31 * x + y предпочтительнее чем x + y?`

Причина, по которой хеш-код для класса вроде Point реализован как 31 * x + y, заключается в том, что он помогает уменьшить количество коллизий между объектами при их хэшировании. 

Умножение на 31 — обычная практика в Java для вычисления хэш-кодов, потому что 31 — нечетное простое число, а умножение на нечетное простое число помогает более равномерно распределить хэш-коды по хеш-таблице. Формула 31*x+y — лишь одна из многих возможных формул для вычисления хеш-кодов, и ее эффективность может зависеть от конкретного варианта использования и характеристик хэшируемых объектов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1243. `Расскажите про клонирование объектов.`

Клонирование объектов в Java происходит с помощью метода Object.clone(). Этот метод создаёт и возвращает копию объекта. Класс объекта, который мы хотим клонировать, должен реализовать интерфейс Cloneable и переопределить метод clone().

Но есть некоторые особенности процесса клонирования в Java:

+ Метод clone() не является public, поэтому его нельзя вызвать из другого класса. Для клонирования объекта, необходимо создать публичный метод, вызывающий метод clone() для соответствующего объекта.
+ Если класс объекта не реализует интерфейс Cloneable, то его клонирование приведёт к исключению CloneNotSupportedException.
+ Клонирование объектов в Java происходит по значению, а не по ссылке, поэтому изменения в клонированном объекте не повлияют на исходный объект.

Например, если у нас есть класс Person, то мы можем клонировать его так:
```java
public class Person implements Cloneable {
    private String name;
    private int age;
    // конструкторы, геттеры и сеттеры
    public Person clone() throws CloneNotSupportedException {
        return (Person) super.clone();
    }
}
```
И затем создаем новый объект примерно так:
```java
Person person1 = new Person("John", 35);
Person person2 = person1.clone();
```
Person person2 — это клон объекта person1, который сохраняет его состояние в момент клонирования. Python также имеет подобный механизм клонирования.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1244. `В чем отличие между поверхностным и глубоким клонированием?`

В Java есть два способа клонирования объектов - поверхностное клонирование (shallow cloning) и глубокое клонирование (deep cloning).

При `поверхностном клонировании` новый объект создается, и его поля заполняются ссылками на те же самые объекты, на которые ссылается клонируемый объект. В результате изменение этих объектов может отразиться как на клонированном объекте, так и на исходном объекте.

При `глубоком клонировании` создается новый объект, и его поля заполняются копиями объектов, на которые ссылается клонируемый объект. Таким образом, изменение этих объектов не отразится на клонированных объектах и на исходном объекте.

Для реализации глубокого клонирования в Java можно использовать интерфейс Cloneable и метод clone(). Однако, для корректной реализации глубокого клонирования необходимо обеспечить правильную работу clone() для всех полей, включая поля ссылочного типа.

Например, реализация глубокого клонирования может выглядеть следующим образом:
```java
public class MyClass implements Cloneable {
    private int myField;
    private MyOtherClass myOtherField;

    @Override
    public Object clone() throws CloneNotSupportedException {
        // Вызываем метод clone() у суперкласса для клонирования объекта
        MyClass clone = (MyClass) super.clone();
        // Клонируем поле myOtherField
        clone.myOtherField = (MyOtherClass) myOtherField.clone();
        return clone;
    }
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1245. `Какой способ клонирования предпочтительней?`

Преимущества каждого из способов клонирования зависят от конкретной ситуации, в которой он используется. При поверхностном клонировании копируются только ссылки на объекты, а не сами объекты, что может привести к тому, что изменения в одном объекте могут повлиять на другой. При глубоком клонировании копируются также и сам объект, что делает каждую копию отдельной и не зависящей от оригинала.

Чаще всего в Java для клонирования используют метод clone(), который выполняет поверхностное клонирование. Однако при необходимости провести глубокое клонирование, необходимо реализовывать интерфейс Cloneable и переопределять метод clone(), чтобы скопировать все поля объекта и объекты, на которые ссылаются поля. Для простых объектов, глубокое клонирование может быть не таким сложным, но для сложных объектов может потребоваться дополнительное управление, что может затруднить реализацию.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1246. `Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?`

В Java метод clone() объявлен в классе Object, а не в интерфейсе Cloneable, потому что он позволяет создать и вернуть новый объект, который является копией исходного объекта. Таким образом, метод clone() относится к функционалу языка, предоставляемому всем объектам в Java Runtime, а не только тем, которые реализуют интерфейс Cloneable.

Интерфейс Cloneable в Java не имеет методов, он является "маркерным интерфейсом", показывающим, что класс, реализующий этот интерфейс, поддерживает клонирование. Если класс не реализует интерфейс Cloneable, то при вызове метода clone() у него возникнет исключение CloneNotSupportedException.

Таким образом, метод clone() предназначен для создания копии объекта, что может потребоваться при многопоточном программировании, где разные потоки могут использовать один и тот же объект.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1247. `Опишите иерархию исключений.`

В Java иерархия исключений представлена классом Throwable, который имеет два основных наследника: классы Error и Exception.


![exceptionsInJavaHierarchy](images/java/exceptionsInJavaHierarchy.png)

Класс Error описывает ошибки, которые вызываются внутренними проблемами виртуальной машины Java, такие как ошибки выделения памяти (OutOfMemoryError). Обрабатывать исключения класса Error не следует, так как они не подлежат исправлению программными средствами.

Класс Exception описывает исключения, которые вызываются проблемами в работе программы. Этот класс имеет несколько наследников, например RuntimeException, IOException и другие. RuntimeException описывает исключения, которые могут быть предотвращены программистом и имеют отношение к ошибкам программы во время выполнения.

Для обработки исключений в Java используют оператор try-catch. В операторе try записывается блок кода, в котором может возникнуть исключение. Далее в блоке catch указывается исключение, которое необходимо обработать. Если исключение возникает в блоке try, программа переходит в блок catch, где выполняется обработка ошибки.

Например, следующий код демонстрирует использование оператора try-catch:
```java
try {
    // Блок кода, в котором может возникнуть исключение
} catch(Exception e) {
    // Обработка исключения, вывод сообщения об ошибке и т.п.
}
```
Также можно определить собственное исключение, которое будет наследоваться от класса Exception, и использовать его в своей программе. Для этого необходимо создать класс исключения и указать, что он наследуется от класса Exception.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1248. `Какие виды исключений в Java вы знаете, чем они отличаются?`

В Java есть два вида исключений: проверяемые (checked) и непроверяемые (unchecked). 

`Проверяемые исключения` - это исключения, которые должны быть обработаны или перехвачены в блоке try-catch, иначе компилятор не позволит скомпилировать код. 

`Непроверяемые исключения, также известные как RuntimeException`, не обязательно должны быть обработаны или перехвачены, и их можно не указывать в сигнатуре методов.

`Некоторые примеры проверяемых исключений в Java: IOException, SQLException, ClassNotFoundException.`

`Примеры непроверяемых исключений: NullPointerException, ArrayIndexOutOfBoundsException, ArithmeticException.`

Непроверяемые исключения обычно возникают из-за ошибок программиста, таких как доступ к null ссылке или деление на ноль, в то время как проверяемые исключения могут возникнуть по разным причинам, таким как проблемы с вводом-выводом, базы данных и т.д.

Учитывайте, что некоторые исключения наследуются от Error, а не от Exception и не являются ни проверяемыми, ни непроверяемыми исключениями. Например, StackOverflowError и OutOfMemoryError.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1249. `Что такое checked и unchecked exception?`

В Java `checked и unchecked exceptions` - это два типа исключений. Checked исключения должны быть обрабатываны или объявлены в заголовке метода с помощью слова ключевого слова throws, в то время как unchecked исключения не обязаны быть обработаны или объявлены. Компилятор Java гарантирует, что программа предоставляет обработку checked исключений, но не гарантирует это для unchecked исключений.

Примеры checked exception:

+ IOException
+ ClassNotFoundExceptio
+ SQLException

Примеры unchecked exception:

+ NullPointerException
+ ArrayIndexOutOfBoundsException
+ IllegalArgumentException

Как именно обрабатывать исключения в вашем коде зависит от конкретных требований вашей программы, но в общих чертах, checked исключения обычно следует обрабатывать в коде, а unchecked исключения следует использовать для ошибок, которые маловероятно произойдут, и которые обычно указывают на ошибки программиста.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1250. `Какой оператор позволяет принудительно выбросить исключение?`

В Java, оператор, который позволяет явно выбросить исключение, называется throw. Он используется для выброса исключения из блока try в случае возникновения ошибки. Например:

```java
if (x < 0) {
  throw new IllegalArgumentException("x must be non-negative");
}
```
Этот код выбросит исключение IllegalArgumentException в случае, если значение переменной x меньше нуля. Конструктору IllegalArgumentException передается сообщение, которое будет содержаться в исключении.

Кроме того, оператор throw можно использовать для перехвата исключения в одном методе и выброса его в вызывающий метод. Например:
```java
public void doSomething() throws SomeException {
  try {
    // some code that might throw SomeException
  } catch (SomeException e) {
    // handle the exception
    throw e; // re-throw the same exception to the caller
  }
}
```
Здесь метод doSomething() может выбросить исключение SomeException. Если это происходит, оно перехватывается в блоке catch и обрабатывается. Затем исключение снова выбрасывается с помощью оператора throw для передачи его в вызывающий метод.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1251. `О чем говорит ключевое слово throws?`

В Java ключевое слово throws используется в объявлении метода, чтобы указать, что метод может бросать исключение определенного типа. Это означает, что при вызове этого метода в коде, вызывающий код должен либо также бросить это исключение, либо обработать его с помощью блока try-catch. Например, следующий метод бросает исключение типа MyException:
```java
public void doSomething() throws MyException {
  // code here
}
```
Если метод вызывается в другом методе, который также не обрабатывает это исключение, то исключение будет передано выше по стеку вызовов, наконец будет передано в вызывающий метод, который должен обработать исключение.

Использование ключевого слова throws является хорошей практикой программирования, которая позволяет обработать исключения и сделать код более предсказуемым и надежным.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1252. `Как написать собственное («пользовательское») исключение?`

В Java можно создавать пользовательские исключения с помощью создания нового класса, который наследуется от класса Exception или его подклассов. Для создания пользовательского исключения необходимо определить конструктор, который вызывает конструктор родительского класса, и добавить необходимые поля, методы и свойства.

Вот пример простого пользовательского исключения в Java:
```java
public class MyException extends Exception {
    public MyException() {
        super("This is my custom exception.");
    }
}
```
Вы можете заменить "This is my custom exception." на сообщение об ошибке, которое вы хотите отобразить при возникновении этого исключения.

Чтобы использовать этот пользовательский класс исключения, вы можете создать экземпляр этого класса и вызвать метод throw с помощью ключевого слова throw. Например:
```java
try {
    throw new MyException();
} catch (MyException e) {
    System.err.println(e.getMessage());
}
```
В этом примере при возникновении исключения MyException будет выведено сообщение "This is my custom exception.".



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1253. `Какие существуют unchecked exception?`

В Java существует несколько типов непроверяемых (unchecked) исключений, включая:

+ RuntimeException и его подклассы (например, NullPointerException, IllegalArgumentException, IndexOutOfBoundsException, ClassCastException, ArithmeticException)

+ Error и его подклассы (например, OutOfMemoryError, StackOverflowError)

Непроверяемые исключения отличаются от проверяемых (checked) исключений тем, что компилятор не требует их обработки или объявления в блоке throws. При возникновении непроверяемого исключения, оно может быть перехвачено в блоке try-catch или может передаться на уровень выше в стеке вызовов вызывающих методов. Если исключение не перехватывается на всех уровнях вызова и достигает верхнего уровня, программа может завершиться с сообщением об ошибке.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1254. `Что представляет из себя ошибки класса Error?`

Ошибка класса Error в Java является подклассом класса Throwable. Как и у всех классов-исключений в Java, есть множество подклассов у Error. Эти подклассы позволяют разработчикам более точно определять ошибку, которая произошла в программе.

Error является необрабатываемым исключением, то есть он является ошибкой в работе Java Virtual Machine, которая свидетельствует о том, что приложение не может продолжить нормально работать. Некоторые примеры известных подклассов Error в Java включают StackOverflowError, OutOfMemoryError, AssertionError и LinkageError.

Поскольку Error является необрабатываемым исключением, он не должен ловиться и обрабатываться в программе. Вместо этого, если возникает ошибка Error, лучше просто попробовать исправить ее и перезапустить приложение.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1255. `Что вы знаете о OutOfMemoryError?`

`OutOfMemoryError` — это исключение времени выполнения в языке программирования Java, которое возникает, когда больше не остается памяти для выделения программой. Эта ошибка обычно возникает, когда память кучи, выделенная для программы, исчерпана, что может быть вызвано различными факторами, такими как создание слишком большого количества объектов, неправильная сборка мусора или загрузка больших объектов в память.

Существует несколько стратегий обработки OutOfMemoryError, в том числе увеличение размера кучи с помощью параметра JVM -Xmx или оптимизация программы для более эффективного использования памяти за счет уменьшения количества создаваемых объектов, повторного использования существующих объектов и надлежащего удаления объектов, которые больше не требуются. .

OutOfMemoryError — это распространенная проблема в программах Java, и разработчикам важно знать о возможных причинах и решениях этой ошибки.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1256. `Опишите работу блока try-catch-finally.`

Блок try-catch-finally - это механизм обработки исключений в Java.

В блоке try содержится код, который нужно выполнить. Если в процессе выполнения этого кода возникает исключение, то выполняется блок catch с соответствующим типом исключения, в котором можно обработать это исключение или выполнить соответствующие действия. Если исключение не было обработано в блоке catch, оно продолжает распространяться по методам, пока не будет обработано или программа не завершится.

Блок finally содержит код, который должен выполниться в любом случае, независимо от того, было ли выкинуто исключение или нет. В этом блоке можно выполнить необходимые действия по очистке ресурсов, закрытию потоков и т.д.

Пример использования блока try-catch-finally:
```java
try {
  // выполнение кода, который может выкинуть исключение
} catch (SomeException e) {
  // обработка исключения
} finally {
  // выполнение кода, который должен выполниться в любом случае
}
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1257. `Что такое механизм try-with-resources?`

Механизм try-with-resources - это нововведение в Java 7, которое предоставляет более простой и безопасный способ управления ресурсами, такими как файлы и сетевые соединения, в блоках try-catch. Когда вы используете try-with-resources, вы можете определить один или несколько ресурсов в заголовке блока try, после чего он будет автоматически закрыт при завершении блока try. Это особенно удобно при работе с ресурсами, которые могут поломаться или неожиданно закрыться, например, при работе с файлами или сетевыми соединениями.

Вот пример использования try-with-resources для чтения строк из файла:
```java 
try (BufferedReader br = new BufferedReader(new FileReader("myfile.txt"))) {
    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException e) {
    System.err.println("Failed to read file: " + e.getMessage());
}
```
Здесь BufferedReader и FileReader оба являются ресурсами, которые будут автоматически закрыты при завершении блока try. Это гарантирует, что ресурсы будут корректно закрыты, даже если произойдет исключение в блоке try.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1258. `Возможно ли использование блока try-finally (без catch)?`

Да, блок try-finally можно использовать без catch. Блок finally содержит код, который всегда исполняется, независимо от того, было исключение в блоке try или нет. Он часто используется для того, чтобы выполнить какие-то заключительные действия, например, закрыть файл или соединение с базой данных, которые необходимо выполнить независимо от того, были ошибки или нет. Вот пример использования блока try-finally без catch:
```java
try {
    // выполнение кода
} finally {
    // код, который должен быть выполнен независимо от наличия исключения
}
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1258. `Может ли один блок catch отлавливать сразу несколько исключений?`

Да, в Java блок catch может отлавливать сразу несколько исключений. Для этого необходимо перечислить их через символ |:
```java
try {
   // some code that might throw exceptions
} catch (IOException | ParseException e) {
   // handle IOException or ParseException
}
```
В этом примерe блок catch может обработать как IOException, так и ParseException. Обратите внимание, что типы исключений должны быть связаны отношением "is-a" (наследование в Java). Если типы не связаны, то необходимо использовать несколько блоков catch для каждого типа исключений.





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1259. `Всегда ли исполняется блок finally?`

В Java блок finally будет выполнен всегда, даже если было возбуждено исключение в try блоке и это исключение не было перехвачено в соответствующем catch блоке. Код в блоке finally предназначен для выполнения затратных операций, таких как закрытие файла или соединения, независимо от того, было ли выполнено нормальное завершение блока try или произошло исключение. Вот пример, который демонстрирует это поведение:
```java
try {
   // Какой-то код, который может вызвать исключение
} catch (Exception e) {
   // Обработка исключения
} finally {
   // Блок finally, который будет выполнен независимо от того, было или нет исключение
   // например, закрытие открытого ресурса
}
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1260. `Существуют ли ситуации, когда блок finally не будет выполнен?`

В основном блок finally в Java выполняется всегда, кроме нескольких случаев:

+ Если выполнение JVM прерывается или происходит выход по ошибке системы, например, с помощью вызова System.exit() в блоке try или catch.

+ Если возникает бесконечный цикл, или программа зависает.

+ Если выполняется неконтролируемый блок кода, такой как бесконечный цикл.

Однако, если в блоке try или catch встречается оператор return, try или catch сразу же завершается и управление передается в вызывающую функцию, и только потом блок finally выполняется.

Также блок finally не будет выполнен, если в блоке try или catch возникает ошибку OutOfMemoryError, которая связана с нехваткой памяти.

Во всех других случаях блок finally будет выполнен.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1261. `Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?`

Да, метод main() в Java может генерировать исключение, и если это произойдет, исключение будет распространено на JVM. Если исключение не обрабатывается программой, JVM напечатает трассировку стека и завершит программу. Если исключение перехватывается и обрабатывается в main() (или любом другом методе, вызываемом main()), то программа может продолжить выполнение.

Однако, если исключение перехватывается и не выбрасывается повторно или не распространяется дальше, программа также завершится.

Вот пример метода main(), который генерирует исключение:

```java
public class Main {
    public static void main(String[] args) throws Exception {
        throw new Exception("An error occurred");
    }
}

```
В этом примере метод main() создает новый объект Exception с сообщением об ошибке. Предложение «throws Exception» в сигнатуре метода указывает, что этот метод может генерировать исключение типа Exception.

Обратите внимание, что в приведенном выше примере исключение не перехватывается и не обрабатывается, поэтому программа завершает работу и печатает трассировку стека исключения.

Если вы хотите перехватить и обработать исключение, вы можете окружить код, выбрасывающий исключение, блоком try-catch:


```java
public class Main {
    public static void main(String[] args) {
        try {
            throw new Exception("An error occurred");
        } catch (Exception e) {
            System.out.println("Caught an exception: " + e.getMessage());
        }
    }
}

```
В этом примере блок try содержит код, вызывающий исключение, а блок catch перехватывает исключение и выводит сообщение на консоль. 

Обратите внимание, что нам не нужно указывать «выбрасывает исключение» в сигнатуре метода, так как теперь мы перехватываем исключение и обрабатываем его в методе main().




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1262. `Предположим, есть метод, который может выбросить IOException и FileNotFoundException в какой последовательности должны идти блоки catch? Сколько блоков catch будет выполнено?`

Когда метод может выбросить IOException и FileNotFoundException, настоятельно рекомендуется обработать каждое исключение в отдельном блоке catch. Если мы решим поместить оба исключения в один блок catch, то нам придется добавить дополнительный код для определения, какое исключение было выброшено. Проще всего разместить два блока catch, которые следуют друг за другом:
```java
try {
    // Код, который может выбросить IOException
} catch (IOException e) {
    // Обработка IOException
}

try {
    // Код, который может выбросить FileNotFoundException
} catch (FileNotFoundException e) {
    // Обработка FileNotFoundException
}
```
В этом случае каждое исключение будет обработано отдельно, и такой подход упрощает код обработки исключений и делает его более понятным. Если оба блока catch были задействованы, то оба будут выполнены.

Пример кода для обработки этих исключений:
```java
try {
    // some code that may throw IOException or FileNotFoundException
} catch (IOException e) {
    // handle IOException
} catch (FileNotFoundException e) {
    // handle FileNotFoundException
}
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1263. `Что такое generics?`

Generics - это механизм в Java, который позволяет создавать классы, интерфейсы и методы, которые работают с параметризованными типами данных. Использование Generics позволяет писать более безопасные и переиспользуемые программы, поскольку компилятор Java может проверять типы данных во время компиляции.

К примеру, если вы хотите иметь класс, который может работать с любым типом данных (например, LinkedList), используя Generics, вы можете написать его так:
```java
public class LinkedList<T> {
    private Node<T> head;

    public void add(T value) {
        // добавляем элемент в связанный список
    }

    private class Node<T> {
        T value;
        Node<T> next;
    }
}
```
Теперь, когда вы создаете экземпляр LinkedList, вы можете указать тип данных, с которым он будет работать, например:
```java
LinkedList<String> list = new LinkedList<String>();
list.add("hello");
```
Здесь тип T заменен на String. Это означает, что LinkedList будет работать только с объектами типа String, и компилятор Java будет проверять типы для вас.

Generics также позволяют создавать обобщенные интерфейсы и методы, что дает еще больше возможностей для переиспользования кода в Java.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1264. `Что такое «интернационализация», «локализация»?`

"Интернационализация" и "локализация" - это две связанные между собой концепции, которые важны для разработчиков программного обеспечения, особенно для тех, кто работает с приложениями, предназначенными для использования в разных языковых и региональных настройках.

"Интернационализация", также известная как "i18n" (где "18" обозначает количество букв между "i" и "n" в слове "internationalization"), означает разработку приложения таким образом, чтобы оно было легко адаптируемо для использования в различных языках и регионах. Это может включать в себя использование мультиязычных текстовых строк, поддержку разных форматов даты и времени, форматирование чисел и валют в соответствии с настройками локали и т.д.

"Локализация", известная как "l10n" (где "10" обозначает количество букв между "l" и "n" в слове "localization"), это процесс адаптации приложения для конкретной локали, включая перевод текстовых строк на местный язык, адаптацию форматов даты и времени, чисел и валют, а также учёт местных традиций и обычаев.

В Java есть множество классов и инструментов для работы с "i18n" и "l10n", такие как Locale, ResourceBundle, ListResourceBundle, NumberFormat, DateFormat, MessageFormat и многие другие, которые могут помочь разработчикам создавать приложения.





# 4 Блок вопросов


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1265. `Что мы знаем о методе main`

Метод main, который находится внутри класса, является входной точкой программы на Java. Он выполняется при запуске приложения виртуальной машины Java (JVM) и предоставляет ей необходимые для запуска приложения параметры.

Сигнатура метода main обязательно должна иметь вид public static void main(String[] args) , где public - модификатор доступа, static - ключевое слово означающее что данный метод является методом класса, void - указывает на то, что метод не возвращает значения, main - имя метода, String[] args - аргументы (параметры) командной строки, которые могут быть переданы программе при запуске.

Пример вызова метода main:

```java
public class MyProgram {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
```
Запуск программы:
```bash
$ javac MyProgram.java
$ java MyProgram
```
Этот код выведет "Hello World!" в консоль.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1266. `Что такое массивы в Java`

В Java массив это упорядоченная коллекция элементов определенного типа данных. Каждый элемент массива имеет индекс, начинающийся с нуля. Тип данных элементов массива должен быть одним из примитивных типов данных (например, int, float, char) или же объектом класса. Чтобы создать массив, нужно указать тип данных его элементов и количество элементов в квадратных скобках. Ниже приведен пример объявления и заполнения массива типа int в Java:
```java
int[] myArray = new int[3]; // создание массива из трех элементов типа int
myArray[0] = 1; // присваивание первому элементу значения 1
myArray[1] = 2; // присваивание второму элементу значения 2
myArray[2] = 3; // присваивание третьему элементу значения 3
```




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1267. `Какой класс реализует динамический массив в Java, и что мы можем про него рассказать?`

В Java динамический массив реализуется с помощью класса ArrayList. ArrayList является обобщенным классом, который позволяет создавать массивы переменного размера, автоматически изменяющие свой размер при добавлении или удалении элементов. Он реализует интерфейс List и позволяет выполнять множество операций, включая добавление, удаление и поиск элементов, а также доступ по индексу.

ArrayList в Java является реализацией динамического массива, который позволяет хранить элементы одного типа. ArrayList может расширяться по мере необходимости при добавлении элементов в список, и освобождаться при удалении элементов.

Важно помнить, что ArrayList может затратить больше памяти, чем обычный массив в Java, так как он динамически изменяет свой размер. Однако, в большинстве случаев ArrayList обеспечивает более удобный и гибкий способ работы с массивами, особенно когда нужно работать с изменяемыми массивами.

Пример использования ArrayList в Java:
```java
import java.util.ArrayList;
ArrayList<String> list = new ArrayList<String>();
list.add("element 1");
list.add("element 2");
```
Здесь создается список строк, который можно заполнять добавлением новых элементов методом add()

Когда ArrayList создается, он имеет некоторую начальную емкость, которая по умолчанию равна 10. Если вы знаете, что вам понадобится больше места, чем это, вы можете указать начальную емкость при создании ArrayList, чтобы избежать ресайзинга массива и получить лучшую производительность.

Еще одна важная деталь - при увеличении размера массива происходит копирование всех элементов в новый массив, что может приводить к дополнительным затратам по производительности, если ArrayList содержит большое количество элементов.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1268. `За счет чего NIO обеспечивает неблокируемый доступ к ресурсам?`

Java NIO (расшифровывается как Non-blocking Input/Output) — это библиотека на Java, которая предоставляет альтернативу традиционному блокирующему API-интерфейсу ввода-вывода, предоставляемому пакетом java.io. Он был представлен в Java 1.4 и предлагает такие функции, как отображаемые в память файлы, масштабируемый ввод-вывод, блокировка файлов и неблокирующий ввод-вывод сокетов. NIO основан на концепции каналов и буферов, которые обеспечивают более эффективные и гибкие операции ввода-вывода по сравнению с потоковым вводом-выводом, предоставляемым java.io. 

Одним из преимуществ NIO является возможность выполнять неблокирующий ввод-вывод, что позволяет одному потоку обрабатывать несколько операций ввода-вывода без блокировки и, таким образом, повышает масштабируемость и производительность в сценариях с высокой нагрузкой. Кроме того, NIO поддерживает использование селекторов для мультиплексирования операций ввода/вывода в нескольких сокетах, что позволяет одному потоку обрабатывать несколько каналов, дополнительно повышая производительность и использование ресурсов.

Java NIO (Non-blocking IO) обеспечивает неблокируемый доступ к ресурсам за счет асинхронности и использования буферов. В противоположность традиционным библиотекам ввода/вывода, которые являются блокирующими, Java NIO позволяет выполнять несколько операций ввода/вывода одновременно в одном потоке, используя меньше потоков и ресурсов. Это достигается за счет услуг, таких как каналы, селекторы и буферы, которые обеспечивают асинхронную, неблокируемую передачу данных между процессом и ядром операционной системы. Селекторы позволяют процессу мониторить несколько каналов для ввода/вывода, в то время как буферы обеспечивают быстрое чтение и запись данных.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1269. `Как работает CopyOnWriteArrayList`

CopyOnWriteArrayList — это потокобезопасный вариант ArrayList в Java. Основная идея заключается в том, что он создает новую копию базовой структуры данных для каждой операции записи (добавление, установка, удаление), и эта копия затем становится доступной для чтения всеми потоками, в то время как исходный массив остается неизменным. Это означает, что любые операции чтения всегда будут иметь согласованное представление данных, которые существовали во время последней операции записи, без необходимости использования блокировок для синхронизации. Хотя это обеспечивает преимущества потокобезопасности и параллелизма, это может привести к проблемам с производительностью, когда речь идет о приложениях с интенсивной записью, поскольку создание новой копии структуры данных для каждой операции записи может быть дорогостоящим с точки зрения использования памяти и ЦП. циклы. Важно отметить, что CopyOnWriteArrayList полезен только в определенных случаях, когда количество операций записи мало по сравнению с количеством операций чтения, иначе это может вызвать проблемы с памятью при большом объеме данных. копируется при каждой операции обновления. Вот пример использования CopyOnWriteArrayList в Java:
```java
import java.util.concurrent.CopyOnWriteArrayList;

CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
list.add("item1");
list.add("item2");
String firstItem = list.get(0);
list.remove(1);
```
Это создаст новый CopyOnWriteArrayList, добавит к нему два строковых элемента, извлечет первый элемент и удалит второй элемент из списка.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1270. `Что такое Stream в контексте Stream API?`
В контексте Stream API в Java, Stream - это последовательный поток элементов, которые можно получить из источника данных, например, коллекции, массива или файла. Stream можно фильтровать, преобразовывать и обрабатывать параллельно. Stream API был введен в Java 8 и облегчает обработку и анализ больших объемов данных, уменьшает количество кода и позволяет писать более читабельный и функциональный код. Например, вы можете использовать Stream API для фильтрации списка объектов по определенному критерию и получения нового списка, содержащего только отфильтрованные элементы. Работа со Stream API требует различных методов, таких как filter(), map(), reduce() и других, которые можно использовать для обработки данных.


Функция filter() отфильтровывает элементы, которые не соответствуют определенному условию:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
List<Integer> even = numbers.stream()
                             .filter(n -> n % 2 == 0)
                             .collect(Collectors.toList());
System.out.println(even); // [2, 4, 6]
```
Функция map() применяет функцию к каждому элементу потока и создает новый поток с преобразованными элементами:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
List<Integer> squares = numbers.stream()
                               .map(n -> n * n)
                               .collect(Collectors.toList());
System.out.println(squares); // [1, 4, 9, 16, 25, 36]
```
Функция reduce() используется для выполнения агрегирующих операций на элементах потока и возвращает единственный результат:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
int sum = numbers.stream()
                 .reduce(0, (a, b) -> a + b);
System.out.println(sum); // 21
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1271. `Какие отличия между методами map и flatMap?`

В Java методы map() и flatMap() используются в контексте Stream API для обработки коллекций. Основное различие между двумя методами заключается в следующем: 

+ map(): этот метод применяет данную функцию к каждому элементу в потоке и возвращает новый поток, состоящий из результатов. 
+ flatMap(): этот метод похож на map(), но применяет функцию, которая возвращает поток для каждого элемента в исходном потоке. Затем результаты объединяются в единый поток. 

Другими словами, map() преобразует каждый элемент потока в другой элемент, а flatMap() преобразует каждый элемент в поток элементов, а затем объединяет все потоки в один поток. 

Вот пример использования map() для преобразования списка строк в список их длин:
```java
List<String> strings = Arrays.asList("foo", "bar", "baz");
List<Integer> lengths = strings.stream().map(String::length).collect(Collectors.toList());
```

А вот пример использования flatMap() для извлечения отдельных слов из списка предложений:
```java
List<String> sentences = Arrays.asList("hello world", "foo bar", "baz qux");
List<String> words = sentences.stream().flatMap(s -> Stream.of(s.split(" "))).distinct().collect(Collectors.toList());
```

В этом примере flatMap() используется для разделения каждого предложения на поток слов, которые затем объединяются в один поток. Метод Different() используется для удаления дубликатов из результирующего потока.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1272. `Что такое функциональный интерфейс?`

Функциональный интерфейс в Java - это интерфейс, который содержит только один абстрактный метод. Такой интерфейс может использоваться для создания лямбда-выражений, которые позволяют передавать функции в качестве параметров.

В Java 8 и новее в пакете java.util.function определены функциональные интерфейсы, такие как Predicate, Consumer, Supplier, Function, UnaryOperator и т.д. Они предназначены для использования в функциональном программировании и упрощают написание кода, который использует лямбда-выражения и методы ссылки.

Например, функциональный интерфейс Consumer<T> определяет метод accept(T t), который принимает один параметр типа T и не возвращает значения. Это может быть использовано для выполнения каких-либо действий над объектом типа T. Пример:
```java
Consumer<String> printer = str -> System.out.println(str);
printer.accept("Hello, world!");
```
Этот код создает объект printer, который принимает строку в качестве параметра и выводит ее на консоль. Затем он вызывает метод accept с аргументом "Hello, world!".



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1273. `Что такое лямбда?`

Лямбда-выражения (lambda expressions) - это нововведение, которое появилось в Java 8. Лямбда-выражения представляют собой анонимные функции, которые могут использоваться вместо интерфейсов с одним абстрактным методом, таких как интерфейс Function или Comparable. Они позволяют более компактно и лаконично выражать функциональные конструкции, такие как обратные вызовы и потоки данных.

Например, вот как можно использовать лямбда-выражения для сортировки списка строк в порядке возрастания:
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Collections.sort(names, (s1, s2) -> s1.compareTo(s2));
```
Здесь лямбда-выражение (s1, s2) -> s1.compareTo(s2) определяет функцию сравнения строк, которая используется для сортировки списка. Код выше эквивалентен следующему коду с использованием интерфейса Comparator:
```java
Collections.sort(names, new Comparator<String>() {
  public int compare(String s1, String s2) {
    return s1.compareTo(s2);
  }
});
```

Еще пример использования лямбда-выражения для создания объекта функционального интерфейса Runnable:
```java
Runnable r = () -> {
    System.out.println("This is a lambda expression");
};
```
Этот код эквивалентен следующему коду с использованием анонимного класса:
```java
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println("This is an anonymous class");
    }
};
```
Лямбда-выражения также могут принимать параметры и возвращать значения. Например, следующее лямбда-выражение принимает два параметра типа int и возвращает их сумму:
```java
IntBinaryOperator sum = (x, y) -> x + y;
```
Это эквивалентно следующему коду с использованием анонимного класса:
```java
IntBinaryOperator sum = new IntBinaryOperator() {
    @Override
    public int applyAsInt(int x, int y) {
        return x + y;
    }
};
```
В целом, лямбда-выражения позволяют упростить код и улучшить его читабельность.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1274. `Что такое ExecutorService, для чего он нужен и какие реализации есть?`

`ExecutorService` — это интерфейс в пакете Java java.util.concurrent, который предоставляет способ управления пулом потоков для выполнения задач. Он обеспечивает более высокий уровень абстракции по сравнению с базовым интерфейсом Executor, позволяя лучше контролировать выполнение задач. Некоторые из преимуществ использования ExecutorService включают в себя:

+ Повторное использование потоков в пуле, что может снизить накладные расходы по сравнению с созданием новых потоков для каждой задачи. 
+ Ограничение количества потоков, используемых для группы задач, что позволяет избежать нехватки ресурсов и повысить общую производительность системы. 
+ Управление рабочими очередями для управления потоком задач, что может уменьшить конкуренцию и повысить скорость реагирования.

В Java интерфейс ExecutorService имеет несколько реализаций, включая ThreadPoolExecutor, ScheduledThreadPoolExecutor и ForkJoinPool. Чтобы использовать ExecutorService, вы обычно создаете экземпляр реализации, который лучше всего соответствует вашему варианту использования, а затем отправляете ему задачи для выполнения. Например:

```java
ExecutorService executor = Executors.newFixedThreadPool(10);
executor.submit(new RunnableTask());
Future<String> future = executor.submit(new CallableTask());

// делаем какую-то другую работу, пока выполняются задачи

String result = future.get(); // блокируется до тех пор, пока вызываемая задача не завершится
executor.shutdown(); // останавливаем службу-исполнитель, когда закончим

```
В этом примере мы создаем новую реализацию FixedThreadPool максимум с 10 потоками, а затем отправляем в нее RunnableTask и CallableTask. Затем мы можем продолжить другую работу, пока задачи выполняются в фоновом режиме. Мы можем использовать объект Future, возвращаемый CallableTask, для получения результата задачи после ее завершения. Наконец, мы выключаем службу-исполнитель, когда закончим с ней. 

В целом ExecutorService предоставляет мощный и гибкий способ управления потоками и контроля выполнения задач в Java.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1275. `Что такое SOLID?`

SOLID — это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования. Принципы придумал Роберт Мартин в начале двухтысячных, а аббревиатуру позже ввел в обиход Майкл Фэзерс. 

Вот что входит в принципы SOLID:
+ Single Responsibility Principle (Принцип единственной ответственности).
+ Open Closed Principle (Принцип открытости/закрытости).
+ Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков).
+ Interface Segregation Principle (Принцип разделения интерфейса).
+ Dependency Inversion Principle (Принцип инверсии зависимостей).




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1276. `Что такое Single Responsibility Principle (Принцип единственной ответственности)?`

Принцип единственной ответственности (Single responsibility principle) - это принцип объектно-ориентированного программирования, который утверждает, что класс должен иметь только одну причину для изменения, то есть должен быть ответственным только за одну функциональность. Если класс имеет несколько функциональностей, то изменение одной из них может привести к ошибкам в работе других функциональностей, что увеличивает сложность кода и усложняет его поддержку. Данный принцип является частью SOLID-принципов, которые были предложены Робертом Мартином в книге "Чистый код". Цель этих принципов заключается в том, чтобы улучшить качество кода, сделать его более читаемым, поддерживаемым и расширяемым.

Принцип единственной ответственности (SRP) - это принцип объектно-ориентированного проектирования, который гласит, что каждый объект должен иметь только одну ответственность и все его сервисы должны быть направлены исключительно на обеспечение этой ответственности.

Вот несколько примеров использования SRP в Java:

+ Класс Customer может иметь только одну ответственность, например, хранить данные о клиенте и предоставлять методы для работы с этими данными. Класс должен быть разделен на две части: одна для хранения информации о клиенте, а другая для обработки ее.
```java
public class Customer {
    private int id;
    private String name;
    private String address;
    
    // methods for getting and setting customer information
    ...
}

public class CustomerRepository {
    // methods for saving, updating, and deleting customer data
    ...
}
```
+ Класс Employee также может иметь только одну ответственность - чтобы содержать информацию о работнике и методы для работы с этой информацией. Этот класс также может быть разделен на две части - одна для хранения информации, а другая для обработки.
```java
public class Employee {
    private int id;
    private String name;
    private String address;
    private String position;
    
    // methods for getting and setting employee information
    ...
}

public class EmployeeRepository {
    // methods for saving, updating, and deleting employee data
    ...
}
```

+ Класс FileReader может иметь только одну ответственность - чтение данных из файла. Этот класс не должен использоваться для трансформации или обработки данных, он должен выполнять только одну задачу - чтение данных из файла.
```java
public class FileReader {
    public List<String> readFile(String filename) {...}
}
```

Все вышеупомянутые классы имеют только одну ответственность




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1277. `Что такое Open Closed Principle (Принцип открытости/закрытости)?`

Принцип открытости/закрытости (Open/Closed Principle, OCP) - классы должны быть открыты для расширения, но закрыты для модификации. Иными словами, вы должны иметь возможность добавлять новую функциональность без изменения старого кода.

Принцип открытости/закрытости (Open Closed Principle, OCP) в объектно-ориентированном программировании означает, что сущность должна быть открыта для расширения, но закрыта для модификации. Суть заключается в том, что при добавлении новой функциональности к системе не следует изменять существующий рабочий код, вместо этого следует добавлять новый код. Это помогает сделать код более гибким и способствует улучшению его качества и поддерживаемости.

Примером может служить система меню, которая может иметь различный функционал в зависимости от роли пользователя. Вместо того, чтобы изменять код существующих классов, можно написать новый класс, который наследует интерфейс существующего класса и реализует новую функциональность. Такой подход позволяет оставлять существующий код неизменным, в то время как добавление новой функциональности выполняется без нарушения существующего функционала.

Еще одним примером может быть система отправки сообщений, которая может использоваться различными клиентами для отправки различных типов сообщений. Эта система может быть организована с использованием интерфейсов и классов, таким образом, чтобы при добавлении нового типа сообщений не требовалось изменять код уже существующих классов.

Изучение и применение принципа OCP в своих проектах может помочь сделать код более гибким и снизить уровень зависимости между различными частями системы.


Пример на Java:
```java
// Плохой пример нарушает OCP
public class Shape {
  private String type;

  public void draw() {
    if (type.equalsIgnoreCase("circle")) {
      drawCircle();
    } else if (type.equalsIgnoreCase("square")) {
      drawSquare();
    }
  }

  private void drawCircle() {
    // логика рисования круга
  }

  private void drawSquare() {
    // логика рисования квадрата
  }
}

// Хороший пример OCP
public abstract class Shape {
  public abstract void draw();
}

public class Circle extends Shape {
  @Override
  public void draw() {
   // логика рисования круга
  }
}

public class Square extends Shape {
  @Override
  public void draw() {
    // логика рисования квадрата
  }
}
```
В этом примере класс Shape нарушает принцип OCP, так как его метод draw() использует условную конструкцию для определения типа фигуры и выбора правильного метода рисования. Если мы добавим новый тип фигуры, нам нужно будет изменить класс Shape, что нарушает принцип OCP.

Классы Circle и Square следуют принципу OCP, так как они наследуются от абстрактного класса Shape и имеют свою собственную реализацию метода draw(). Если мы захотим добавить новый тип фигуры, нам просто нужно будет создать новый класс, наследуемый от Shape




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1278. `Что такое Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков)?`

Принцип подстановки Барбары Лисков (Liskov's Substitution Principle, LSP) - это принцип SOLID-архитектуры, который гласит, что объекты в программе должны быть заменяемыми их наследниками без изменения корректности программы.

Пример на Java:
```java
class Bird {
  public void fly() {
    // выполнение полета
  }
}

class Duck extends Bird {
  public void swim() {
    // выполнение плавания
  }
}

class Ostrich extends Bird {
  public void run() {
    // выполнение бега
  }
}

public class Main {
  public static void main(String[] args) {
    Bird duck = new Duck();
    duck.fly(); // вызывает метод лета у объекта Duck
    Bird ostrich = new Ostrich();
    ostrich.fly(); // ошибка компиляции, т.к. страус не умеет летать
  }
}
```
Здесь подклассы Bird - это наследники класса Bird, который содержит метод fly(). Однако, Ostrich не умеет летать, так что вызов метода fly() приводит к ошибке. Таким образом, Ostrich не является заменяемым на Bird без нарушения принципа LSP.

Пример, который следует принципу LSP:
```java
class Bird {
  public void move() {
    // выполнение движения
  }
}

class Duck extends Bird {
  public void move() {
    // выполнение полета или плавания
  }
}

class Ostrich extends Bird {
  public void move() {
    // выполнение бега
  }
}

public class Main {
  public static void main(String[] args) {
    Bird duck = new Duck();
    duck.move(); // вызывает метод move() у объекта Duck, это может быть полет или плавание
    Bird ostrich = new Ostrich();
    ostrich.move(); // вызывает метод move() у объекта Ostrich, это бег
  }
}
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1279. `Что такое Interface Segregation Principle (Принцип разделения интерфейса)?`

Принцип разделения интерфейса (Interface Segregation Principle, ISP) является одним из пяти принципов SOLID для объектно-ориентированного программирования. Он заключается в том, что клиенты не должны зависеть от методов, которые они не используют.

Суть этого принципа заключается в том, что интерфейсы должны быть маленькими и специализированными, чтобы клиенты могли использовать только те методы, которые им нужны. Это позволяет избежать создания толстых интерфейсов, которые содержат много методов, из которых на практике используется только небольшая часть.

Вот пример реализации ISP на Java:
```java
interface Vehicle {
    void startEngine();
    void stopEngine();
    void speedUp();
    void slowDown();
}

interface Car extends Vehicle {
    void turnOnAC();
    void turnOffAC();
}

interface Motorcycle extends Vehicle {
    void putHelmetOn();
}
```
В данном примере интерфейс Vehicle содержит четыре метода, которые должны быть реализованы всеми транспортными средствами. Затем мы создаем два специализированных интерфейса - Car и Motorcycle - которые содержат только те методы, которые соответствуют конкретному типу транспортного средства. Это позволяет клиентам использовать только те методы, которые им нужны, вместо того, чтобы иметь доступ к всем методам в одном интерфейсе.

Например, если у нас есть объект car типа Car, то мы можем использовать методы turnOnAC() и turnOffAC() для управления кондиционером, но не можем использовать методы putHelmetOn(), которые присутствуют только в интерфейсе Motorcycle.

Другими словами, этот принцип говорит о том, что интерфейсы должны быть разделены на более мелкие, чтобы клиенты не зависели от методов, которые им не нужны. Это позволяет уменьшить зависимости между компонентами системы и улучшить ее модульность.

Еще пример, который демонстрирует принцип разделения интерфейса в Java:
```java
public interface Printer {
    void print();
}

public interface Scanner {
    void scan();
}

public interface Fax {
    void fax();
}

public class AllInOnePrinter implements Printer, Scanner, Fax {
    public void print() {
        // код для печати
    }

    public void scan() {
        // код для сканирования
    }

    public void fax() {
        // код для отправки факса
    }
}

public class SimplePrinter implements Printer {
    public void print() {
        // код для печати
    }
}
```
Здесь мы определили три интерфейса: Printer, Scanner и Fax, каждый из которых имеет один метод. После этого мы определили два класса: AllInOnePrinter, который реализует все три интерфейса, и SimplePrinter, который реализует только Printer.

Использование такой иерархии делает возможным создание различных комбинаций объектов в зависимости от требований клиента, не затрагивая код, который клиент не использует.

Теперь, если у клиента возникнет потребность только в печати документов, ему можно будет использовать класс SimplePrinter без необходимости создавать экземпляр класса AllInOnePrinter.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1280. `Что такое Dependency Inversion Principle (Принцип инверсии зависимостей)?`

Dependency Inversion Principle (Принцип инверсии зависимостей) - это принцип SOLID, который гласит, что абстракции не должны зависеть от деталей, а детали должны зависеть от абстракций. То есть, высокоуровневые модули не должны зависеть от низкоуровневых, а должны зависеть от абстракций, которые могут быть реализованы как в низкоуровневых, так и в высокоуровневых модулях.

Пример на Java:
```java
public interface MessageSender {
    void sendMessage(String message);
}

public class EmailMessageSender implements MessageSender {
    public void sendMessage(String message) {
        // sending email message
    }
}

public class SmsMessageSender implements MessageSender {
    public void sendMessage(String message) {
        // sending SMS message
    }
}

public class NotificationService {
    private MessageSender messageSender;
    public NotificationService(MessageSender messageSender) {
        this.messageSender = messageSender;
    }
    public void sendNotification(String message) {
        messageSender.sendMessage(message);
    }
}

public class MyApp {
    public static void main(String[] args) {
        MessageSender messageSender = new EmailMessageSender();
        NotificationService notificationService = new NotificationService(messageSender);
        notificationService.sendNotification("Hello World!");
    }
}
```
В этом примере зависимость между NotificationService и MessageSender инвертирована. Мы создаем экземпляр MessageSender вне NotificationService и передаем его через конструктор. Таким образом, NotificationService не зависит от конкретной реализации MessageSender, а зависит только от абстракции MessageSender. Это позволяет нам легко заменять конкретные реализации MessageSender, добавлять новые реализации и тестировать NotificationService независимо от реализации MessageSender.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1281. `Паттерны проектирования (Шаблоны ООП)?`

Паттерны проектирования это повторяемые решения, которые можно применять для решения конкретных проблем в рамках разработки программного обеспечения. Они представляют собой архитектурные решения, которые были протестированы и оптимизированы для конкретных сценариев использования.

Некоторые из наиболее широко используемых паттернов проектирования включают в себя:

+ Паттерн Одиночка (Singleton) - гарантирует, что у класса есть только один экземпляр, и обеспечивает глобальную точку доступа к этому экземпляру.

+ Паттерн Фабричный метод (Factory Method) - определяет интерфейс для создания объектов, но позволяет подклассам выбирать классы для создания.

+ Паттерн Команда (Command) - инкапсулирует запрос в виде объекта, позволяя передавать его как аргумент при вызове методов, модифицировать или отменять запросы, а также сохранять историю запросов.

+ Паттерн Стратегия (Strategy) - определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость.

+ Паттерн Адаптер (Adapter) - преобразует интерфейс одного класса в интерфейс другого класса, который ожидается клиентом.

+ Паттерн Состояние (State) - это паттерн поведения объектов, который позволяет объектам изменять свое поведение в зависимости от своего внутреннего состояния.

+ Паттерн Посредник (Mediator) - является поведенческим шаблоном проектирования, который позволяет уменьшить уровень связности между объектами. 

+ Паттерн Наблюдатель (Observer) - используется для уведомления одним объектом других, подписанных на него объектов об изменениях своего состояния. 

+ Шаблонный метод (Template Method) - это паттерн проектирования, который определяет основу алгоритма в родительском классе, но позволяет дочерним классам переопределить отдельные шаги алгоритма без изменения его структуры. Этот паттерн обеспечивает гибкость проектирования и может использоваться для избежания дублирования кода.

Существуют другие паттерны, которые можно использовать в Java.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1282. `Какие отличия между шаблонами ООП Стратегия и Состояние?`

Паттерны проектирования Стратегия и Состояние (Strategy и State соответственно) имеют некоторые сходства, но в то же время есть и отличия.

Основное сходство заключается в том, что оба паттерна позволяют отделить логику поведения объекта от самого объекта и делегировать эту логику на другие объекты.

Но есть и отличия:

+ Паттерн "Стратегия" позволяет менять алгоритм поведения объекта во время выполнения программы. То есть, каждая конкретная стратегия реализует отдельный вариант алгоритма. Например, разные способы сортировки массива - с помощью quicksort, mergesort и т.д.

+ В паттерне "Стратегия" контекст имеет ссылку на стратегию, а в паттерне "Состояние" контекст имеет состояние.

+ В паттерне "Стратегия" замена стратегий может происходить динамически, а в паттерне "Состояние" замена состояний также происходит динамически, но инициируется извне.

+ Паттерн "Стратегия" часто используется для реализации различных форматов вывода, фильтрации и сортировки данных, а паттерн "Состояние" - для реализации поведения объектов в зависимости от их внутреннего состояния, например, в играх и управлении.

+ Паттерн "Состояние", в свою очередь, позволяет изменять поведение объекта при изменении его состояния. То есть, у каждого состояния объекта свое поведение. Например, в зависимости от состояния заказа (ожидание оплаты, обработка заказа и т.д.), у заказа будет разное поведение.


Другими словами, если в паттерне Стратегия меняется поведение объекта в зависимости от выбранного алгоритма, то в паттерне Состояние поведение объекта меняется в зависимости от его состояния.

Например, в паттерне Состояние можно использовать различные состояния для объекта Заказ: Новый, В обработке, Доставлен и т.д. Каждое состояние будет определять, какие методы вызываются при изменении состояния заказа и как происходит обработка заказа.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1283. `Что такое группировка в БД? Примеры.`

В базах данных группировка (GROUP BY) - это операция, позволяющая группировать строки таблицы по определённым критериям, например, значениям столбца или комбинации значений из нескольких столбцов.

Например, если у вас есть таблица "заказы" с полями "имя продукта", "цена", "количество", "дата", и вы хотите узнать, какой была общая цена продукта за каждый отдельный день, то вы можете использовать операцию GROUP BY по полю "дата":
```sql
SELECT DATE, SUM(price*quantity) as total_price
FROM orders
GROUP BY DATE
```
Также, можно использовать операции агрегации, такие как сумма, среднее, максимальное или минимальное значение в группе. Например:
```sql
SELECT category, COUNT(*) as count, AVG(price) as avg_price, MAX(price) as max_price
FROM products
GROUP BY category
```
В результате получим список категорий товаров с количеством товаров, средней ценой и наибольшей ценой товара в каждой категории.

Группировка данных позволяет получать сводную информацию о больших объемах данных и удобно использовать результаты дальнейшего анализа.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1284. `Что такое ORM и какие есть реализации?`

ORM (Object-Relational Mapping) - это технология программирования, которая позволяет представлять объекты из реляционной базы данных в виде объектов в языке программирования. Таким образом, ORM упрощает работу с базами данных объектно-ориентированных приложений.

В Java есть несколько реализаций ORM. Одна из самых популярных - это Hibernate. Hibernate предоставляет API для работы с базами данных через классы Java, что делает взаимодействие с базой данных более интуитивным и упрощает создание запросов. Другие популярные реализации ORM в Java включают Java Persistence API (JPA) и EclipseLink.

JPA - это стандарт Java для ORM, который определяет API для управления постоянными объектами, используя аннотации или XML-файлы для настройки маппинга объектов на базу данных. Он позволяет устанавливать единую систему управления постоянными объектами для разных ORM-реализаций.

ORM (Object-Relational Mapping) - это технология, которая позволяет связывать объектно-ориентированный код с реляционной базой данных. Она упрощает работу с базой данных, позволяя использовать объекты и методы для работы с данными, вместо использования SQL-запросов напрямую.

Основные реализации ORM для языка Java:

+ Hibernate - самая популярная и широко используемая реализация ORM для языка Java. Пример использования:
```java
@Entity
@Table(name = "employees")
public class Employee {

   @Id
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   @Column(name = "id")
   private int id;

   @Column(name = "name")
   private String name;

   // getters and setters
}
```
+ EclipseLink - еще одна популярная реализация ORM для языка Java, входящая в состав платформы Eclipse. Пример использования:
```java
@Entity
@Table(name = "employees")
public class Employee {

   @Id
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   @Column(name = "id")
   private int id;

   @Column(name = "name")
   private String name;

   // getters and setters
}
```
+ OpenJPA - реализация ORM, разработанная в рамках проекта Apache. Пример использования:
```java
@Entity
@Table(name = "employees")
public class Employee {

   @Id
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   @Column(name = "id")
   private int id;

   @Column(name = "name")
   private String name;

   // getters and setters
}
```
Каждая из этих реализаций ORM обладает своими особенностями и преимуществами, поэтому выбор конкретной реализации зависит от требований к проекту.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1285. `Какие уровни кэширования есть в Hibernate?`

Hibernate поддерживает три уровня кэширования:

+ Первичный кэш (First-Level Cache) - это внутренний кэш, который находится внутри фабрики сессий. Он кэширует объекты, полученные в рамках одной транзакции и позволяет избежать повторной загрузки объектов при повторном запросе к ним. Пример использования первичного кэша:
```java
Session session = sessionFactory.openSession();
MyEntity entity = session.get(MyEntity.class, entityId); // первичный запрос
entity = session.get(MyEntity.class, entityId); // повторный запрос
session.close();
```
+ Кэш второго уровня (Second-Level Cache) - это распределенный кэш, доступный нескольким сессиям в приложении. Он кэширует объекты, полученные при выполнении запросов к базе данных. Пример использования вторичного кэша:
```java
@Entity
@Cacheable
@Table(name = "my_entity")
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class MyEntity implements Serializable {
   // ...
}
```
+ Кэш запросов (Query Cache) - это кэш, который используется для кэширования результатов выполнения запросов в базу данных. Пример использования кэша запросов:
```java
Query query = session.createQuery("from MyEntity where name = :name");
query.setParameter("name", "John");
query.setCacheable(true);
List<MyEntity> entities = query.list();
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1286. `Как происходит запуск Spring Boot приложение?`

Spring Boot приложение можно запустить несколькими способами. Рассмотрим два наиболее распространенных:

+ Запуск через командную строку с помощью Maven:
```java
mvn spring-boot:run
```
При этом Maven соберет проект, выполнит все необходимые действия и запустит приложение.

+ Запуск .jar файла с помощью командной строки:
```java
java -jar myproject.jar
```
При этом необходимо предварительно упаковать приложение в .jar файл.

+ Если используется интегрированная среда разработки (IDE), то Spring Boot приложение можно запустить из нее. Например, в IntelliJ IDEA можно выбрать опцию "Run Application" для запуска приложения.

При запуске Spring Boot приложения, оно автоматически запускает встроенный сервер (по умолчанию это Tomcat или Jetty) и создает ApplicationContext. Если используется специальная аннотация, например, @SpringBootApplication, то автоматически будут сканироваться все классы внутри этого package и выполняться инициализация всех @Bean объектов. Если все прошло успешно, то Spring Boot приложение будет готово к работе и можно будет проверить его работоспособность.

Spring Boot приложения запускаются через класс, помеченный аннотацией @SpringBootApplication, которая включает в себя несколько других аннотаций, таких как @Configuration, @EnableAutoConfiguration, и @ComponentScan. Когда приложение запускается, Spring Boot автоматически сканирует все компоненты и автоматически конфигурирует их на основе определенных правил и конвенций.

Вот пример класса Application, который запускает Spring Boot приложение:
```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```
В этом примере класс Application помечен аннотацией @SpringBootApplication, что обозначает, что этот класс является классом конфигурации Spring Boot приложения. В методе main делается вызов SpringApplication.run, который запускает приложение.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1287. `В чем разница между юнит и интеграционными тестами?`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1288. `Что такое Docker?`
Docker - это программное обеспечение, которое позволяет упаковывать приложения и их зависимости в контейнеры, которые могут быть запущены на любой машине с установленным Docker. Контейнеры Docker предоставляют легковесную виртуализацию, которая позволяет изолировать приложения от окружающей среды и обеспечивает удобную портативность и масштабируемость.

С помощью Docker можно создавать, запускать и распространять контейнеры с приложениями и сервисами, даже если они используют разные операционные системы или различные версии зависимостей. Docker также предоставляет механизмы для управления контейнерами, их масштабирования и обновления.

Одной из ключевых особенностей Docker является то, что контейнеры используют общую операционную систему и ядро, что делает их более легковесными и быстрыми, чем традиционные виртуальные машины. Контейнеры Docker также обеспечивают высокий уровень изоляции, благодаря чему каждый контейнер имеет свое собственное окружение со своими собственными зависимостями и файловой системой.

Docker используется для упрощения процесса развертывания приложений и сервисов в различных средах, облегчения масштабирования и обновления систем и уменьшения затрат на ресурсы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1289. `В чем отличия между Docker и виртуальной машиной?`

Docker и виртуальные машины - это два разных подхода к виртуализации и управлению окружениями приложений.

Виртуальная машина (VM) имитирует полноценный компьютер и позволяет запускать на нем операционную систему и приложения. В отличие от физического компьютера, на котором может быть только одна операционная система, на одном физическом сервере можно запустить несколько виртуальных машин с разными операционными системами.

Docker, с другой стороны, использует концепцию контейнеров для запуска приложений в изолированной среде, которая является частью операционной системы хоста. Контейнеры используют общую операционную систему, что позволяет запускать более легковесные и эффективные приложения, чем при использовании виртуальных машин. Docker-контейнеры также позволяют легко переносить приложения между разными средами, так как они содержат все необходимые зависимости и настройки внутри контейнера.

Основное отличие между Docker и виртуальными машинами заключается в том, что виртуальная машина эмулирует полную операционную систему, включая ядро и ресурсы (процессор, память, хранилище), тогда как Docker использует ресурсы и ядро операционной системы хоста, а контейнеры являются легковесными изолированными процессами, которые работают на базе общей операционной системы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1290. `Каким образом передаются переменные в методы, по ссылке или по значению?`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1291. `Какие отличия между примитивными и ссылочными типами данных?`
В Java есть два типа данных: примитивные типы и ссылочные типы. Примитивные типы представляют основные типы данных, такие как числа и булевы значения. Они хранятся непосредственно в памяти и не имеют методов. Ссылочные типы, с другой стороны, представляют объекты, которые хранятся в куче (heap) и имеют методы. Объекты создаются с помощью оператора "new" и могут содержать значения примитивных типов, а также ссылки на другие объекты. Когда переменная ссылочного типа объявляется, она содержит ссылку на объект на куче.

Основные отличия между примитивными и ссылочными типами данных в Java:

+ Хранение: примитивные типы данных хранятся в стеке (stack), а ссылочные типы данных хранятся в куче (heap).

+ Размер: примитивные типы данных имеют фиксированный размер, а ссылочные типы данных могут иметь переменный размер.

+ Присваивание значения: примитивные типы данных присваиваются значениями, а ссылочные типы данных - ссылками на объекты.

+ Сравнение: примитивные типы данных можно сравнивать с помощью операторов сравнения, а ссылочные типы данных нужно сравнивать с использованием метода equals().

+ Использование: примитивные типы данных используются для хранения простых значений, а ссылочные типы данных используются для представления более сложных структур данных, таких как массивы, списки, карты.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1292. `Как устроена память в JVM?`

Виртуальная машина Java (JVM) имеет несколько различных областей памяти. Общий объем доступной памяти зависит от настроек JVM и характеристик операционной системы. Вот некоторые области памяти в JVM:

+ Heap (Куча): это область памяти, в которой хранятся объекты, созданные вашей программой. Это единственная область памяти, куда могут помещаться объекты, созданные вами, и она автоматически управляется сборщиком мусора, который удаляет объекты, которые больше не используются.

+ Stack (Стек): это область памяти, в которой хранятся локальные переменные, аргументы методов и адреса возврата. Это означает, что когда программа вызывает метод, происходит выделение новых фреймов стека, которые хранят все переменные и аргументы метода. Когда метод завершается, соответствующий фрейм стека удаляется.

+ PermGen/Metaspace: это область памяти, в которой хранятся метаданные, такие как информация о классах и методах, аннотации и т.д. В старых версиях JVM использовался PermGen, но в более новых версиях используется Metaspace.

+ Code Cache: это область памяти, в которой хранятся скомпилированные версии методов.

+ Non-Heap memory (Не куча) - здесь хранятся данные, которые обрабатываются JVM, такие как код класса, метаинформация и т.д.

Это только некоторые из областей памяти в JVM. Каждая область памяти имеет свою специфическую функцию, и понимание того, как они работают, может помочь оптимизировать производительность вашей программы.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1292. `Что такое сборка мусора?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1293. `Многопоточность, параллелизм и асинхронность.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1294. `ия и какие между ними отличия?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1295. `Разница между виртуальными и реальными потоками.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1296. `Future и CompletableFuture. Их назначение и отличия.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1297. `Коллекция HashMap. Устройство и особенности работы.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1298. `ли она потокобезопасной?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1299. `Что такое индексы в базах данных?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1300. `Особенности удаления данных, связанных через FOREIGN KEY.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1301. `Что такое Result Set в JDBC? Особенности его конфигурации.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1302. `Что такое хранимые процедуры и какой способ их вызова через JDBC?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1303. `Что такое SessionFactory в Hibernate?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1304. `Управление уровнями изоляции транзакций в Hibernate.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1305. `Как работает аутентификация и авторизация в Spring Security с использованием JWT токена?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1306. `Виды тестирования в Java.`

В Java могут проводиться различные типы тестирования, включая модульное тестирование, функциональное тестирование, тестирование производительности и интеграционное тестирование.

+ Модульное тестирование (unit testing) - это тестирование отдельных модулей или компонентов программного обеспечения для проверки, соответствует ли каждый модуль требованиям и работает ли он правильно в изоляции от других модулей.

+ Функциональное тестирование (functional testing) - это тестирование, которое проверяет, соответствует ли программное обеспечение функциональным требованиям и способно ли оно выполнять заданные функции.

+ Тестирование производительности (performance testing) - это тестирование, которое оценивает производительность программного обеспечения в различных условиях нагрузки.

+ Интеграционное тестирование (integration testing) - это тестирование, которое проверяет, работают ли различные модули программного обеспечения вместе и интегрированы ли они корректно.

Одним из инструментов для тестирования Java-приложений является фреймворк JUnit, который позволяет проводить модульное тестирование. Для тестирования REST API в Java можно использовать библиотеку REST Assured, которая обеспечивает удобный интерфейс для написания тестов на Java.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1307. `Что такое юнит-тестистирование.`

Юнит-тестирование (англ. unit testing) — техника тестирования программного обеспечения, при которой отдельные блоки кода (юниты) тестируются отдельно от всей программы. Целью таких тестов является проверка корректности работы отдельных блоков кода, а не всего приложения в целом. Юнит-тесты позволяют выявлять ошибки и дефекты на ранних этапах разработки, что упрощает их исправление и снижает вероятность появления серьезных проблем в конечном продукте.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1308. `Ключевое слово final, назначение и варианты использования?`

Ключевое слово final в Java используется для указания, что значение поля (переменной) или метода не может быть изменено после инициализации. Оно может применяться к полям класса, локальным переменным, параметрам методов и классам.

В частности, применение final к полям класса делает их константами - они могут быть инициализированы только один раз при создании объекта и не могут быть изменены после этого. Кроме того, объявление метода как final запрещает его переопределение в подклассах.

Вот некоторые примеры использования ключевого слова final в Java:
```java
public class MyClass {
  final int MAX_VALUE = 100; // константа поля класса
  final double PI = 3.14;
  final String NAME; // константа поля класса, инициализируется в конструкторе
  final int[] ARRAY = {1, 2, 3}; // константа ссылки на массив

  public MyClass(String name) {
    NAME = name;
  }

  public final void myMethod() {
    // код метода
  }
}

public final class MySubClass extends MyClass {
  // MySubClass не может быть подклассом другого класса, потому что он объявлен как final
}
```


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1309. `Значения переменных по умолчанию - что это и как работает?`

В Java значения переменных по умолчанию зависят от их типов. Для типов данных в Java существует набор значений по умолчанию, которые присваиваются переменным при их создании:

0 для числовых типов данных: byte, short, int, long, float, double

'\0' для типа char

false для типа boolean

null для ссылочных типов данных (объектов)

Это означает, что если переменная не была инициализирована явным образом, то ей будет присвоено значение по умолчанию в соответствии с её типом данных.

Например, если мы объявим переменную int a;, то ей будет присвоено значение по умолчанию 0. А если мы объявим переменную String str;, то ей будет присвоено значение по умолчанию null. При попытке обратиться к неинициализированной переменной в Java произойдет ошибка компиляции.

Если требуется задать переменной другое значение по умолчанию, то можно использовать оператор присваивания при ее создании. Например, int a = 10; задаст переменной a начальное значение 10.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1310. `Иерархия Collections API`

![CollectionsHierarchy](images/java/CollectionsHierarchy.png)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1311. `Иерархия интерфейсов коллекций java`
![CollectionsHierarchy](images/java/Collectionsinterfaces.png)

[ссылка на картинку большего размера](https://disk.yandex.ru/i/bEJWKe4nzoXyrA)



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1312. `Класс TreeMap - какая структура данных и алгоритмические сложности базовых операций`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1313. `Иерархия исключения в Java, их типы и способы их обработки.` 
В Java иерархия исключений представлена классом Throwable, который имеет два подкласса: Error и Exception.

![exceptionsInJavaHierarchy](images/java/exceptionsInJavaHierarchy.png)

Класс Error представляет ошибки, связанные с внутренними проблемами системы, которые обычно не могут быть исправлены, например, OutOfMemoryError.

Класс Exception представляет ошибки, которые обычно могут быть обработаны программой, например, IOException. Класс Exception имеет много подклассов, каждый из которых представляет конкретную ошибку, например, NullPointerException, IllegalArgumentException, ArrayIndexOutOfBoundsException и т.д.

Error обозначает серьезные проблемы, которые происходят во время выполнения программы и которые не могут быть восстановлены. Обработка Error не предполагается.

Exception обозначает проблемы, которые могут быть обработаны в коде. Они делятся на две категории: Checked Exceptions и Unchecked Exceptions. Checked Exceptions вынуждают производить обработку в коде, а Unchecked Exceptions не вынуждают обязательно обрабатываться.

RuntimeException - это небольшая подкатегория Unchecked Exceptions, которая указывает на ошибки, которые могут произойти в результате неправильной работы кода, к примеру, деление на ноль.

Для обработки исключений в Java используют блоки try, catch и finally. Блок try содержит код, который может породить исключение, а блок catch содержит код обработки исключения. Блок finally выполняется в любом случае, независимо от того, было ли исключение порождено или нет. Можно также использовать конструкцию throw для явного выбрасывания исключения в определенных ситуациях.

Пример использования блоков try и catch в Java:
```java
try {
  // Код, который может породить исключение
} catch (ExceptionType e) {
  // Код обработки исключения
}
```
Также можно использовать несколько блоков catch для обработки разных типов исключений:

```java
try {
  // Код, который может порождать исключения
} catch (ExceptionType1 e) {
  // Обработка исключения типа 1
} catch (ExceptionType2 e) {
  // Обработка исключения типа 2
} catch (Exception e) {
  // Общая обработка исключения
} finally {
  // Код который сработает в любом случае
```



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1314. `Что делает ключевое слово volatile?`

Ключевое слово volatile в Java используется для гарантии, что значения полей объектов будут согласованы между потоками и не будут кэшироваться в рантайме. Кэширование может привести к непредсказуемым результатам при доступе к изменяемым полям из разных потоков исполнения.

Когда поле объявлено как volatile, Java гарантирует, что доступ к этому полю со стороны разных потоков будет согласован и последовательным. Это обеспечивает правильную синхронизацию между потоками, когда один поток записывает в это поле, а другой поток его читает.

Например:
```java
public class MyRunnable implements Runnable {
    private volatile boolean running;

    public void run() {
        while (running) {
            // делаем что-то здесь
        }
    }

    public void stop() {
        running = false;
    }
}
```
Здесь мы объявляем поле running как volatile, чтобы гарантировать, что его значение будет согласовано между потоками. Мы используем это поле для остановки выполнения потока в методе run(), проверяя его значение на каждой итерации цикла. Метод stop() устанавливает значение running в false, чтобы остановить цикл while в методе run().

Важно отметить, что использование ключевого слова volatile не гарантирует атомарности операций чтения и записи. Для решения этой проблемы можно использовать блокировки.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1315. `Что такое Future? Что такое CompletableFuture? Какие задачи они решают?` 

Future и CompletableFuture - это классы из пакета java.util.concurrent, которые позволяют делегировать выполнение асинхронных задач на другой поток, не блокируя при этом главный поток. Они предоставляют возможность получить результат выполнения задачи в будущем, в виде объекта Future.

Класс Future представляет собой обертку, которая содержит результат асинхронной операции, но не блокирует поток, который вызвал эту операцию. Для получения результата можно использовать метод get() объекта Future, который блокирует поток до того момента, пока результат не станет доступным.

Класс CompletableFuture построен поверх Future и предоставляет более широкие возможности для управления асинхронными задачами. Он позволяет объединять и комбинировать несколько асинхронных операций и определять цепочки операций, которые будут выполнены, когда все результаты будут готовы. CompletableFuture также поддерживает Callback функции, которые вызовутся после того, как операция закончится.

Использование Future и CompletableFuture может значительно улучшить производительность приложения, позволяет более эффективно использовать ресурсы компьютера и обеспечивать отзывчивость приложения.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1316. `Что такое нормальная форма БД? Виды и мотивировки приведения БД к нормальной форме?`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1317. `Что такое JDBC?`
JDBC (Java Database Connectivity) - это API , которое позволяет Java-приложениям работать с базами данных. JDBC содержит интерфейсы и классы, которые позволяют Java-приложениям установить соединение с базой данных, отправлять SQL-запросы и осуществлять манипуляции с данными. JDBC позволяет подключаться к различным СУБД, включая Oracle, MySQL, Microsoft SQL Server и др.

Пример использования JDBC для получения данных из базы данных:
```java
import java.sql.*;

public class Example {
  public static void main(String[] args) {
    try {
      // Установка соединения с базой данных
      Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/mydatabase", "username", "password");
      
      // Создание запроса и выполнение его
      Statement stmt = conn.createStatement();
      ResultSet rs = stmt.executeQuery("SELECT * FROM customers");
      
      // Обработка результатов запроса
      while (rs.next()) {
        String name = rs.getString("name");
        int age = rs.getInt("age");
        System.out.println(name + " " + age);
      }
      
      // Закрытие соединения
      rs.close();
      stmt.close();
      conn.close();
    } catch (Exception e) {
      System.out.println("Error: " + e.getMessage());
    }
  }
}
```
Этот код подключается к MySQL базе данных с именем mydatabase и получает данные из таблицы customers.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1318. `Что такое statement в контексте JDBC? Виды и отличия.`

В контексте JDBC, Statement - это интерфейс для выполнения SQL-запросов к базе данных. Он позволяет создавать объекты для выполнения запросов SQL на основе подключения к базе данных. В JDBC существует три типа Statement:

+ Statement – простой объект для выполнения запросов без параметров.

+ PreparedStatement – позволяет создавать запросы с параметрами, что облегчает их использование и предотвращает SQL-инъекции.

+ CallableStatement – используется для вызова хранимых процедур в базе данных.

Основное отличие PreparedStatement от Statement заключается в том, что PreparedStatement запоминает SQL-запрос при своём создании и присваивает значения параметров только при его выполнении, делая его производительнее и безопаснее.

Для использования Statement необходимо создать объект, используя методы Connection.createStatement() или Connection.prepareCall(), затем использовать методы объекта Statement для выполнения запросов и получения результатов.

Пример создания объекта Statement и выполнения запроса SELECT с использованием него:
```java
import java.sql.*;

public class Example {
   public static void main(String[] args) {
      Connection conn = null;
      Statement stmt = null;
      ResultSet rs = null;

      try {
         conn = DriverManager.getConnection("jdbc:mysql://localhost/test?" +
                                    "user=misha&password=secret");

         stmt = conn.createStatement();
         rs = stmt.executeQuery("SELECT * FROM users");

         while (rs.next()) {
            int id = rs.getInt("id");
            String name = rs.getString("name");

            System.out.println("ID: " + id + ", Name: " + name);
         }
      } catch (SQLException ex) {
         ex.printStackTrace();
      } finally {
         try {
            if (rs != null) {
               rs.close();
            }
            if (stmt != null) {
               stmt.close();
            }
            if (conn != null) {
               conn.close();
            }
         } catch (SQLException ex) {
            ex.printStackTrace();
         }
      }
   }
}
```
Этот пример создает объект Statement с помощью метода createStatement()



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1319. `Что такое Hibernate? Что такое JPA? Их отличия.`

`Hibernate` - это фреймворк для объектно-реляционного отображения (ORM), который позволяет связывать объекты Java с таблицами в базе данных. Он упрощает взаимодействие между приложением и базой данных, предоставляя механизм для выполнения операций CRUD (создание, чтение, обновление, удаление). Hibernate также устраняет необходимость писать ручные SQL-запросы, что делает процесс разработки более быстрым и эффективным.

`JPA (Java Persistence API)` - это стандарт Java EE для ORM , который определяет интерфейсы и классы для управления постоянными объектами. JPA предоставляет программистам удобный способ описывать объектно-реляционное отображение с помощью аннотаций или XML-конфигурации. Он позволяет использовать ORM на уровне абстракции, который похож на реляционную базу данных.

Hibernate и JPA тесно связаны друг с другом. JPA является стандартом для ORM, предоставляя API для работы с объектами и сущностями. Hibernate, с другой стороны, является одной из реализаций этого стандарта, но позволяет использовать дополнительные функции и возможности, не предусмотренные JPA. Поэтому, можно сказать, что Hibernate - это более мощный ORM-фреймворк, который частично включает в себя JPA.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1320. `Что такое N+1 SELECT проблема?`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1321. `Что такое REST API?` 

`REST API (Representational State Transfer API)` - это архитектура API, которая использует HTTP-методы (GET, POST, PUT, DELETE) для передачи и манипулирования ресурсами на удаленном сервере. Она основывается на принципах REST (REpresentational State Transfer), которые были определены Роем Филдингом. REST API использует URI (Uniform Resource Identifier) для определения ресурса, к которому обращается запрос, и может принимать и возвращать данные в различных форматах, таких как JSON, XML и другие.

REST API позволяет разработчикам создавать гибкие и масштабируемые приложения, обеспечивая возможности манипулирования ресурсами на удаленном сервере. Кроме того, REST API может быть легко кэширован и масштабирован, что позволяет предоставлять быстрый доступ к данным и уменьшить нагрузку на сервер.


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1321. `Отличие Aerospike от Redis`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1322. `Какие существую функциональные фичи в Java`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1323. `Отличие Unmodifiable от Immutable`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1324. `Функциональные интерфейсы`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1325. `Метод reduce() `


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1326. `чем его преимущество перед циклом`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1327. `HashTable и ConcurrentHashMap - отличия и что эффективнее `


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1328. `Классы мониторов для мониторинга многопоточки`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1329. `retry block`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1330. `Шаблон Builder - что такое и для каких задач`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1331. `Что будет если конструктор класса будет private , и зачем это нужно`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1332. `Singleton - почему его называют анти-паттерн`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1333. `Как обойтись без synchronized в многопоточке на Singleton”е`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1334. `Что такое Double check`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1335. `Stateful и Stateless сервисы`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1336. `Optimistic vs. Pessimistic locking`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1337. `Ключевое отличие SQL vs NoSQL DBs`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1338. `Возможно ли изоляция транзакций в распределенных системах`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1339. `Доказать CAP теорему`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1340. `Почему нет смысла гнаться  за 100% или 99.999% надежности, если есть 99.99%`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1341. `Какие минусы Rest в высоконагруженных системах?`
Есть несколько минусов у REST API в высоконагруженных системах:

+ REST API взаимодействует с HTTP протоколом, который не подходит для решения всех задач.

+ REST API требует большого количества запросов к серверу для получения всей необходимой информации, что может приводить к задержкам.

+ REST API не всегда может гарантировать безопасность при передаче конфиденциальной информации.

+ REST API может быть трудным в использовании для неопытных разработчиков.

+ Разработка и поддержка REST API может быть трудоемким процессом, особенно при работе с большим количеством конечных точек.

+ REST API может оказаться неэффективным при работе с большим количеством пользователей, особенно при необходимости частой передачи больших объемов данных.

+ Узкие места в производительности: Rest API может иметь узкие места в производительности из-за проблем с сетью, нагрузкой на БД и других причин. В таких случаях может потребоваться более сложная архитектура, как, например, микросервисная архитектура.

+ Проблемы с безопасностью: Rest API может стать уязвимым для атак, таких как атаки DDoS или инъекции SQL/NoSQL. Однако, правильное проектирование и реализация Rest API может снизить вероятность таких атак.

+ Сложность масштабирования: Если Rest API не был проектирован с учетом масштабируемости, то его масштабирование может стать сложной задачей.

+ Проблемы с совместимостью: Rest API предоставляют некоторые ограниченные возможности для изменения структуры данных, что может привести к проблемам совместимости при обновлении API в дальнейшем.

Однако следует помнить, что REST API все же является одним из наиболее распространенных и удобных методов взаимодействия с сервером, и эти ограничения могут быть разрешены с помощью правильной оптимизации и скорректированных настроек.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1342. `Что такое JRPC`



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1343. `Процесс от пуша кода до продакшена`

От пуша кода до продакшена процесс разработки и доставки приложения может варьироваться в зависимости от выбранной методологии и используемых инструментов. Ниже описан общий высокоуровневый процесс, который может быть адаптирован к конкретным потребностям проекта:

+ Разработка приложения – написание и отладка кода, тестирование функциональности

+ Создание и отправка Pull Request – создание новой ветки в Git-репозитории приложения, разработка отдельной функциональности или исправление ошибки, отправка Pull Request для рассмотрения изменений

+ CI/CD – при наличии CI/CD системы, ее настройка позволяет автоматизировать процесс сборки, тестирования и доставки приложения в продакшен. Обычно, на этапе CI проверяется работоспособность кода на тестовом окружении, а на этапе CD происходит доставка приложения на продакшен

+ Code Review – внесение изменений в код приложения на основе комментариев и рекомендаций, которые были оставлены после Code Review

+ Доставка в продакшен – когда изменения получают подтверждение и сливаются в основной кодовую базу, происходит доставка приложения на продакшен. Этот этап также может быть автоматизирован, используя CI/CD системы

+ Мониторинг и сбор обратной связи – отслеживание производительности приложения, сбор обратной связи от пользователей и разработка новых функциональных изменений





<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1344. `Сколько нужно instance-ов чтобы обеспечить CI\CD`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1345. `Kлючевое слово final`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1346. `Класс String`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1347. `Передача значение по ссылке/по значению`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1348. `LinkedHashSet`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1349. `HashSet`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1350. `Kласс Phaser`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1351. `Понятие монитора`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1352. `Что такое реляционная база данных`
Реляционная база данных (RDBMS) - это тип базы данных, в котором данные хранятся в виде набора связанных таблиц. В реляционной базе данных каждая таблица представляет собой набор строк и столбцов, где каждый столбец представляет отдельный атрибут или поле данных, а каждая строка представляет отдельную запись или элемент данных. Реляционные базы данных обычно используют структурированный язык запросов (SQL) для извлечения, вставки и обновления данных.

Примеры реляционных баз данных включают в себя MySQL, PostgreSQL, Oracle и Microsoft SQL Server.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1353. `Команда GROUP BY в SQL`
Команда GROUP BY в SQL используется для группировки результатов запроса по одному или нескольким столбцам таблицы. Вот несколько примеров, демонстрирующих использование этой команды:

Пример 1: Группировка по одному столбцу
```sql
SELECT column1, SUM(column2)
FROM table
GROUP BY column1;
```
Данная команда выберет значения из первого столбца, а затем сгруппирует результаты по этому столбцу. Затем она выполнит функцию SUM для значения всех записей второго столбца, относящихся к каждому уникальному значению из первого столбца.

Пример 2: Группировка по нескольким столбцам
```sql
SELECT column1, column2, SUM(column3)
FROM table
GROUP BY column1, column2;
```sql
Этот пример группирует результаты запроса по двум столбцам. Затем он выполняет функцию SUM для значения всех записей третьего столбца, относящихся к каждой уникальной комбинации значений из первого и второго столбцов.

Пример 3: Использование HAVING для фильтрации результатов группировки
```sql
SELECT column1, SUM(column2)
FROM table
GROUP BY column1
HAVING SUM(column2) > 100;
```
Этот пример группирует результаты запроса по первому столбцу, выполняет функцию SUM для значения всех записей второго столбца и затем фильтрует результаты, выбирая только те, для которых сумма второго столбца больше 100.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1354. `Для чего используется Spring Boot`
Для чего используется Spring Boot Spring Boot — это популярная платформа с открытым исходным кодом для создания приложений Java. Он был разработан для упрощения и ускорения процесса создания готовых к работе автономных приложений на основе Spring. Spring Boot предоставляет множество функций и преимуществ, в том числе:

+ Автоматическая настройка: Spring Boot может автоматически настроить приложение Spring на основе зависимостей, включенных в проект. Это может сэкономить разработчикам значительное количество времени и усилий при настройке нового проекта или внесении изменений в существующий проект. 
+ Встроенный веб-сервер: Spring Boot включает встроенный веб-сервер, поэтому разработчикам не нужно отдельно настраивать веб-сервер при развертывании приложения. 
+ Готовые к работе функции: Spring Boot предоставляет готовые к работе функции, такие как проверки работоспособности и метрики. Это означает, что разработчики могут сосредоточиться на создании основных функций своего приложения, не беспокоясь об инфраструктуре. 
+ Простая интеграция: Spring Boot легко интегрируется с другими библиотеками, такими как Spring Data, Spring Security и Spring Cloud. Это упрощает добавление дополнительных функций в приложение по мере его развития.

В целом, Spring Boot — это мощная среда для создания приложений Java, обеспечивающая упрощенную разработку и готовые к работе функции.




<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1355. `Области видимости бинов в Spring`
В Spring Framework существуют различные области видимости бинов, определяющие, как много экземпляров бина будет создано и как долго он будет жить. Некоторые из наиболее распространенных областей видимости бинов в Spring:

+ Singleton - по умолчанию все бины в Spring являются синглтонами, то есть создается только один экземпляр бина для контейнера. Этот бин существует до тех пор, пока контейнер не будет уничтожен.

+ Prototype - при каждом обращении к контейнеру создается новый экземпляр бина. Этот тип области видимости особенно полезен в случаях, когда бину необходимо создаваться и уничтожаться каждый раз при обращении к нему.

+ Request - бин, созданный в области запроса, существует только в течение одного HTTP-запроса и уничтожается после его завершения.

+ Session - бин, созданный в области сессии, существует в течение жизни HTTP-сессии и уничтожается после ее завершения.

+ Global session - аналогично с областью видимости сессии, но в контексте портлетов.

+ Application - бин создается один раз при запуске приложения и существует до его завершения.

Как правило, каждый бин может иметь только одну область видимости, но можно использовать прокси-объекты, чтобы создавать бины, которые имеют область видимости, отличную от области видимости оригинального бина.

96. Что такое socket
"Socket" - это механизм коммуникации между процессами, который используется для обмена данными между сервером и клиентом. Сокеты могут быть использованы для отправки и получения информации, такой как текстовые сообщения, файлы или потоковые данные. Для создания сокетов в Java используются классы java.net.Socket и java.net.ServerSocket. Когда клиент хочет установить соединение с сервером, он создает экземпляр класса java.net.Socket и указывает адрес и порт сервера, а затем использует этот сокет для отправки и получения данных. Сервер на своей стороне создает экземпляр класса java.net.ServerSocket и ждет, пока клиент не подключится. Когда клиент подключается, сервер принимает соединение, создает новый сокет для обмена данными с клиентом и продолжает слушать новые соединения.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1352. `шаблон проектирование "Стратегия"`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1353. `тип данных short`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1354. `short vs class Short`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1355. `обобщения в Java (Generics)`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1356. `класс ArrayList (динамический массив)`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1357. `класс LinkedList (связный список)`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1358. `класс TreeSet (красно-чёрное дерево)`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1359. `интерфейс Сomparable`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1360. `протокол HTTP`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1361. `базы данных (нормализация)`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1362. `написание SQL запроса (INNER JOIN)`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1363. `принципы ООП`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1364. `отличия примитивных типов данных от ссылочных`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1365. `алгоритмы поиска элементов по значению в массивах и их сложности`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1366. `сложность поиска элемента по ключу в HashMap`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1367. `класс CompletableFuture`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1368. `шаблоны проектирования`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1369. `области видимости бинов в Spring`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1370. `что такое Bean в Spring`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1371. `аннотация @Autowired в Spring`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1372. `аннотация @ComponentScan в Spring`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1373. `ACID`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1374. `propagation уровни в транзакциях`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1375. `что такое mock в тестировании`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1376. `что такое метод clone()`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1377. `чем отличается наследование от композиции`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1378. `какие механизмы полиморфизма реализованы в Java`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1379. `что такое неизменяемые классы`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1380. `класс LinkedList`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1381. `чем отличается волатильность от атомарности`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1382. `что такое реляционная модель хранения данных`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1383. `какие состояния объекта есть в Hibernate`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1384. `N + 1 проблема в Hibernate`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1385. `уровни пропагации транзакций в Spring Data` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1386. `жизненный цикл Bean в Spring`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1387. `что такое идемпотентный метод в REST API`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1388. `CAP теорема`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1389. `как устроена HashMap`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1390. `какие участки памяти есть в JVM`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1391. `где хранятся статические методы и переменные`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1392. `где хранятся объекты`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1393. `что такое "мусор" с точки зрения JVM`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1394. `чем отличается СoncurrentHashMap от Hashtable`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1395. `механизм CAS`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1396. `что такое Stream API`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1397. `что такое сериализация`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1398. `ключевое слово transient`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1399. `какие группы команд есть в SQL`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1400. `чем отличается INNER JOIN от RIGHT JOIN`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1401. `уровни изоляции транзакций`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1402. `ACID`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1403. `что такое Servlet`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1404. `как происходит обработка запроса (HttpServlet)`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1405. `Метод hashcode`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1406. `Ключевое слово transient`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1407. `Чем отличается сериализация от маршалинга?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1408. `Сложность поиска элемента по ключу в HashMap`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1409. `Механизм CAS`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1410. `Optimistic vs pessimistic lock в Hibernate`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1411. `Потокобезопасные коллекции в Java`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1412. `Коллекция LinkedHashMap`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1413. `Что лежит "под капотом" parallelStream()?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1414. `Чем отличается Future от CompletableFuture?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1415. `Способы оптимизации запросов в БД в БД`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1416. `Сложность поиска элемента по индексу`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1417. `Чем отличается JOIN от UNION?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1418. `Проблема N+1 в Hibernate`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1419. `Уровни кэширования в Hibernate`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1420. `Что такое ApplicationContext в Spring?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1421. `Аннотация @Transactional в Spring Data`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1422. `Виды тестирования`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1423. `Статические методы`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1424. `Принципы ООП`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1425. `Что такое наследование?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1426. `Почему множественное наследование запрещено?` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1427. `Как устроена HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1428. `Что такое коллизия hashcode в HashMap?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1429. `Что такое lambda и функциональная парадигма?` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1430. `Что такое функциональный интерфейс?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1431. `Что такое stream?` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1432. `Применение методов Stream API` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1433. `Параллельные стримы и ForkJoinPool` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1434. `Отличие между ForkJoinPool и FixedThreadPool`  


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1435. `Что такое ExecutorService?` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1436. `Интерфейс Callable`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1437. `Что такое CompletableFuture?` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1438. `Какие участки памяти есть в JVM?` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1439. `Нормализация БД`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1440. `Уровни изоляции транзакций`  


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1441. `Инициализация бинов в Spring` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1442. `Что такое mock?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1443. `Аннотация @Transactional в Spring Data` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1444. `Q&A in 1.`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1445. `ООП vs функциональное программирование`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1446. `Композиция vs наследование`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1447. `Множественное наследование`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1448. `SOLID - interface segregation`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1449. `SOLID - dependency inversion` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1450. `Ковариантность типов` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1451. `Неизменяемые классы`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1452. `Коллекции - TreeMap`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1453. `Коллекции - LinkedList`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1454. `Stream API - метод peek()`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1455. `На чём основан forEach()`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1456. `Примеры функциональных интерфейсов в Java`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1457. `Участки памяти в JVM`
JVM (Java Virtual Machine) разделяет память на участки, каждый из которых имеет свое назначение и предназначен для выполнения специальных задач:

+ Heap – это область памяти, где хранятся объекты Java. Она автоматически выделяется и освобождается сборщиком мусора, что позволяет упростить процесс управления памятью в Java.

+ Методический стек (Method Area) – это область памяти, где хранятся все классы, методы, переменные, статические поля, и другие сведения о программе.

+ Native Heap – это область памяти, где хранятся объекты, созданные в коде, который выполняется за пределами JVM (например, приложения, написанные на C/C++).

+ Stack – это область памяти, где хранятся локальные переменные и стек вызовов для каждого потока.

+ PC Register – это область памяти, где хранится текущее значение коммуникатора (Program Counter), который указывает на следующую инструкцию, которую нужно выполнить в JVM.

+ Garbage collection – это технология, которая автоматически удаляет неиспользуемые объекты из памяти, освобождая пространство для новых объектов.

+ Direct Memory – это область памяти, которая используется для работы с буферами, созданными в коде на языке, который выполняется за пределами JVM.

Эти участки памяти позволяют управлять памятью в Java и обеспечивают эффективное выполнение кода на JVM.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1458. `Где хранятся статические методы в памяти JVM`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1459. `Оптимизация SQL запросов`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1460. `Оптимизация работы Hibernate`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1461. `Нарушение нормализации БД с целью увеличения производительности`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1462. `Уменьшение времени ответа на запрос`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1463. `Организация процесса СI/CD`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1464. `Проблемы при горизонтальном масштабировании`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1465. `Как устроена HashMap?` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1466. `Отличие примитивных типов данных от ссылочных`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1467. `Чем обусловлен диапазон допустимых значений "примитивов"?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1468. `Что такое лямбда?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1469. `С каким функциональным интерфейсом "работает" метод filter?` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1470. `Что делает метод peek()?` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1471. `Применение метода anyMatch() в Stream API` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1472. `Задача по многопоточности` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1473. `Как работает механизм CAS?` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1474. `Применение принципа инкапсуляции в реальных системах`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1475. `Партиционирование в БД` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1476. `Нормальные формы БД` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1477. `Третья нормальная форма`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1478. `Что такое ORM?` 
ORM (Object-Relational Mapping) это технология программирования, которая связывает базу данных и приложение с помощью объектно-ориентированного подхода. С помощью ORM можно обращаться к данным в базе данных, не пиша SQL-запросы. ORM предоставляет объекты, которые соответствуют отдельным таблицам в базе данных и позволяет работать с этими объектами, как с обычными объектами в приложении.

Примеры ORM в Java: Hibernate, JPA (Java Persistence API), EclipseLink, MyBatis и др. Hibernate является одним из наиболее популярных ORM-фреймворков в Java. Он предоставляет удобный API для работы с базой данных и поддерживает большое количество баз данных, вORM (Object-Relational Mapping) - это технология, которая позволяет представлять отношения между объектами в программировании на языке высокого уровня, как отношения между таблицами в РСУБД (Реляционной Системе Управления Базами Данных).

ORM позволяет использовать объектно-ориентированный подход к работе с базами данных, не привязываясь к конкретной РСУБД и SQL. Объекты в приложении могут быть маппированы на соответствующие таблицы в базе данных, поля объектов - на столбцы таблиц, а методы объектов - на SQL-запросы. ORM-система сама заботится о создании запросов к базе данных и преобразовании результатов запросов в объекты.

Примеры ORM-фреймворков для Java:

+ Hibernate - самый популярный ORM-фреймворк для Java

+ Java Persistence API (JPA) - стандарт Java EE для работы с базами данных, включающий в себя ORM-функциональность. Реализации JPA включают EclipseLink, OpenJPA и Hibernate.

+ MyBatis - ORM-фреймворк, который позволяет работать с базами данных через SQL-запросы, при этом предоставляет маппинг результатов запросов на объекты.

Это лишь некоторые примеры, существует множество ORM-фреймворков для Java, каждый со своими особенностями и функциональностью.



<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1479. `Кэширование в ORM?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1480. `Какую проблему решает Spring Framework?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1481. `Что такое Stream?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1482. `Что такое параллельный Stream?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1483. `Что такое ExecutorService и его имплементации?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1484. `Что такое асинхронность?` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1485. `Что такое CompletableFuture?` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1486. `В чем преимущества композиции в ООП?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1487. `К чему может привести нарушение принципов SOLID?` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1488. `Какие существуют имплементации интерфейса List?` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1489. `Когда стоит использовать LinkedList?` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1490. `Жизненный цикл Bean.` 


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1491. `Как передаются параметры в Java(по ссылке или по значению)?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1492. `Какие есть методы у класса Object?`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1493. `Как происходит сравнение объектов в Java`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1494. `Какой “контракт” между методами equals() и hashcode()`


<DIV ALIGN="RIGHT">
    <B><A HREF="#">↥ ВЕРНУТЬСЯ К НАЧАЛУ</A></B>
</DIV>  

## 1495. `К какому принципу ООП относится переопределение методов?`

Переопределение методов в Java относится к принципу полиморфизма объектно-ориентированного программирования. Полиморфизм позволяет использовать объекты с разной реализацией, используя для этого один и тот же интерфейс. Переопределение методов в Java позволяет определить новую реализацию метода в подклассе наследующем метод из родительского класса. Это позволяет подклассу изменять поведение унаследованного метода для соответствия своим потребностям, в то время как другие методы в подклассе могут сохранять унаследованный функционал из родительского класса. Обратите внимание, что для успешного переопределения метода в подклассе, имя, параметры и тип возвращаемого значения должны полностью совпадать с методом в родительском классе, иначе это будет не переопределение, а перегрузка метода. Ключевое слово @Override используется для явного указания, что данный метод является переопределенным методом.

1496. Что такое immutable объекты?
1497. Как устроена HashMap?
1498. Что является монитором при работе с методом wait?
1499. С каким функциональным интерфейсом мы работаем в методе map()?
1500. Как работает связка try-catch-finally?
1501. Написание SQL запроса
1502. Как работает fetch type LAZY в Hibernate?
1503. Что такое Named Query в Hibernate?
1504. Что такое BeanPostProcessor?
1505. Что такое bean scope и какие виды существуют?
1506. Что такое IoC и DI?
1507. Чем отличается обычный объект от Bean?
1508. Жизненный цикл бина в Spring
1509. Что такое M1. 
1510. Ключевое слово final, назначение и варианты использования? 
1511. Значения переменных по умолчанию - что это и как работает? 
1512. Иерархия Collections API
1513. Класс TreeMap - какая структура данных и алгоритмические сложности базовых операций
1514. Иерархия исключения в Java, их типы и способы их обработки. 
1515. Что делает ключевое слово volatile?
1516. Что такое Future? Что такое CompletableFuture? Какие задачи они решают? 
1517. Что такое нормальная форма БД? Виды и мотивировки приведения БД к нормальной форме?
1518. Что такое JDBC?
1519. Что такое statement в контексте JDBC? Виды и отличия.
1520. Что такое Hibernate? Что такое JPA? Их отличия.
1521. Что такое N+1 SELECT проблема? 
1522. Что такое REST API?  
1523. Каким образом передаются переменные в методы, по ссылке или по значению?
1524. Какие отличия между примитивными и ссылочными типами данных?
1525. Как устроена память в JVM?
1526. Что такое сборка мусора?
1527. Многопоточность, параллелизм и асинхронность. Определения и какие между ними отличия?
1528. Разница между виртуальными и реальными потоками. 
1529. Future и CompletableFuture. Их назначение и отличия.
1530. Коллекция HashMap. Устройство и особенности работы. Является ли она потокобезопасной?
1531. Что находится под буквой L в принципах SOLID?
1532. Что такое индексы в базах данных?
1533. Особенности удаления данных, связанных через FOREIGN KEY.
1534. Что такое Result Set в JDBC? Особенности его конфигурации.
1535. Что такое хранимые процедуры и какой способ их вызова через JDBC?
1536. Что такое SessionFactory в Hibernate?
1537. Управление уровнями изоляции транзакций в Hibernate.
1538. Как работает аутентификация и авторизация в Spring Security с использованием JWT токена?
1539. Что такое юнит-тестирование?
1540. Абстрактный класс и интерфейс
1541. модификатор default
1542. equals и hashcode
1543. Коллизии hashcode
1544. Все еще коллизия 
1545. heap и stack
1546. Задачка на string pool
1547. List и Set
1548. О-большая 
1549. Связи map и set
1550. capacity
1552. load factor
1553. потеря объекта в хэшмапе
1554. Что делал с многопоточностью?
1555. Синхронайз 
1556. Race condition, Dead lock
1557. опыт со Spring
1558. Scope бинов в Spring
1559. Создание singleton-бина
1560. Primary в Spring
1561. Transactional и транзакции
1562. ACID
1563. GROUP BY
1564. Задача по БД
1565. Индексы
1566. SOLID
1567. Тестирование
1568. Сценарии тестирования
1569. Maven или Gradle?
1570. Команды в Git
1571. Класс Object, его методы
1572. Hashcode
1573. Стирание типов
1574. Maven, плагин менеджмент 
1575. Транзитивность
1576. Многопоточность
1577. Как создать поток
1578. Хитрость от кандидата
1579. Мютекс, монитор, семафор
1580. Volatile 
1581. Deadlock, Race condition
1582. Мое объяснение Race condition
1583. Неоднозначность бинов в Spring
1584. Виды прокси
1585. Разница аннотаций Service, Repository, Controller
1586. Как оптимизировать запросы к БД? 
1587. Какие паттерны проектирование используешь?
1588. типы Join
1589. having, where
1590. Задача на собеседовании на SQL
1591. Индексы
1592. куда будет вставляться строка быстрее
1593. партиционирование и explain
1594. какие есть scope в Spring?
1595. какой scope используется по умолчанию? 
1596. где использовал прототайп?
1597. аннотации, в чем их разница?
1598. разница RestController и Controller?
1599. где используется Bean?
1600. конфигурация Spring-приложени
1601. Знакомы ли Вам какие-либо паттерны проектирования?
1602. Напишите Singleton… А с ленивой загрузкой. А если он должен быть потоко-безопасным? А в каких случаях ленивая загрузка хуже?
1603. Что можете сказать про MVC? Нарисуйте диаграмму и объясните, как MVC работает.
1604. Напишите функцию вычисления факториала.

Вот пример функции на Java для вычисления факториала:
```java
public static int factorial(int n) {
  if (n == 0) {
    return 1;
  } else {
    return n * factorial(n-1);
  }
}
```
Эта функция использует рекурсию для вычисления факториала. Если n равно 0, то функция возвращает 1. В противном случае, функция вызывает саму себя с аргументом n-1 и умножает n на результат этого вызова.
```java
int n = 5;
int result = factorial(n);
System.out.println("Факториал числа " + n + " равен " + result);
```
Этот код выведет на консоль: "Факториал числа 5 равен 120".


# 5 Блок вопросов (Чаcто задаваемые запросы в поисковике Яндекс)

1605. `Как сделать ввод с клавиатуры в Java?`

Для ввода данных с клавиатуры в Java вы можете использовать класс Scanner.

Вот пример:
```java
import java.util.Scanner;

public class MyClass {
  public static void main(String[] args) {
    Scanner myScanner = new Scanner(System.in);
    System.out.println("Введите значение:");
    String userInput = myScanner.nextLine();
    System.out.println("Вы ввели: " + userInput);
  }
}
```
В этом примере мы создали объект Scanner с именем myScanner и использовали метод nextLine() для чтения строки, введенной пользователем. Мы затем использовали эту строку в качестве части результирующего выражения при выводе на консоль.

Вы можете использовать методы nextInt(), nextDouble() и т.д. для чтения других типов данных из консоли.

Однако, обратите внимание, что Scanner может бросить исключение, если ввод пользователя не соответствует ожидаемому типу или формату данных. Поэтому рекомендуется использовать соответствующие методы hasNext...() для проверки, корректен ли ввод пользователя, прежде чем читать данные.

1606. `Как сделать список списков Java?`

Чтобы создать список списков (List of Lists) в Java, вы можете использовать ArrayList<ArrayList> таким образом:
```java
ArrayList<ArrayList<Integer>> list = new ArrayList<>();
ArrayList<Integer> innerList1 = new ArrayList<>();
innerList1.add(1);
innerList1.add(2);
list.add(innerList1);
ArrayList<Integer> innerList2 = new ArrayList<>();
innerList2.add(3);
innerList2.add(4);
list.add(innerList2);
```
Здесь создается список списков list, который содержит два внутренних списка innerList1 и innerList2. Вы можете добавлять / удалять элементы из внутренних списков или изменять их как обычные списки. Для этой задачи также могут использоваться многомерные массивы, но если вам нужно изменять размер списка, то ArrayList будет удобнее.
```java
ArrayList<ArrayList<Integer>> list = new ArrayList<>(2); 

list.add(new ArrayList<Integer>());
list.get(0).add(1);
list.get(0).add(2);

list.add(new ArrayList<Integer>());
list.get(1).add(3);
list.get(1).add(4);
```
Здесь мы создаём список размера 2 и добавляем в него два внутренних списка.

Result: Создание списка списков в Java с помощью ArrayList



