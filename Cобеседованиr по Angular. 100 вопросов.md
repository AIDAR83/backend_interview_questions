Нажмите ★, если вам нравится проект. Ваш вклад сердечно ♡ приветствуется.

Если вам интересно мое резюме: https://github.com/DEBAGanov


## 1. `Каковы различия между декоратором Angular и аннотацией?`

Декораторы и аннотации в Angular имеют различные функции и синтаксис.

Декораторы в Angular используются для добавления метаданных к классам, методам, свойствам и параметрам. Они представляют собой специальные функции, которые применяются к элементам кода с помощью символа @. Декораторы позволяют определить различные аспекты поведения и конфигурации элементов Angular, таких как компоненты, сервисы, директивы и т. д. Некоторые из наиболее часто используемых декораторов в Angular включают @Component, @Directive, @Injectable и @Input.

Аннотации в Angular, с другой стороны, являются способом добавления дополнительной информации к типам данных в TypeScript. Аннотации используются для определения типов параметров функций, свойств классов и других элементов кода. Они представляют собой специальные комментарии, которые начинаются с символа @. Аннотации в Angular используются вместе с декораторами для определения типов данных и метаданных элементов Angular.

Таким образом, различия между декораторами и аннотациями в Angular заключаются в их функциональности и синтаксисе. Декораторы используются для добавления метаданных к элементам Angular, в то время как аннотации используются для определения типов данных в TypeScript.

## 2. `Что такое AOT-компиляция в Angular (Ahead-of-Time компиляция)?`

AOT-компиляция (Ahead-of-Time компиляция) в Angular - это процесс преобразования кода Angular HTML и TypeScript в эффективный JavaScript-код во время этапа сборки перед запуском в браузере

Основное отличие AOT-компиляции от JIT-компиляции (Just-in-Time компиляции) заключается в том, что при AOT-компиляции код Angular преобразуется в JavaScript до запуска приложения, в то время как при JIT-компиляции преобразование происходит во время выполнения приложения в браузере.

Преимущества AOT-компиляции в Angular включают:

+ Улучшенную производительность: AOT-компиляция позволяет уменьшить размер и сложность кода, что приводит к более быстрой загрузке и выполнению приложения.
+ Более раннее обнаружение ошибок: AOT-компиляция позволяет обнаружить некоторые ошибки во время этапа сборки, что помогает предотвратить возможные проблемы во время выполнения приложения.
+ Улучшенную безопасность: AOT-компиляция позволяет обнаружить потенциальные уязвимости в коде на этапе сборки, что помогает улучшить безопасность приложения.
+ AOT-компиляция в Angular может быть выполнена с помощью Angular CLI, добавив флаг --aot при выполнении команды сборки, например: ng build --aot .

## 3. `Что такое динамические компоненты?`

Динамические компоненты в Angular позволяют создавать и добавлять компоненты в приложение во время выполнения. Они представляют собой способ генерации и управления компонентами динамически, без необходимости определения их статически в шаблоне.

Для создания динамических компонентов в Angular используются методы createComponent() и ComponentFactoryResolver. Метод createComponent() позволяет создавать экземпляры компонентов, а ComponentFactoryResolver используется для получения фабрики компонента, которую можно использовать для создания экземпляров компонента.

Пример использования динамических компонентов в Angular:
```javascript
import { Component, ComponentFactoryResolver, ViewChild, ViewContainerRef } from '@angular/core';

@Component({
  template: `<div><ng-container #dynamicContent></ng-container></div>`,
})
export class AppComponent {
  @ViewChild("dynamicContent", { read: ViewContainerRef })
  public dynamicContainer: ViewContainerRef;

  constructor(private componentFactoryResolver: ComponentFactoryResolver) {}

  createDynamicComponent() {
    // Получение фабрики компонента
    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(DynamicComponent);

    // Создание экземпляра компонента
    const componentRef = this.dynamicContainer.createComponent(componentFactory);
  }
}
```
В приведенном примере AppComponent содержит ViewContainerRef, который представляет контейнер для динамически создаваемых компонентов. Метод createDynamicComponent() использует ComponentFactoryResolver для получения фабрики компонента DynamicComponent, а затем создает экземпляр компонента с помощью createComponent().

Важно отметить, что динамические компоненты в Angular могут быть полезны при создании динамических макетов, модальных окон, компонентов, которые должны быть добавлены или удалены в зависимости от условий, и других сценариев, требующих гибкости и динамического управления компонентами.




## 4. `Что такое модули в Angular?`

Модули в Angular - это способ организации и структурирования приложения на Angular. Модули позволяют разделить функциональность приложения на отдельные блоки, называемые модулями. Каждый модуль содержит компоненты, сервисы, директивы и другие ресурсы, связанные с определенной функциональностью приложения.

Модули в Angular предоставляют следующие преимущества:

Логическая организация: Модули позволяют разделить функциональность приложения на логические блоки, что делает код более понятным и поддерживаемым.
Изоляция: Каждый модуль имеет свою собственную область видимости, что позволяет изолировать компоненты и сервисы от других частей приложения.
Ленивая загрузка: Модули могут быть загружены только по требованию, что улучшает производительность приложения и уменьшает время загрузки.
Переиспользование: Модули могут быть повторно использованы в разных приложениях или в разных частях одного приложения.

NgModule - это декоратор, который используется для определения модуля в Angular. Он применяется к классу модуля и принимает объект конфигурации, который определяет компоненты, сервисы и другие ресурсы, связанные с модулем.

Пример использования декоратора NgModule:
```javascript
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```


В приведенном примере AppModule является корневым модулем приложения. Он импортирует BrowserModule, который предоставляет функциональность для работы с браузером, и объявляет AppComponent в качестве компонента, который будет использоваться в модуле.

## 5. `Что такое сервисы в Angular?`

Сервисы в Angular - это классы, которые предоставляют функциональность и могут быть использованы в разных частях приложения. Они используются для разделения логики и общих функций между компонентами, директивами и другими классами Angular.

Сервисы в Angular обычно используются для выполнения следующих задач:

Получение данных с сервера или других источников данных.
Хранение и обработка данных, которые должны быть доступны в разных частях приложения.
Реализация общей функциональности, такой как аутентификация, логирование и обработка ошибок.
Взаимодействие с внешними библиотеками или сервисами.
Сервисы в Angular могут быть созданы с помощью ключевого слова @Injectable и зарегистрированы в модуле приложения или компоненте с помощью массива providers. Это позволяет Angular создавать и предоставлять экземпляр сервиса внедрения зависимостей (DI) при создании компонента или другого класса.

Пример регистрации сервиса в модуле Angular:
```javascript
import { NgModule } from '@angular/core';
import { MyService } from './my.service';

@NgModule({
  providers: [MyService]
})
export class AppModule { }
```

После регистрации сервиса в модуле, он может быть внедрен в компоненты или другие классы, используя DI. Например, в компоненте можно внедрить сервис следующим образом:
```javascript
import { Component } from '@angular/core';
import { MyService } from './my.service';

@Component({
  selector: 'app-my-component',
  template: '...',
})
export class MyComponent {
  constructor(private myService: MyService) { }
}
```

Важно отметить, что сервисы в Angular могут быть созданы в разных режимах жизненного цикла, таких как синглтон, когда создается только один экземпляр сервиса на всё приложение, или новый экземпляр сервиса для каждого компонента. Выбор режима жизненного цикла зависит от требований и особенностей приложения.


## 6. `Что такое жизненный цикл компонента в Angular?`

Жизненный цикл компонента в Angular - это последовательность событий и методов, которые происходят при создании, обновлении и уничтожении компонента в Angular. Жизненный цикл компонента предоставляет разработчикам возможность выполнять определенные действия на разных этапах жизненного цикла компонента, таких как инициализация, обновление и уничтожение.

Методы жизненного цикла компонента в Angular
В Angular есть несколько методов жизненного цикла компонента, которые разработчики могут использовать для выполнения определенных действий на разных этапах жизненного цикла компонента. Некоторые из этих методов включают:

+ ngOnChanges: Этот метод вызывается, когда значения входных свойств компонента изменяются. Он принимает объект SimpleChanges, который содержит информацию о предыдущих и текущих значениях входных свойств..
+ ngOnInit: Этот метод вызывается после того, как Angular инициализирует компонент и устанавливает входные свойства. Он используется для выполнения инициализационных действий, таких как получение данных с сервера или настройка компонента..
+ ngDoCheck: Этот метод вызывается при каждом изменении в компоненте, включая изменения входных свойств, события и обнаружение изменений, которые Angular не может обнаружить самостоятельно. Он позволяет разработчикам выполнять дополнительные проверки и действия при изменении компонента..
+ ngAfterContentInit: Этот метод вызывается после того, как Angular вставляет внешний контент в представление компонента. Он используется для выполнения действий, которые требуют доступа к внешнему контенту, например, инициализация дочерних компонентов..
+ ngAfterContentChecked: Этот метод вызывается после каждой проверки внешнего контента компонента. Он используется для выполнения действий, которые требуют доступа к внешнему контенту и проверки его изменений..
+ ngAfterViewInit: Этот метод вызывается после инициализации представления компонента и его дочерних компонентов. Он используется для выполнения действий, которые требуют доступа к представлению компонента, например, инициализация сторонних библиотек или установка обработчиков событий..
+ ngAfterViewChecked: Этот метод вызывается после каждой проверки представления компонента и его дочерних компонентов. Он используется для выполнения действий, которые требуют доступа к представлению компонента и проверки его изменений..
+ ngOnDestroy: Этот метод вызывается перед уничтожением компонента. Он используется для выполнения действий, таких как отписка от подписок, очистка ресурсов или отмена запущенных процессов..

Пример использования методов жизненного цикла компонента в Angular:
```javascript
import { Component, OnInit, OnDestroy } from '@angular/core';

@Component({
  selector: 'app-my-component',
  template: `
    <h1>{{ title }}</h1>
  `
})
export class MyComponent implements OnInit, OnDestroy {
  title: string;

  ngOnInit() {
    this.title = 'Hello, Angular!';
    console.log('Component initialized');
  }

  ngOnDestroy() {
    console.log('Component destroyed');
  }
}
```

В приведенном выше примере компонент MyComponent реализует интерфейсы OnInit и OnDestroy, что позволяет использовать методы ngOnInit и ngOnDestroy. В методе ngOnInit устанавливается значение переменной title и выводится сообщение в консоль при инициализации компонента. В методе ngOnDestroy выводится сообщение в консоль перед уничтожением компонента.

Обратите внимание: При использовании методов жизненного цикла компонента в Angular, важно следить за правильным использованием и избегать выполнения длительных операций в методах, которые могут замедлить работу приложения.

## 8. `Чем наблюдаемые отличаются от обещаний?`

## 9. `Что такое бутстрэппинг?`

## 10. `Что вы подразумеваете под внедрением зависимостей?`

## 11. `Описать аутентификацию и авторизацию Angular.`

## 12. `Что такое процесс цикла дайджеста в Angular?`

## 13. `Что такое угловой маршрутизатор?`

## 14. `Что такое ОТДЫХ?`

## 15. `Объясните Angular CLI.`

## 16. `Что такое схема?`

## 17. `Что такое HttpClient и каковы его преимущества?`

## 18. `Что такое многоадресная рассылка в Angular?`

## 19. `Что такое директива в Angular?`

## 23. `Как обмениваться данными между компонентами в Angular?`

## 24. `Что такое складывание?`

## 25. `Что такое NoopZone?`

## 26. `Что такое макросы?`

## 27. `Какова цель общего модуля в Angular?`

## 28. `Какие типы компиляторов используются в Angular?`

## 29. `Какова поддержка Angular Elements в браузере?`

## 30. `Какова роль SPA в Angular?`

## 31. `Что произойдет, если вы не предоставите обработчик для наблюдателя?`

## 32. `Что вы подразумеваете под интерполяцией строк?`

## 33. `Что вы подразумеваете под привязкой данных?`

## 34. `Что такое проекция контента?`

## 35. `Что такое шаблонные выражения?`

## 35. `Что такое двусторонняя привязка данных в Angular?`

## 36. `Что такое декораторы и их типы в Angular?`

## 43. `Что такое обнаружение изменений и как работает механизм обнаружения изменений?`

## 44. `Что происходит, когда вы используете тег скрипта в шаблоне?`

## 45. `Когда использовать директиву?`

## 46. `Что такое интерполяция?`

## 47. `В чем разница между чистой и нечистой трубой?`

## 48. `Что такое наблюдаемые?`

## 49. `Что такое пользовательские элементы?`

## 50. `Каковы различные виды директив?`

## 51. `Всегда ли нам нужен модуль маршрутизации?`

## 52. `Что такое (JIT)?`

## 53. `Какова цель файлов метаданных JSON?`

## 54. `Как вы описываете различные зависимости в приложениях Angular?`

## 55. `Что такое декораторы классов в Angular?`

## 56. `Что произойдет, если я импортирую один и тот же модуль дважды?`

## 57. `Каковы способы запуска обнаружения изменений в Angular?`

## 58. `Каковы принципы безопасности в angular?`

## 59. `Каковы принципы безопасности в angular?`

## 60. `Что такое интерфейс командной строки Schematics?`

## 70. `В чем разница между ViewEncapsulation и Shadow DOM в Angular?`

## 71. `Что такое защита маршрута в Angular?`

## 72. `Что такое угловой материал?`

## 73. `Какова цель декоратора NgModule в Angular?`

## 74. `Что такое внедрение зависимостей в Angular?`

## 75. `В чем разница между HttpClient и Http в Angular?`

## 76. `В чем разница между HttpClient и Http в Angular?`

## 77. `Какова цель элемента ng-container в Angular?`

## 78. `Что такое угловая защита?`

## 79. `В чем разница между асинхронным каналом и методом подписки в Angular?`

## 80. `Как вы обмениваетесь данными между компонентами в Angular?`

## 81. `Что такое преобразователь в Angular?`

## 82. `Что такое провайдер в Angular?`

## 83. `В чем разница между сервисом и компонентом в Angular?`

## 84. `В чем разница между ElementRef и Renderer2 в Angular?`

## 85. `В чем разница между формой, управляемой шаблоном, и реактивной формой в Angular?`

## 86. `Что такое сервисный работник Angular?`

## 87. `В чем разница между шаблоном и представлением в Angular?`

## 88. `Что такое механизм обнаружения изменений Angular?`

## 89. `В чем разница между сервисом и компонентом в Angular?`

## 90. `Что такое ссылочная переменная шаблона Angular?`

## 91. `Что такое декоратор ViewChild в Angular?`

## 92. `В чем разница между формой, управляемой шаблоном, и реактивной формой в Angular?`

## 93. `Что такое модуль Angular?`

## 94. `Что такое NgZone в Angular?`

## 95. `В чем разница между ngOnInit и ngAfterViewInit в Angular?`

## 96. `Какова цель декоратора HostListener в Angular?`

## 97. `Какова цель директивы ng-template в Angular?`

## 98. `Какова цель службы ActivatedRoute в Angular?`

## 99. `Какова цель синтаксиса async/await в Angular?`

## 100. `Какова цель директивы ngClass в Angular?`
