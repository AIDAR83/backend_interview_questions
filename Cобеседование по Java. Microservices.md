# Cобеседование по Java Микросервисы. Разбор вопросов и ответов.


<a href="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%">
    <img src="https://mc.yandex.ru/pixel/8711235002931986822?rnd=%aw_random%" />
  </a>&nbsp;&nbsp;
<a href="https://mc.yandex.ru/watch/92801430">
    <img src="https://mc.yandex.ru/watch/92801430" />
  </a>&nbsp;&nbsp;


Нажмите ★, если вам нравится проект. Ваш вклад сердечно ♡ приветствуется.

Если вам интересно мое резюме: https://github.com/DEBAGanov




1. Что вы знаете о микросервисах?

Микросервисы - это архитектурный подход к разработке программного обеспечения, в котором приложение разбивается на небольшие и независимые сервисы, каждый из которых выполняет конкретную функцию. Каждый микросервис может быть разработан, развернут и масштабирован независимо от других сервисов в приложении.

Преимущества микросервисной архитектуры:
Гибкость и масштабируемость: Микросервисы позволяют разрабатывать и масштабировать каждый сервис независимо, что облегчает внесение изменений и обеспечивает гибкость в разработке приложений.

Отказоустойчивость: Если один микросервис выходит из строя, остальные сервисы продолжают работать, что повышает отказоустойчивость системы в целом.

Улучшенная командная работа: Каждый микросервис может быть разработан и поддерживаться отдельной командой, что способствует более эффективной командной работе и ускоряет процесс разработки.

Технологичесное разнообразие: Микросервисы позволяют использовать различные технологии и языки программирования для каждого сервиса, в зависимости от его потребностей.

Основные компоненты микросервисной архитектуры:
Сервисный реестр (Service Registry): Это компонент, который отслеживает доступные микросервисы и их местоположение. Он позволяет другим сервисам обнаруживать и взаимодействовать с нужными сервисами.

Circuit Breaker: Это механизм, который предотвращает распространение сбоев в системе. Он обеспечивает отказоустойчивость, переключая запросы на альтернативные сервисы или возвращая значения по умолчанию, если сервис недоступен.

API Gateway: Это компонент, который предоставляет единый точку входа для клиентов и маршрутизирует запросы к соответствующим микросервисам.

Saga Pattern: Это паттерн, который обеспечивает согласованность данных и выполнение транзакций в распределенной среде. Он используется для управления долгоживущими транзакциями, которые включают несколько микросервисов.

Event Sourcing Pattern: Это паттерн, который сохраняет все изменения состояния системы в виде событий. Он позволяет восстанавливать состояние системы на основе событий и обеспечивает аудит и воспроизводимость данных.

Command Query Responsibility Segregation (CQRS): Это паттерн, который разделяет операции записи и операции чтения в системе. Он позволяет оптимизировать производительность и масштабируемость системы, разделяя обработку команд и запросов.

Bulkhead Pattern: Это паттерн, который изолирует компоненты системы друг от друга, чтобы предотвратить распространение сбоев. Он обеспечивает отказоустойчивость и предотвращает полное отключение системы при сбое одного компонента.

Backends for Frontends (BFF): Это паттерн, который предоставляет отдельные бэкенды для различных клиентских интерфейсов. Он позволяет оптимизировать взаимодействие между клиентами и микросервисами, предоставляя специфические API для каждого клиента.


2. Каковы характеристики микросервисов?

Микросервисы - это архитектурный подход, в котором приложение разбивается на небольшие независимые компоненты, называемые микросервисами. Каждый микросервис выполняет определенную функцию и может быть разработан, развернут и масштабирован независимо от других микросервисов.

Вот некоторые характеристики микросервисов:

+ Разделение обязанностей: Каждый микросервис отвечает только за определенную функцию или задачу. Это позволяет разработчикам сосредоточиться на конкретной функциональности и упрощает поддержку и развитие приложения.
+ Независимость: Микросервисы могут быть разработаны, развернуты и масштабированы независимо друг от друга. Это означает, что разработчики могут обновлять и изменять каждый микросервис отдельно, без влияния на остальные компоненты системы.
+ Гибкость: Микросервисы могут быть написаны на разных языках программирования и использовать различные технологии и инструменты. Это позволяет командам разработчиков использовать наиболее подходящие технологии для каждого микросервиса и упрощает интеграцию с другими системами.
+ Масштабируемость: Благодаря независимости каждого микросервиса, их можно горизонтально масштабировать, добавляя новые экземпляры микросервисов при необходимости. Это позволяет обрабатывать большие объемы трафика и обеспечивает высокую отказоустойчивость системы.
+ Легкость развертывания: Микросервисы могут быть развернуты отдельно, что упрощает процесс развертывания и обновления приложения. Каждый микросервис может быть развернут на отдельном сервере или контейнере, что улучшает изоляцию и безопасность.
+ Легкость тестирования: Микросервисы могут быть легко тестированы в изоляции. Это позволяет разработчикам быстро проверять функциональность каждого микросервиса и обнаруживать ошибки и проблемы на ранних стадиях разработки.

В целом, микросервисы обеспечивают гибкую и масштабируемую архитектуру, которая позволяет разработчикам эффективно разрабатывать, развертывать и масштабировать сложные приложения.

3. Каковы лучшие практики разработки микросервисов?

Разработка микросервисов является широко распространенной практикой в современной архитектуре программного обеспечения. Вот некоторые из лучших практик, которые помогут вам успешно разрабатывать микросервисы:

Разделение функциональности: Разбейте ваше приложение на отдельные микросервисы, каждый из которых отвечает только за определенную функцию или возможность. Это поможет упростить разработку, развертывание и масштабирование вашей системы.

Контейнеризация: Используйте контейнеры, такие как Docker, для упаковки и изоляции каждого микросервиса. Это позволяет легко развертывать и масштабировать микросервисы, а также обеспечивает независимость их работы.

Коммуникация через API: Определите четкий и гибкий интерфейс для взаимодействия между микросервисами. Используйте RESTful API или сообщения, такие как RabbitMQ или Apache Kafka, для обмена данными между сервисами.

Надежность и отказоустойчивость: Разработайте микросервисы с учетом возможности отказа других сервисов. Используйте механизмы обработки ошибок, резервное копирование и мониторинг, чтобы обеспечить надежную работу вашей системы.

Масштабируемость: Разрабатывайте микросервисы таким образом, чтобы они могли масштабироваться горизонтально. Это позволит вам управлять растущей нагрузкой, добавляя дополнительные экземпляры сервисов по мере необходимости.

Тестирование: Проводите регулярное модульное и интеграционное тестирование каждого микросервиса, чтобы обеспечить его правильную работу и совместимость с другими сервисами.

Мониторинг и трассировка: Внедрите механизмы мониторинга и трассировки, чтобы отслеживать работу каждого микросервиса и идентифицировать проблемы или узкие места.

Безопасность: Обеспечьте безопасность каждого микросервиса, используя механизмы аутентификации, авторизации и шифрования данных.

Учет этих лучших практик поможет вам создать гибкую, масштабируемую и отказоустойчивую архитектуру микросервисов.

4. Как работает микросервисная архитектура?

Микросервисная архитектура - это подход к разработке программного обеспечения, при котором приложение разбивается на небольшие, независимые сервисы, каждый из которых выполняет конкретную функцию. Каждый сервис может быть разработан, развернут и масштабирован независимо от других сервисов в системе. Это позволяет достичь более гибкой и масштабируемой архитектуры, где каждый сервис может быть разработан и поддерживаться отдельной командой разработчиков.

Преимущества микросервисной архитектуры:

+ Гибкость: Микросервисы могут быть разработаны и развернуты независимо друг от друга, что позволяет командам разработчиков работать над ними параллельно и вносить изменения без влияния на другие сервисы.
+ Масштабируемость: Каждый сервис может быть масштабирован отдельно в зависимости от его нагрузки, что позволяет более эффективно использовать ресурсы и обеспечивать высокую производительность системы в целом.
+ Устойчивость к отказам: Если один сервис выходит из строя, остальные сервисы продолжают работать нормально, что обеспечивает более высокую отказоустойчивость системы.
+ Легкость в развертывании и обновлении: Каждый сервис может быть развернут и обновлен независимо от других сервисов, что упрощает процесс развертывания и обновления системы.

Примеры использования микросервисной архитектуры в Java:
+ Spring Boot: Spring Boot является популярным фреймворком для разработки микросервисов на языке Java. Он предоставляет удобные инструменты и библиотеки для создания и развертывания самостоятельных сервисов. Например, Spring Data MongoDB позволяет работать с базой данных MongoDB в микросервисной архитектуре.
+ Java EE: Java EE (Enterprise Edition) также предоставляет набор инструментов и спецификаций для разработки микросервисов на Java. Например, Java EE включает в себя фреймворк Spring MVC для разработки REST API.


5. Каковы преимущества и недостатки микросервисной архитектуры?
Микросервисная архитектура имеет несколько преимуществ и недостатков. Вот некоторые из них:

Преимущества микросервисной архитектуры:

+ Гибкость и масштабируемость: Микросервисы могут быть разработаны и развернуты независимо друг от друга, что позволяет гибко масштабировать систему в зависимости от потребностей. Это также упрощает добавление новых функций и изменение существующих без влияния на другие сервисы.
+ Легкость в сопровождении: Каждый микросервис отвечает только за определенную функциональность, что упрощает понимание и сопровождение кода. Команды разработчиков могут работать над разными сервисами независимо друг от друга, что повышает производительность.
+ Устойчивость к сбоям: Если один микросервис выходит из строя, это не приводит к полному отказу системы. Остальные сервисы продолжают работу, что обеспечивает более высокую доступность и надежность системы.
+ Использование разных технологий: Разные микросервисы могут быть разработаны с использованием разных технологий и языков программирования в зависимости от их специфических требований. Это позволяет выбирать наиболее подходящие инструменты для каждого сервиса.

Недостатки микросервисной архитектуры:

+ Сложность управления: Управление микросервисной архитектурой может быть сложным из-за необходимости отслеживать и контролировать множество сервисов. Это может потребовать дополнительных усилий для мониторинга, отладки и обновления каждого сервиса.
+ Сетевая сложность: Взаимодействие между микросервисами происходит через сеть, что может привести к задержкам и потере производительности. Необходимость обеспечения надежности и безопасности сетевого взаимодействия также может быть вызовом.
+ Увеличенные затраты на инфраструктуру: Каждый микросервис требует собственной инфраструктуры и ресурсов, что может повлечь дополнительные затраты на оборудование и поддержку.
+ Сложность тестирования: Тестирование микросервисной архитектуры может быть сложным из-за необходимости проверять взаимодействие между разными сервисами. Это требует более сложной инфраструктуры тестирования и стратегии тестирования.

Несмотря на некоторые недостатки, микросервисная архитектура становится все более популярной из-за своей гибкости и масштабируемости. Решение о ее применении должно быть основано на конкретных потребностях и ограничениях проекта.


6. Монолитная, в чем разница между SOA и микросервисной архитектурой?

Монолитная архитектура и микросервисная архитектура - это два разных подхода к разработке и построению программного обеспечения.

Монолитная архитектура представляет собой подход, при котором вся функциональность приложения находится в одном целом - монолите. В монолитной архитектуре все компоненты приложения взаимодействуют непосредственно друг с другом. Все эти компоненты разворачиваются вместе и масштабируются вместе. Обновления и изменения в монолите требуют пересборки всего приложения.

С другой стороны, микросервисная архитектура представляет собой подход, при котором приложение разбивается на небольшие, самостоятельные и независимые сервисы, которые взаимодействуют друг с другом через сетевые вызовы. Каждый сервис выполняет конкретную функцию и может быть развернут, масштабирован и обновлен независимо от других сервисов. Микросервисная архитектура облегчает масштабирование и поддержку приложения, так как изменения и обновления могут быть внесены только в отдельные сервисы, без необходимости пересборки всего приложения.

Основное отличие между монолитной и микросервисной архитектурами заключается в масштабируемости и гибкости. Монолитная архитектура проста в разработке и развертывании, но может стать сложной для масштабирования и поддержки в случае больших и сложных приложений. Микросервисная архитектура обеспечивает большую гибкость и масштабируемость, но требует более сложной инфраструктуры и управления.

В итоге, выбор между монолитной и микросервисной архитектурами зависит от требований и характеристик конкретного проекта. Каждая архитектура имеет свои преимущества и недостатки, и разработчики должны выбирать наиболее подходящий подход в каждом конкретном случае.

7. С какими проблемами вы сталкиваетесь при использовании микросервисной архитектуры?

При использовании микросервисной архитектуры могут возникать следующие проблемы:

Сложность управления: Когда у вас есть множество микросервисов, каждый из них требует отдельного управления, мониторинга и масштабирования. Это может привести к сложностям в обнаружении и устранении проблем, а также в управлении зависимостями между сервисами.

Коммуникация и координация: Взаимодействие между микросервисами может быть сложным и требовать дополнительных усилий для обеспечения согласованности данных и управления транзакциями. Координация между различными командами разработчиков также может быть сложной задачей.

Управление данными: Микросервисная архитектура может привести к проблемам с управлением данными, так как каждый сервис обычно имеет свою собственную базу данных. Это может усложнить поиск и анализ данных, а также создание единой истинной версии данных.

Надежность и отказоустойчивость: В микросервисной архитектуре каждый сервис может выходить из строя независимо от других сервисов. Это означает, что необходимо предусмотреть механизмы отказоустойчивости и резервного копирования, чтобы минимизировать простои и сбои в системе.

Культура и организационные изменения: Внедрение микросервисной архитектуры может потребовать изменения в культуре и организации компании. Это может включать в себя изменения в процессах разработки, коммуникации и управлении, а также в разделении обязанностей и ответственности.

Важно отметить, что эти проблемы не являются неизбежными и могут быть решены с помощью правильного планирования, архитектуры и управления проектом. Однако их учет и решение может потребовать дополнительных усилий и ресурсов.

8. В чем основное различие между SOA и микросервисной архитектурой?

SOA (Service-Oriented Architecture) и микросервисная архитектура (Microservices Architecture) - это два разных подхода к построению распределенных систем. Вот основные различия между ними:

Масштабирование: SOA подразумевает создание нескольких служб, которые могут быть масштабированы независимо друг от друга. Однако, микросервисная архитектура делит приложение на небольшие, независимые сервисы, каждый из которых может быть масштабирован отдельно.

Гранулярность: SOA обычно ориентирована на создание крупных служб, которые предоставляют большой функционал. В то время как микросервисная архитектура стремится к созданию маленьких, специализированных сервисов, каждый из которых выполняет конкретную функцию.

Коммуникация: В SOA, службы обычно взаимодействуют друг с другом посредством протокола SOAP (Simple Object Access Protocol) или REST (Representational State Transfer). В микросервисной архитектуре, межсервисное взаимодействие часто осуществляется с помощью легковесных протоколов, таких как HTTP или сообщения в стиле "очередей".

Управление данными: SOA обычно использует общую базу данных для хранения и обмена данными между службами. В микросервисной архитектуре, каждый сервис имеет собственную базу данных, что делает их более автономными и изолированными друг от друга.

Гибкость: Микросервисная архитектура предлагает большую гибкость и возможность для независимого развертывания и изменения каждого сервиса. SOA, с другой стороны, может быть менее гибкой из-за более жесткой архитектуры и большого масштаба служб.

В конечном счете, выбор между SOA и микросервисной архитектурой зависит от конкретных требований проекта и контекста использования. Оба подхода имеют свои преимущества и недостатки, и выбор должен быть основан на уникальных потребностях вашей системы.

9.  Что такое DDD - Domain Driven Design - Предметно-ориентированное проектирование?

Предметно-ориентированное проектирование (ПОП или DDD) - это подход к разработке программного обеспечения, который заключается в создании специализированного языка программирования или набора инструментов, ориентированных на решение конкретной предметной области или класса задач.

Предметно-ориентированное проектирование позволяет разработчикам создавать программное обеспечение, которое более точно отражает особенности и требования конкретной предметной области. Вместо того чтобы использовать общие языки программирования, такие как Java или C++, разработчики могут создавать специализированные языки, которые лучше соответствуют конкретным задачам и потребностям.

При использовании предметно-ориентированного проектирования разработчики могут создавать модели, описывающие концептуальные аспекты предметной области, и автоматически генерировать исполняемый код на основе этих моделей. Это позволяет сократить время и усилия, затрачиваемые на разработку программного обеспечения, и повысить его качество.

Преимущества предметно-ориентированного проектирования включают более высокую производительность разработки, повышенную читаемость и понятность кода, легкость сопровождения и модификации программного обеспечения, а также возможность повторного использования компонентов.

В общем, предметно-ориентированное проектирование позволяет разработчикам создавать более эффективное и гибкое программное обеспечение, специально адаптированное к конкретным потребностям предметной области.

10.  Зачем мне нужен DDD - Domain Driven Design - Предметно-ориентированное проектирование?

Доменно-ориентированный дизайн (DDD) - это подход к разработке программного обеспечения, который помогает организовать код таким образом, чтобы он отражал бизнес-логику и структуру домена предметной области. Основная идея DDD заключается в том, чтобы построить модель системы, которая полностью соответствует бизнес-процессам и предметной области, с которыми работает программа.

Основные преимущества использования DDD в разработке программного обеспечения:

Понятность и легкость сопровождения: DDD помогает создать ясную и понятную модель системы, которая отражает бизнес-логику. Это делает код более легким для чтения, понимания и сопровождения, как для новых разработчиков, так и для существующих членов команды.

Гибкость и масштабируемость: DDD позволяет разбить систему на модули, отражающие различные аспекты предметной области. Это позволяет легко добавлять новые функциональные возможности и изменять существующие без необходимости переписывать весь код. DDD также способствует легкому масштабированию системы при необходимости.

Улучшенное взаимодействие с бизнесом: DDD помогает установить эффективное взаимодействие между разработчиками и бизнес-аналитиками. Благодаря четкому отражению бизнес-логики в коде, разработчики лучше понимают требования и ожидания бизнеса, что способствует более эффективной работе.

Улучшенная тестирование: DDD способствует созданию модульных и независимых от других компонентов системы моделей. Это делает их легкими для тестирования, что повышает качество программного обеспечения.

В целом, использование доменно-ориентированного дизайна в разработке программного обеспечения помогает создать более гибкую, понятную и легко сопровождаемую систему, которая полностью отражает бизнес-процессы и потребности предметной области.
11.  Какой язык используется повсеместно?

12. Что такое сплоченность?

13. Что такое сцепление?

14. Что такое REST / RESTful и какова его цель?

15. Что вы знаете о Spring Boot?

16. Что такое привод пружинного пыльника?

17. Что такое Spring Cloud??

18. Какие проблемы решает Spring Cloud?

19. Какая польза от аннотаций WebMvcTest в приложениях Spring MVC?

20. Не могли бы вы рассказать об отдыхе и микросервисах?

21. Какие существуют типы тестирования микросервисов?
22. Что вы понимаете в распределенной транзакции?
23. Что такое идемпотенция и где она используется?
24. Что такое ограниченный контекст?
25. Что такое двухфакторная аутентификация?
26. Какие типы учетных данных используются для двухфакторной аутентификации?
27. Что такое сертификат клиента?
28. Какова цель PACT в микросервисной архитектуре?
29. Что такое OAuth?
30. Что такое закон Конвея?
31. Что вы знаете о тестировании контрактов?
32. Что такое сквозное тестирование микросервисов?
33. Для чего нужен контейнер в микросервисах?
34. Что такое DRY в микросервисной архитектуре?
35. Что такое договор, ориентированный на потребителя (CDC)?
36. Какова роль Web и RESTful API в микросервисах?
37. Что вы знаете о семантическом мониторинге в микросервисной архитектуре?
38. Как мы проводим кросс-функциональное тестирование?
39. Как устранить недетерминизм в тестировании?
40. В чем разница между макетом и заглушкой?
41. Что вы знаете о тестовой пирамиде Майка Кона?
42. Какова цель Докера?
43. Что такое канареечный релиз (Canary Releasing)?
44. Что такое непрерывная интеграция (CI)?
45. Что такое непрерывный мониторинг?
46. Какова роль архитектора в микросервисной архитектуре?
47. Можем ли мы использовать микросервисы для создания конечных автоматов?
48. Что такое реактивное расширение в микросервисах?

Вопросы на собеседовании SpringCloud
1. Что такое Spring Cloud?
2. Каковы преимущества использования Spring Cloud?
3. Что означает регистрация и обнаружение службы? Как достичь Spring Cloud?
4. В чем разница между Spring Cloud и dubbo?
5. В чем разница между SpringBoot и SpringCloud?
6. Какое значение имеет балансировка нагрузки?
7. Что такое Hystrix? Как добиться отказоустойчивости?
8. Что такое автоматический выключатель Hystrix? Оно нам нужно?
9. Что такое Netflix Feign? В чем его преимущества?
10. Что такое Spring Cloud Bus? Оно нам нужно?
11. роль автоматического выключателя springcloud
12. Что такое SpringCloudConfig?
13. Spring Cloud Gateway?



20 Основных вопросов для собеседования по архитектуре микросервисов

1. Что такое архитектура микросервисов и чем она отличается от монолитной архитектуры?
2. Как спроектировать и внедрить микросервисы?
3. Каковы ключевые характеристики хорошо спроектированного микросервиса?
4. Что такое связность в микросервисах? Какая она бывает?
5. Как микросервис Java и микросервис .NET могут взаимодействовать с teach? (подсказка: json)
6. Как решать сквозные проблемы, такие как безопасность, в архитектуре микросервисов?
7. Почему отладка так сложна в микросервисной архитектуре?
8. Как обеспечить согласованность данных в архитектуре микросервисов?
9. Как гарантировать, что микросервисы масштабируемы и устойчивы?
10. Как обрабатывать обнаружение и регистрацию служб в архитектуре микросервисов?
11. Как управлять взаимодействием служб и совместным использованием данных в архитектуре микросервисов?
12. Как управлять версиями сервисов и обратной совместимостью в архитектуре микросервисов?
13. Как отслеживать микросервисы и устранять неполадки в них?
14. Как обрабатывать развёртывания и откаты в архитектуре микросервисов?
15. Как справиться с тестированием и непрерывной интеграцией в архитектуре микросервисов?
16. В архитектуре микросервисов тестирование и непрерывная интеграция должны выполняться на уровне сервиса, с автоматизированными тестами и непрерывным конвейером доставки для каждой службы. Это позволяет осуществлять независимое развёртывание и масштабирование служб.
17. Как управлять жизненным циклом в архитектуре микросервисов?
18. Как обеспечить безопасность и контроль доступа в архитектуре микросервисов?
19. Как вы осуществляете интеграцию данных и миграцию данных в архитектуре микросервисов?
20. Как управлять составом и оркестровкой сервисов в архитектуре микросервисов?
21. Как вы развертываете свои микросервисы Java?
22. Как обеспечить отказоустойчивость сервиса в случае сбоев?
23. Какие фреймворки Java вы можете использовать для создания микросервисов?
24. Сколько микросервисов содержится в вашем проекте? Как вы находите их, если пользователь говорит, что один из его заказов отсутствует в базе данных? (подсказка — одна база данных на микросервис – это шаблон).

  15 Вопросов для собеседования по микросервисам о шаблонах и принципах проектирования
1. Что такое шаблон Gateway API и как он используется в архитектуре микросервисов? Пожалуйста, объясните, какую проблему он решает и является ли он обязательным для микросервисов или нет?
2. Можете ли вы объяснить схему автоматического выключателя и как она используется для обработки сбоев обслуживания в архитектуре микросервисов? Какую проблему это решает.
3. Что такое шаблон Command Query Responsibility Segregation (CQRS) и когда его целесообразно использовать в архитектуре микросервисов?
4. Что такое Retry pattern в микросервисах? Когда и как его использовать?
5. Зачем нежен Explain Event-Driven шаблон и как его используют в микросервисной архитектуре?
6. Зачем нежен Explain Service Registry шаблон и как его используют в микросервисной архитектуре?
7. Зачем нежен Explain Sidecar шаблон и как его используют в микросервисной архитектуре?
8. Зачем нежен Explain Backend for Frontend шаблон и как его используют в микросервисной архитектуре?
9. Зачем нежен Explain Bulkhead шаблон и как его используют в микросервисной архитектуре?
10. Зачем нежен Saga шаблон и как его используют в микросервисной архитектуре?
11. Зачем нежен Explain Outbox  шаблон и как его используют в микросервисной архитектуре?
12. Зачем нежен Self-Containment шаблон и как его используют в микросервисной архитектуре?
13. Зачем нежен Explain External Configuration шаблон и как его используют в микросервисной архитектуре?
14. Зачем нежен Strangler шаблон и как его используют в микросервисной архитектуре?







15 Вопросов для о микросервисах для опытных разработчиков



1. Как выполнить секционирование данных и репликацию данных в MS?
2. Выполняли ли вы какое-либо разделение служб и масштабирование служб в архитектуре микросервисов? Если нет, то как вы можете это сделать?
3. Объясните организацию обслуживания и хореографию обслуживания в микросервисах?
4. С какими проблемами вы сталкивались при разработке микросервисов в вашем проекте?
5. Как вы справляетесь с безопасностью служб и шифрованием служб в микросервисах?
6. Как вы будете реализовывать мониторинг служб и ведение журнала служб в архитектуре микросервисов?
7. Как вы справляетесь с отслеживанием служб и отладкой служб в архитектуре микросервисов?
8. Что такое тестирование сервиса и обеспечение качества сервиса в архитектуре микросервисов?
9. Как вы справляетесь с развертыванием служб и их откатом в архитектуре микросервисов?
10. Как вы справляетесь с управлением сервисами и жизненным циклом сервисов в архитектуре микросервисов?
11. Как вы справляетесь с миграцией служб и модернизацией сервисов в архитектуре микросервисов?
12. Как вы справляетесь с интеграцией сервисов и управлением API сервисов в архитектуре микросервисов?
13. Как вы справляетесь с производительностью сервиса и оптимизацией сервиса в архитектуре микросервисов?
14. Как убедиться, что ваши микросервисы не влияют на другие микросервисы на том же хосте?
15. Как вы организуете свои микросервисы? Остаётся ли весь код в одном и том же репозитории или вы создаёте несколько репозиториев для разных микросервисов?
16. Что лучше: разная база данных для разных микросервисов или единая база данных для всех микросервисов? Почему?1.